#+title: Information Science
#+author: ROCKTAKEY

#+options: ^:{}

#+hugo_base_dir: ../
#+hugo_section: information-science

#+link: files file+sys:../static/files/
#+link: images https://raw.githubusercontent.com/ROCKTAKEY/images/blog/%(my-org-netlify)
# ~my-org-netlify~ can be gotten from https://gist.github.com/ROCKTAKEY/e67ec5f1db4fbc9f1976fb7a3b27e2ef

* DONE Information Science
  CLOSED: [2020-08-05 Wed 17:37]
 :PROPERTIES:
 :EXPORT_FILE_NAME: _index
 :EXPORT_HUGO_LASTMOD: [2020-08-06 Wed 12:33]
 :END:

  主にEmacsの話になりそう。C++や競技プログラミングの話もするかも。
* DONE tab-bar-modeを探検する
  CLOSED: [2020-08-21 Fri 19:22]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2020-d99103ba-db6f-5424-3053-087c12ab74be
  :EXPORT_HUGO_TAGS: Emacs Emacs-Lisp tab-bar-mode
  :END:
** 導入
   Emacs-27.1で、 ~tab-bar-mode~ と ~tab-line-mode~ が追加された。

   ~tab-line-mode~ では、[[fig:tab-line-mode]]にあるように、
   ウィンドウ[fn:1:Emacsにおいては、一般に言うウィンドウをフレームと言い、フレームを分割したものをウィンドウと言う。]
   上部(ヘッダラインという)にバッファ一覧が
   タブとして表示される。バッファ切り替えを行うときにそれをクリックすることで
   バッファを切り替えられる。
   実装を見ると、どうやら ~window-next-buffers~ と ~window-prev-buffers~ を用いて
   表示するバッファを決めているようなので、さしあたりでは ~C-x b~ (~switch-bufer~)
   の一部代替、及び ~next/previous-buffer~ の代替が目的だろう。
   バッファリストが表示されるという点では ~C-x C-b~ (~list-buffer~)や ~ibuffer~ の
   代替とも捉えられるが、横幅に限りがあることと、そもそも ~window-next/prev-buffer~
   では全バッファを網羅できないことを踏まえると、完全に置き換えるには貧弱だろう。
   ~tab-line-mode~ に関しては、バッファ切り替えを文字以外で行うのに
   慣れることができそうもないので、ここまでにしておく。

   #+caption: ~global-tab-line-mode~ をオンにしたEmacs。各ウィンドウにタブ欄がある。
   #+attr_latex: scale=0.75
   #+label: fig:tab-line-mode
   [[images:tab-line-mode.png]]

   私が今回説明したいのは、 ~tab-bar-mode~ である。こちらは先程とは違い、
   *1つのフレーム[fn:1]につき1つ* 、一番上にタブ欄が表示される。
   このタブが切り替えるのはウィンドウ構成、つまりどの位置になんのバッファを表示した
   ウィンドウがあるかの情報、である。これはとても有用だ。
   単純に表示領域が足りないからというのもあるが、やはり大きいのは、
   突然別のことをやりたくなったときに今の状態を保持してさっと移り、
   終わったら戻ってこれることだ。だれしも一度は経験した、「さっきなに見てたっけ」
   「さっきまでなにがしたかったんだっけ」というのが格段に減ることだろう。
   現実世界にもはやく実装されてほしい。今まで机の上を保存したいと何度思ったことか。

   #+caption: ~tab-bar-mode~ をオンにしたEmacs。ウィンドウは複数あるがタブ欄は1つだけだ。
   #+attr_latex: scale=0.75
   #+label: fig:tab-bar-mode
   [[images:tab-bar-mode.png]]

*** ~elscreen~ との比較
   同じことをしてくれるパッケージには、
   [[https://github.com/knu/elscreen][~elscreen~]] がある。こちらも同様にウィンドウ構成を切り替えられ、今まで利用してきたが、
   いくつか欠点がある。

   一つは、タブの表示が貧弱なことだ。
   基本的にヘッダラインに表示しているので、(同じ内容なのに)全てのウィンドウで表示されたり、
   左右に分割されているウィンドウでは半分しか見えなかったりといった感じで、
   痒いところに手が届かない。やはりタイトルバーのようにフレーム一杯に広がっている領域が1つだけ欲しい。
   そういうわけで過去に[[https://github.com/conao3/navbar.el][navbar.el]]というものの制作([[https://github.com/papaeye/emacs-navbar][元]]があるので正確には改修)に少しだけ携わった
   ことがある(今もメンテナではあります)が、いかんせん古いコードだったので、かなりバギーで、
   動作が怪しい。それに比べると、 ~tab-bar-mode~ はかなり優秀だと思う。
   先程述べたとおり、 ~tab-bar-mode~ では1フレームにつき一つ、タブ一覧がフレーム一杯に広がっている。
   それでいて、GNU Emacsに取り込まれていることからある程度の動作は保証されているからだ。

   もう一つは、前段落とやや被るが、 ~elscreen~ は外部パッケージであることだ。
   あくまでもGNU Emacsの外の存在である。ウィンドウ構成周りは元々複雑でバグが入りやすいため、
   ウィンドウ構成の管理が外部パッケージだと、どうしても怪しい動作が目立つ。
   その点 ~tab-bar-mode~ はGNU Emacsに取り込まれているので、安心できる。
   もちろんバグが絶対にないわけではないが、本家に入っているなら安定性は重視されているだろう。

   ただし、もちろん利点もある。 ~elscreen~ はかなりの古参なので、拡張がたくさんある。
   ~elscreen-persist~ なんかは(MELPAからは消えているとはいえ)その筆頭だろう。
   ~tab-bar-mode~ にそのような類のものはまだないので、
   永続化したい人は乗り換えを待ったほうがいいかもしれない。


** 基本的な使い方とキーバインド
   まず、 ~M-x tab-bar-mode~ で ~tab-bar-mode~ をオンにすることで上部にタブが出てくる
   [fn:2:なお、この操作は必須ではない。名前とは矛盾するが、 ~tab-bar-mode~ がオフでも
   ~tab~ 系の関数を使うことができる。]。
   気に入ったら ~init.el~ に以下のように書けばよい。
   #+begin_src emacs-lisp :tangle yes
   (tab-bar-mode +1)
   #+end_src

   見た目については、アクティブなタブは ~tab-bar-tab~ 、
   非アクティブなタブは ~tab-bar-tab-inactive~ のfaceを変更すれば変えられる。
   といってもどちらも ~tab-bar~ にinheritしているので、
   ~tab-bar~ のほうのfaceを変えるのがお手軽かもしれない。

   と、ここまではただの見た目だ。これはとりあえず見た目を他と合わせたい自分用。
   とりあえず、先にキーバインドを示しておく。prefixは ~C-x t~ で ~tab-prefix-map~
   に登録されているので、もしこれを変えたければ適宜 ~define-key~ すればよい。

   #+caption: ~tab-bar~ 系のキーバインド(~C-x t~ は省略)
   | key        | function                     | summary                    |
   |------------+------------------------------+----------------------------|
   | ~2~        | ~tab-new~                    | タブの新規作成             |
   | ~1~        | ~tab-close-other~            | 現在のタブ以外全て削除     |
   | ~0~        | ~tab-close~                  | 現在のタブの削除           |
   | ~o~        | ~tab-next~                   | 次のタブへ移動             |
   | ~m~        | ~tab-move~                   | 現在のタブの位置を移動     |
   | ~r~        | ~tab-rename~                 | タブに名前を付ける         |
   | ~RET~      | ~tab-bar-select-tab-by-name~ | 名前でタブを選択           |
   | ~b~        | ~switch-to-buffer-other-tab~ | バッファを新しいタブで開く |
   | ~C-f~, ~f~ | ~find-file-other-tab~        | ファイルを新しいタブで開く |


   各コマンドの詳細はこれから書くが、基本は ~C-x t 2~ でさくっとタブを作り、
   おわったら ~C-x t 0~ で消す運用だろう。名前はお好みで ~C-x t r~ を使って付ける。
   一斉に消したければ ~C-x t 1~ 。これくらい覚えていれば使えると思う。

*** 各キーの説明
   ~2~ (~tab-new~)、 ~1~ (~tab-close-other~)、 ~0~ (~tab-close~)、 ~o~ (~tab-next~)に関しては、
   バッファやウィンドウを操作する ~C-x~ 系の
   ~split-window-below~ (~C-x 2~)、 ~delete-other-windows~ (~C-x 1~)、
   ~delete-window~ (~C-x 0~)、 ~other-window~ (~C-x o~)に倣っているようだ。
   たしかに、間に ~t~ を挟むだけだし、手に馴染んでいるのでわかりやすい。
   3ストロークはちと多い気もするが、連発するものでもないのでそこまで問題なさそうだ。

   ~m~ (~tab-move~)はすこしわかりづらいかもしれないが、要は表示されたタブの並び換えに使う
   ものだ。現在のタブを一つ右に移動させる。並べ替えにどれほどの需要があるかは
   不明だが、複数の関連するウィンドウ構成をまとめておきたいときには有用だろう。

   ~r~ (~tab-rename~)はタブに名前を付けるものだ。renameの名が冠されているが、
   デフォルトではタブには名前がなく、カレントバッファの名前が動的に表示される
   ([[#tab-bar-tab-name-function][こちら]]で変更可能)ので、
   名前を最初につけるときにも使うことになる。フランクに使うなら
   わざわざ名前はつけなくてもいいかもしれない。

   ~RET~ (~tab-bar-select-tab-by-name~)は名前を入力してタブを選択する形だ。
   名前がついてない場合はカレントバッファが候補の名前となる。
   ~completing-read~ を直で呼んでいるので、 ~ido~ や ~ivy~ を使いたければ 他と同様に
   ~completing-read-function~ を ~ido-completing-read~ や ~ivy-completing-read~ とすればよいだろう。

   ~b~ (~switch-to-buffer-other-tab~)、 ~f~ 、 ~C-f~ (~find-file-other-tab~)も ~C-x~ 系に倣っている。
   それぞれ選択したバッファ、ファイルを新しいタブで開くもので、丁度
   ~C-x b~ (~switch-to-buffer~)と ~C-x C-f~ (~find-file~)に対応している。

*** ~tab-bar-history-mode~
    また、 ~tab-bar-history-mode~ というものもある。これは各タブでウィンドウ構成の履歴を
    辿れるようにするものだ。よほど重たいのでなければ、オンにしない手はない。
    #+begin_src emacs-lisp :tangle yes
    (tab-bar-history-mode +1)
    #+end_src
    利用できる関数は2つだけ。 ~tab-bar-history-back~ と ~tab-bar-history-forward~ だ。
    それぞれがウィンドウ構成履歴を戻る、進む役割をもつ。
    また、タブ一覧の一番左側にでてくる2つの矢印にも同じものが割り当てられている。

** Custom variables
   この節ではカスタマイズ変数の説明をする。括弧内は初期値。
   あまり重要でなさそうなのは載せてないので、各自で調べてね☆

*** ~tab-bar-show~ (~t~)
    先述のようなタブ操作系のキーバインドを使ったときに、自動で ~tab-bar-mode~ を
    オンにして、タブを表示するかどうか。 ~t~ なら常にそうする。
    ~nil~ なら常にそうしない。 ~1~ なら2つ以上のタブがあるときだけ表示する。

*** ~tab-bar-new-tab-choice~ (~t~)
    新規タブがどの状態で始まるかどうか。 ~t~ ならカレントバッファ1つ。
    ~nil~ なら現在のタブを複製。
    文字列ならその名前のバッファ、なければファイルやディレクトリを探して開く。
    関数ならその返り値のバッファを開く。個人的には動的に決められるようになっているのが
    とても好み。よき。

*** ~tab-bar-new-button-show~ (~t~)、 ~tab-bar-close-button-show~ (~t~)
    新規タブボタン、タブ削除ボタンを表示するかどうか。~t~ なら表示、 ~nil~ なら
    非表示。 ~tab-bar-close-button-show~ の場合、 さらに
    ~selected~ (カレントタブでのみ表示)と ~non-selected~ (カレントタブ以外で表示)の二つも可能。

*** ~tab-bar-tab-hints~ (~nil~)
    タブに連番を表示するかどうか。

*** ~tab-bar-tab-name-function~ (~tab-bar-tab-name-current~)
    :PROPERTIES:
    :CUSTOM_ID: tab-bar-tab-name-function
    :END:
    名前がないとき、名前をどう決めるか。デフォルトではカレントバッファ名
    を返す ~tab-bar-tab-name-current~ ([[fig:tab-bar-tab-name-current]])となっているが、
    任意の関数に変更可能。
    windowの数を数えて付け加えてくれる ~tab-bar-tab-name-current-with-count~
    ([[fig:tab-bar-tab-name-current-with-count]])、
    長さが ~tab-bar-tab-name-truncated-max~ を超えると省略してくれる
    ~tab-bar-tab-name-truncated~ ([[fig:tab-bar-tab-name-truncated]])、
    表示されている全バッファの名前をカンマで繋げてくれる
    ~tab-bar-tab-name-all~ ([[fig:tab-bar-tab-name-all]])が用意されている。
    自身で作った関数でももちろんOK。

    #+caption: ~tab-bar-tab-name-current~ のとき(デフォルト)
    #+attr_latex: scale=0.75
    #+label: fig:tab-bar-tab-name-current
    [[images:tab-bar-tab-name-current.png]]

    #+caption: ~tab-bar-tab-name-current-with-count~ のとき
    #+attr_latex: scale=0.75
    #+label: fig:tab-bar-tab-name-current-with-count
    [[images:tab-bar-tab-name-current-with-count.png]]

    #+caption: ~tab-bar-tab-name-truncated~ のとき
    #+attr_latex: scale=0.75
    #+label: fig:tab-bar-tab-name-truncated
    [[images:tab-bar-tab-name-truncated.png]]

    #+caption: ~tab-bar-tab-name-all~ のとき
    #+attr_latex: scale=0.75
    #+label: fig:tab-bar-tab-name-all
    [[images:tab-bar-tab-name-all.png]]

*** ~tab-bar-new-tab-to~ (~right~)
    新しいタブをどこに作るか。 ~left~ や ~right~ なら現在のタブの左右に、
    ~leftmost~ や ~rightmost~ なら一番左や一番右に作る。

*** ~tab-bar-close-tab-select~ (~recent~)
    現在のタブを閉じたとき、どのタブに移動するか。
    ~recent~ なら最近利用したタブに、 ~left~ や ~right~ なら元々あったタブの左右の
    タブに移動する。

*** ~tab-bar-close-last-tab-choice~ (~nil~)
    最後の1つのタブを閉じたときにどうするか。
    ~nil~ ならなにもしない。 ~delete-frame~ なら現在のフレームを削除。
    ~tab-bar-mode-disable~ なら ~tab-bar-mode~ をオフにする。
    また、関数を渡すと閉じたときに関数を実行してくれる。

** 改造
   せっかく1フレーム1つの領域を手に入れたので、自由に表示したい。
   日付や時計、場合によってはbranchなんかも、1フレーム1つで十分だろう。

   というわけで、しくみをざっくりと見て、真似してみようではないか。
   と思って見てみると、なんだかおもしろい記述が。

   #+caption: tab-bar-mode.el L197-199
   #+begin_src emacs-lisp :tangle yes
   (global-set-key [tab-bar]
                   `(menu-item ,(purecopy "tab bar") ignore
                               :filter tab-bar-make-keymap))
   #+end_src
   どうやら ~[tab-bar]~ にメニューアイテムを割り当てると画面上部に表示できるらしい。
   おもしろい試みだ。 ~navbar.el~ ではバッファを表示させていたのに対し、
   専用の領域を用意したわけか。(試しに ~[tab-bar2]~ に同じものを割り当ててみたが、
   なにも表示されなかったので、おそらく新しく専用の領域を作ったのだろう。)

   恥ずかしながら ~menu-item~ 形式の ~global-set-key~ は初めて見たので、
   ~define-key~ のヘルプをみてみると、InfoファイルのExtended Menu Itemsの項に
   説明があるらしい。(日本語版は(24.5のものだが)[[https://ayatakesi.github.io/emacs/24.5/elisp_html/Extended-Menu-Items.html][ここ]]にある。ほとんどかわっていないので
   問題ない。)これを読むと、どうやら ~:filter~ に渡された関数 ~tab-bar-make-keymap~ は、
   3番目の ~ignore~ というシンボルを受けとり(~tab-bar~ では使ってないので適当なシンボル
   をおいているっぽい)、キーマップを返すものらしい。本来は ~ignore~ の位置に
   キーマップを直接置くが、動的に生成したいときは ~:filter~ を使う、という感じのようだ。

   ~tab-bar-make-keymap~ は内部的には ~tab-bar-make-keymap-1~ を呼んでいるだけだが、
   この関数は通常我々が使うようなキーマップとは毛色が異なり、
   ~cdr~ の各要素のほとんどは /~(symbol~/ ~menu-item~ /~string function)~/ となっている。
   /~symbol~/ は識別子で、 /~string~/ が表示される文字列だ。クリックすることで
   /~function~/ が呼び出される。もし単に文字を表示したければ、 ~tab-bar~ の
   セパレータの表示に倣って /~function~/ を ~ignore~ にすればよいだろう。

   さあこれで準備は整った。要は ~tab-bar-make-keymap-1~ をハックして、
   さっきの形式で文字列をいれてやればいいのだろう。

   というわけで ~tab-bar-display~ というパッケージを作った。

   [[https://github.com/ROCKTAKEY/tab-bar-display][https://gh-card.dev/repos/ROCKTAKEY/tab-bar-display.svg]]

   使いかたは簡単で、 ~tab-bar-display-before~ と ~tab-bar-display-after~ に
   ~format-mode-line~ 形式で表示したいものを書いて、 ~tab-bar-display-mode~
   を ~tab-bar-mode~ と共にオンにしておけば、タブ一覧の前後にそれが表示される。

   #+caption: ~tab-bar-display-mode~ を用いた例
   #+attr_latex: scale=0.75
   #+label: fig:tab-bar-display-mode
   [[images:tab-bar-display.png]]

** まとめ
   ~tab-bar-mode~ はとても便利というはなしでした。
   かなり便利そうなので ~elcreen~ を捨てて乗り換えようかしら。
* DONE chocolateyのインストールをするとMcAfeeに邪魔される
  CLOSED: [2020-08-23 Sun 21:13]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2020-0536cd60-b6e5-2e44-26db-e9d895d148be
  :EXPORT_HUGO_TAGS: chocolatey McAfee
  :END:
  Haskellのコンパイラのghcをインストールしようとしたら、
  chocolateyが必要と言われた。気になってはいたので、いれてみようと一念発起。

  [[https://chocolatey.org/install][chocolateyのインストールセクション]]にPowershell用のインストールコマンドがあるので、
  (~ExecutionPolicy AllSigned~ したあと)ペーストして実行した。が、謎のエラーが。
  #+BEGIN_SRC text -n
$ Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
発生場所 行:1 文字:1
+ Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.Service ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
このスクリプトには、悪質なコンテンツが含まれているため、ウイルス対策ソフトウェアによりブロックされています。
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : ScriptContainedMaliciousContent
  #+END_SRC
  こいつとともにMcAfeeが「ウイルスいたから殺しといたわ!」と通知してきたので、
  たぶんMcAfeeのせいだろう。ファイアウォールとリアルタイムスキャンを無効にするも、
  変わらず。お手上げかと思ったが、[[https://qiita.com/konta220/items/95b40b4647a737cb51aa#2-chocolatey%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E5%AE%9F%E8%A1%8C][Qiitaの記事]]をみつけた。ここにある画像の、3つ目のスクリプトは
  全文みえているので、一か八かで実行。
  #+BEGIN_SRC shell -n
  iwr https://chocolatey.org/install.ps1 -UseBasic Parsing | iex
  #+END_SRC
  最初のスクリプトとなんの差があったのかはわからないが、無事インストールできた。
  よかった。

* DONE grugru.el ― カーソル下のthingをじゅんぐりに入れ替える
CLOSED: [2021-11-30 Tue 23:59]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2021-eb9f86f0-ee65-1824-4063-ed0d0ba15dbf
  :EXPORT_HUGO_TAGS: Emacs Emacs-Lisp grugru
  :END:
  [[https://qiita.com/advent-calendar/2021/emacs][https://img.shields.io/badge/Emacs%20Advent%20Calendar%202021-22%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]
** 導入
   さてみなさん、突然ですが、コードを書いていて、「あっやっぱり ~true~ じゃなくて ~false~ だった」
   「 ~&&~ じゃなくて ~||~ だった」などということが多々あるのではないでしょうか。そして、往々にして、
   入れ替えることになる組み合わせは決まっているのではないでしょうか。こういうとき、いちいちバックスペースを
   連打して打ち直すのは、思考のノイズになってしまってよくありません。そこで、単一のコマンドを使って、
   あらかじめ登録しておいた一連の ~thing~ をじゅんぐりに出してくれる ~grugru.el~ というパッケージを開発しました。

   [[https://github.com/ROCKTAKEY/grugru][https://gh-card.dev/repos/ROCKTAKEY/grugru.svg]]

   とりあえず使ってみたい人は、 =M-x package-install RET grugru RET= してください
   (インストールできない場合は、[[https://emacs-jp.github.io/packages/package][ここ]]を参照)。
   その後、
   #+begin_src emacs-lisp :tangle yes
     (grugru-default-setup)
     (global-set-key (kbd "C-:") #'grugru)
     (grugru-highlight-mode)
   #+end_src
   を評価するなり =init.el= に貼り付けて再起動するなりしてみましょう。すると、じゅんぐりに変えられる
   =thing= をハイライトしてくれるようになります。そこで ~C-:~ を押下すると、次の =thing= へと置き換えてくれます。

   口で言ってもわかりにくいので、例として、C++の以下のようなソースコードを開いてみましょう。
   #+BEGIN_SRC cpp
     #include <iostream>
     #include <vector>
     #include <array>
     #include <deque>

     class c{
     private:
         float f;
     };

     int main(){
         bool b = false;

         std::vector<int> v(1, 1);

         double d;

         std::cin >> d;

         if (d || b) {
             std::cout << d << "\n";
         } else {
             std::cout << b << "\n";
         }

         return 0;
     }
   #+END_SRC
   ここにある シンボルはほとんどが ~grugru~ 可能です。以下にgifを置いておきます。
   適当なところにカーソルをもっていって、ハイライトされたら ~C-:~ を押してみてください。
   連打してもよいです。実際に使ってみたgifを以下においておきます。
   #+caption: C++におけるgrugruのデモ
    #+attr_latex: scale=0.75
    #+label: fig:c++-grugru-demo
   [[https://raw.githubusercontent.com/ROCKTAKEY/images/35e323db33f4da1545c289f2741782c4ac04968b/c++-mode.gif]]

** 自分で定義する
   ここでは ~grugru-default-setup~ を使ってあらかじめ用意されたものを ~grugru~ していますが、
   自分で定義することも可能です。定義するための関数は主に3つあります。
   - ~(grugru-define-global GETTER STRINGS-OR-GENERATOR)~
   - ~(grugru-define-on-major-mode MAJOR GETTER STRINGS-OR-GENERATOR)~
   - ~(grugru-define-local GETTER STRINGS-OR-GENERATOR)~
   書き方はとても簡単です。 ~GETTER~ の部分には、 ~symbol~ 、 ~word~ 、 ~char~ など、
   どの範囲をひとつの ~thing~ としてみなすかを指定します。
   ~STRINGS-OR-GENERATOR~ には、 ~grugru~ したい一連の文字列のリストを渡します。
   ~grugru-define-global~ はEmacs全体を通じてそれらの文字列が ~grugru~ できるようになり、
   ~grugru-define-on-major-mode~ は ~MAJOR~ で指定したメジャーモード(リストによる複数指定可)全体、
   ~grugru-define-local~ は現在のバッファのみで ~grugru~ できるようになる、という違いがあります。
   書き方の例を示します。
   #+begin_src emacs-lisp :tangle yes
     (grugru-define-global 'word '("aaaa" "bbbb" "cccc"))
     (grugru-define-on-major-mode '(c-mode c++-mode) 'symbol '("unsigned" "signed"))
     (grugru-define-local 'char '("a" "b" "c"))
     #+end_src

   基本的には、 ~GETTER~ には ~symbol~ (Lispにおける識別子的な意味合い)を選んでおけば大丈夫です。
   もし「camelCase」の「camel」の部分だけ、といった ~symbol~ 内の単語を対象にしたい場合は
   ~word~ を、連続する記号類 (~&&~ や ~>>=~ など)を対象にしたい場合は ~non-alphabet~
   を使用します。自前で定義することも可能ですが、高度な内容になるため[[#technical-configuration][高度な内容]]に預けます。

   もし大文字小文字の情報を無視して定義したい場合は、 ~STRINGS-OR-GENERATOR~ に以下のように
   書けばよいです。
   #+begin_src emacs-lisp :tangle yes
     ;; 誤植があったためコードを修正しました
     (grugru-define-global 'word (grugru-metagenerator-keep-case '("aaa" "bbb" "ccc")))
     ;; AAA -> BBB -> CCC のような `grugru' が可能!
   #+end_src
   実は ~STRINGS-OR-GENERATOR~ には ~GENERATOR~ と呼ばれる関数を書くことができますが、
   高度な内容になるため[[#technical-configuration][高度な内容]]に預けます。

   また、 ~grugru-define-global~ と ~grugru-define-on-major-mode~ はいっぺんに定義するためのマクロが
   用意されています。以下の3つは全て等価になります(上2つはLispの文法上等しい)。
   #+begin_src emacs-lisp :tangle yes
     (grugru-define-multiple
      (fundamental-mode
       . ((word . ("aaa" "bbb" "ccc"))
          (symbol . ("xxx" "yyy" "zzz"))
          (word . ("abc" "def" "ghi"))))
       (word . ("aaaa" "bbbb" "cccc"))
       (symbol . ("xxxx" "yyyyy" "zzzzz"))
       (word . ("abcd" "defd" "ghid")))

     (grugru-define-multiple
      (fundamental-mode
        (word "aaa" "bbb" "ccc")
        (symbol "xxx" "yyy" "zzz")
        (word "abc" "def" "ghi"))
       (word "aaaa" "bbbb" "cccc")
       (symbol "xxxx" "yyyyy" "zzzzz")
       (word "abcd" "defd" "ghid"))

     (progn
       (progn
          (grugru-define-on-major-mode 'fundamental-mode 'word '("aaa" "bbb" "ccc"))
          (grugru-define-on-major-mode 'fundamental-mode 'symbol '("xxx" "yyy" "zzz"))
          (grugru-define-on-major-mode 'fundamental-mode 'word '("abc" "def" "ghi")))
        (grugru-define-global 'word '("aaaa" "bbbb" "cccc"))
        (grugru-define-global 'symbol '("xxxx" "yyyyy" "zzzzz"))
        (grugru-define-global 'word '("abcd" "defd" "ghid")))
   #+end_src

   ちなみに、複雑な ~grugru~ にも対応すべく、 ~GETTER~ や ~STRING-OR-GENERATOR~ には関数を
   与えることが可能になっています。詳細はここでは省きますが、
   ~GETTER~ は引数なしでカーソル位置から ~thing~ の始点と終点のコンスセルを返し、
   ~STRING-OR-GENERATOR~ は第一引数として貰った候補が有効なら次の候補(第二引数が ~non-nil~ なら前の候補)
   を返せばよいです。

*** 高度な内容
    :PROPERTIES:
    :CUSTOM_ID: technical-configuration
    :END:
    この項の内容はやや高度です。Emacs Lispをある程度理解している方向けになります。興味のないかたは飛ばしていただいて
    かまいません。

    ~grugru-define-*~ における ~GETTER~ と ~STRINGS-OR-GENERATOR~ は、本質的には関数です。
    ~GETTER~ で指定できる ~symbol~ や ~word~ は ~grugru-getter-alist~ から ~alist-get~ を通じて関数に置き換えられます。
    ~STRINGS-OR-GENERATOR~ で指定できる文字列のリストは、 ~grugru-strings-metagenerator~ に格納された高階関数に通すことで
    関数 ~GENERATOR~ に置き換えられます。以下はそれらを内部で行っている関数です。
    #+begin_src emacs-lisp :tangle yes
      (defun grugru--get-getter-function (getter)
        "Get getter function from GETTER."
        (setq getter (or (cdr (assq getter grugru-getter-alist)) getter))
        (pcase getter
          ((pred functionp)
           getter)
          ((pred integerp)                    ;「local な `grugru' をinteractiveに定義する」を参照
           (apply-partially #'grugru--metagetter-with-integer getter))
          (_ `(lambda () ,getter))))

      (defun grugru--get-generator (strings-or-generator)
        "Return generator from STRINGS-OR-GENERATOR."
        (if (functionp strings-or-generator) strings-or-generator
          (funcall grugru-strings-metagenerator strings-or-generator)))
    #+end_src

**** Getter
    ~GETTER~ は、引数をとらず、2つのポイントをコンスセルにして返す関数です。
    返り値は ~bounds-of-thing-at-point~ と同じで、 ~car~ は現在のバッファにおける開始位置、 ~cdr~ は終了位置のポイントになります。
    ~grugru~ は、この間にある部分を ~GENERATOR~ に渡し、次の候補を得ようと試みます。

    ~GETTER~ の例として、 ~word~ に対応する ~GETTER~ を以下に示しておきます。
    #+begin_src emacs-lisp :tangle yes
      (defun grugru--getter-word ()
        "Get beginning/end of word at point."
        (if (or (eq (point) (point-at-eol))
                (string-match "[-\\[\\]_:;&+^~|#$!?%'()<>=*{}.,/\\\\\n\t]\\| "
                              (buffer-substring (point) (1+ (point)))))
            (save-excursion (cons (subword-left) (subword-right)))
          (save-excursion
            (let ((x (subword-right))
                  (y (subword-left)))
              (cons y x)))))
    #+end_src

**** Generator
    ~GENERATOR~ は、1つの引数と1つの省略可能引数をとり、 文字列 ~next-string~ 、 ~(valid-bounds . next-string)~、 ~nil~ のどれかを返します。
    一つ目の引数は文字列 ~STRING~ で、 ~GENERATOR~ はこの文字列の次の文字列を返します。もし省略可能な第二引数 ~REVERSE~ が
    ~non-nil~ である場合、次の文字列の代わりに *前* の文字列を返します。次の文字列として該当するものがない場合は ~nil~ を
    返します。 ~valid-bounds~ は ~(BEGIN . END)~ のリストです。
    これは ~bounds-of-thing-at-point~ の返り値とほぼ同じ意味合いですが、 ~STRING~ の開始位置を ~0~ としたときの位置になります。
    ~valid-bounds~ を指定するち、指定した範囲のどこにもカーソルがない場合は該当する文字列なし(つまり返り値 ~nil~)として扱ってくれます。
    次の文字列を算出するのにより広い範囲の文字列を必要とするが、事実上のターゲット文字列はもっと狭い、もしくは
    カーソル位置がある位置にない場合は対象にするべきでない、というようなケースで使えます
    (例: 関数の呼び出しに用いられている括弧だけを対象にしたい。/
    関数名を ~grugru~ するときに、一緒に引数の順番も入れ替えたいが、カーソルが引数上にあるときは対象にしたくない。)。

    ~GENERATOR~ の例として、 ~grugru-default.el~ で定義されている ~grugru-default@emacs-lisp+nth!aref~ を以下に示しておきます。
    この ~generator~ は、カーソルが ~nth~ か ~aref~ にある場合に限り、 ~(nth 1 lst)~ と ~(aref lst 1)~ のような組み合わせを
    ~grugru~ します。
    なお、 ~grugru-utils-lisp-exchange-args~ は関数呼び出し形をしたS式として ~read~ できる文字列と
    数学的な意味での置換(permutation)を与えることで、引数部分を置換した文字列を返してくれる関数です。
    #+begin_src emacs-lisp :tangle yes
      (defun grugru-default@emacs-lisp+nth!aref (str &optional _)
        "Return STR exchanged `nth' and `aref' with argument permutation."
        (cond
         ((string-match "^(\\_<\\(nth\\)\\_>" str)
          (cons
           (cons (match-beginning 1) (match-end 1))
           (grugru-utils-lisp-exchange-args
            (replace-match "aref" nil nil str 1)
            '(2 1))))
         ((string-match "^(\\_<\\(aref\\)\\_>" str)
          (cons
           (cons (match-beginning 1) (match-end 1))
           (grugru-utils-lisp-exchange-args
            (replace-match "nth" nil nil str 1)
            '(2 1))))))
    #+end_src

** local な ~grugru~ をinteractiveに定義する
   :PROPERTIES:
   :CUSTOM_ID: interactive-grugru-define
   :END:
   実は、 ~grugru-define-local~ は、interactiveに定義することができます。
   バッファ使い捨ての ~grugru~ をぱっと定義したいときに有用です。実行すると、単に置換したい
   2つの文字列を聞かれます。略語の展開のような意図で使うことを想定しているため、デフォルトの ~GETTER~ は
   「カーソルから1つ目の候補の文字列の長さ分前に戻った部分まで」となっています。
   また、リージョンがアクティブなら中身を2つ目の文字列として自動で入力されます。
   もし ~GETTER~ や置換したい文字列の数を指定したい場合は、前置引数 ~C-u~ を付けて実行してください。

   #+caption: ~grugru-define-local~ をinteractiveに使う
   #+attr_latex: scale=0.75
   #+label: fig:grugru-define-local-interactively
   [[https://raw.githubusercontent.com/ROCKTAKEY/images/698f33489645a6e7b0c29d879771dbb15fa3fcd9/grugru-define-local.gif]]

** 選択肢の中から ~grugru~ を選んで適用する
   さて、たくさんの ~grugru~ を定義すると、同じ ~thing~ に対して複数の ~grugru~ 候補がある場合が出てくる
   かもしれません。その場合、 ~grugru~ コマンドは単に一番優先度の高いものを実行します。優先度は
   「local>major-mode>global」になっていて、同じ優先度の中では「後に定義されるほど強い」というふうに
   なっています。

   しかし、せっかく定義しても使えなければ意味がありません。そこで、 ~grugru-select~ というものが用意
   されています。とても素直な関数なので使ってみればわかると思いますが、
   (あれば)複数の ~grugru~ 候補の中から適用したいものを選択し、さらにどの文字列へと置換するのかを選択する、
   というものです。この関数は、複数の ~grugru~ 候補がある場合だけでなく、 ~grugru~ をたくさん連打しないと
   目的の文字列まで到達できない時に、絞り込みによって一気に到達するのにも有用です。画像では使って
   いませんが、 ~ivy~ などの候補選択ライブラリと一緒に使うとより快適だと思います。
   #+caption: ~grugru-select~ による置換先の選択画面
   #+attr_latex: scale=0.75
   #+label: fig:grugru-select
   [[images:grugru-select.png]]

** ~grugru~ を再定義する
   ~grugru~ を実行して、やっぱりこれは違うな、と思ったとき、その場でサクっと再定義できると便利ですよね。
   設定ファイルにこだわりがない場合は、 ~grugru-edit~ を利用するとよいです。現在のカーソルで有効な
   ~grugru~ を再定義できます。

   この関数で再定義した値のうち、グローバルなものとメジャーモードローカルのものは
   ~grugru-edit-save-file~ に保存されます。 ~init.el~ に以下のような記述をすれば、
   その設定は次回起動時にも読み込まれます。
   #+begin_src emacs-lisp :tangle yes
     (grugru-edit-load)
   #+end_src
   保存されたファイルは単なるEmacs Lispの式ですので、気に入らないことがあれば手で編集しても構いません。

   ただし、 ~grugru-edit~ を使うと設定が分散してしまうので、 ~init.el~ に設定を集約することにこだわりがある人には
   おすすめできません。 ~leaf~ のキーワードにも対応していますし、当然直接定義を書いても問題ないので、
   そういう人は素直に ~init.el~ に書いてください。

   再定義関数は ~grugru-redefine-*~ のような名前になっていて、最後の引数として新しい ~STRING-OR-GENERATOR~
   を与えることで再定義できます。 ~nil~ を与えれば無効にできます。
   ~init.el~ に直接書く場合、自分で定義したものは書き換えれば済むので、
   主にデフォルトの挙動を変えたいときに使うことになりそうです。

** 独立した ~grugru~ を定義する
   ここまで、なるべく負荷を減らすべく、 ~grugru~ という単一のコマンドによって =thing= の置換を
   行うようにしてきました。しかし、時には、もしくは人によっては、「いくつかの =thing= だけを
   置換するようなコマンドを独立して定義したい」ということがあると思います。そういう人のために、
   ~grugru-define-GENERATOR~ というものが用意されています。基本的な引数は ~defun~ に準じます。
   ~body~ 部の文法はメジャーモード指定ができない以外は ~grugru-define-multiple~ と同様です。
   たとえば以下の ~three-state~ は、"water"、"ice"、"vapor"の3つと、"solid"、"liquid"、"gas"の3つ
   のみを順に置換することができ、それ以外はいっさい置換できません。
   #+begin_src emacs-lisp :tangle yes
     (grugru-define-generator three-state ()
      "Docstring. This is optional."
      (symbol . ("water" "ice" "vapor"))
      (symbol . ("solid" "liquid" "gas")))
   #+end_src

** 結論
   ここに書ききれていないことも多々ありますので、詳細は[[https://github.com/ROCKTAKEY/grugru#readme][README.org]]
   を見てね!! 質問などあれば、コメント欄、githubのDiscussionやissue(日本語可能)、メールなどなんでもいいのでぜひ
   ご連絡ください!!

   みなさんも ~grugru~ といっしょに、ストレスのないコーディングを楽しみましょう!!

** お願い
   私があまり知らない言語では、どのような =thing= が置換されうるのかが分からないため、デフォルトが
   あまり充実していないのが現状です。issueでもPRでも、SlackやTwitterのDMでも構いませんし、
   フォーマットの有無や日本語英語も問いませんので、どの言語(どれかひとつの言語で構いません)に
   どのような ~grugru~ できそうなペアがあるか(1つだけでも構いません)、教えていただけると嬉しいです。

   あと、良かったら投げ銭してってね!

* DONE Surface Laptop 1にUbuntuを(LUKSによる暗号化つきで)インストールする
CLOSED: [2022-01-31 Mon 02:50]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-27ba711f-28e9-35b4-5c13-5fb121b8023d
  :EXPORT_HUGO_TAGS: Surface-Laptop-1 Ubuntu LUKS
  :END:
基本的には[[#surface-linux-reference][参考]]にあるサイトに準拠しています。
** 必要なもの
- USBハブ (USB端子が1つしかないため、以下の2つを同時に接続するために必要)
- USBキーボード (途中までSurfaceにもとからついているキーボードは使えません)
- USBメモリ (Ubuntuのブート用)

** ブート用のUbuntuをUSBメモリに用意する
基本[[https://zenn.dev/sprout2000/articles/52caaffa9ad3fa#1.-usb-%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%AE%E4%BD%9C%E6%88%90][ここ]]のとおりにやればよい。あらかじめ作っておいてある人もいそう。ここ以外にもたくさん文献があると思うので
ここでは説明しない。

** UEFIでセキュアブートを無効にする
音量アップボタン(F6)を押しつづけながら、電源を入れる。
もしくは、Windowsを立ち上げて「設定>更新とセキュリティ>PCの起動をカスタマイズする>今すぐ再起動>
トラブルシューティング>詳細オプション>UEFIファームウェアの設定」と行く。UEFIは、BIOSの進化版みたいな
ものらしい。

UEFIに入ったら、「Security>Secure Boot>Change configuration」をクリックして、「Microsoft only」から
「None」に変更する。LUKSで暗号化すればどうせSSDの中身はパスワードなくして読めないので、
セキュアブートはなくても問題ない気がしている(本当か？)。
後でLUKSのパスワードを求められたときには堅牢なパスワードにしておきましょう。

最後に、Boot configurationタブで、USB Storageを一番上にもっていく。これで、Windowsではなく
USBにあるUbuntuが先に立ち上がるようになる。

** Ubuntuを起動する
まず、SurfaceにUbuntuの入ったUSBとキーボードを、USBハブ経由で繋ぐ。
そして、「exit>Restart now」すると、Ubuntuが立ち上がる。

** Ubuntuをインストール
基本は下記のURLに従ってもらえればいいが、暗号化するのに注意がある。
「インストールの種類」のタイミングで、「ディスクを削除してUbuntuをインストール」すると思うが、
ここで「高度な機能」をクリックし、「新しいUbuntu」の「インストールにLVMを使用する」を選択し、
「安全のために新しいUbuntuのインストールを暗号化する」にチェックを入れて欲しい。
これで、bitlockerと同様にディスクが暗号化される。

URLは[[https://linuxfan.info/ubuntu-20-04-install-guide][これ]]。「ストレージ設定」の見出しのところに
その画面がある。この記事では暗号化をしていないので、一切触れられていない。
この後パスワードを入力させられる(パスワードなしでもいけるが、セキュアブートなしだと危うそう)。
そのとき、バックアップキーが表示されるので、パスワードを忘れたときのためにどこかにメモっておく。

** Surface用のカーネルを導入
次に、Surfaceの各種デバイスが使えるよう、専用のカーネルをインストールする。
基本は[[https://github.com/linux-surface/linux-surface/wiki/Installation-and-Setup#debian--ubuntu][ここ]]に買いてある通りでよい。ただし、
#+BEGIN_SRC shell -n
  sudo apt install linux-surface-secureboot-mok
  sudo update-grub
#+END_SRC
に関しては、セキュアブートしないのならば必要ない。
私はこれを実行した上で、UEFIにおいてセキュアブートを「Microsoft and 3rd party CA」としても
セキュアブートできなかったので断念した。余力があればチャレンジしてほしい。

** キーボードをLUKSパスワード入力時にも使えるようにする
このまま再起動すると、起動時にLUKSのパスワードを聞かれる。
しかし、その時点で読み込まれるファイルシステムはSurfaceのキーボードのドライバを含んでいないらしく、
外部キーボードでしか入力できない。これでは使いものにならないので、最初に読まれるモジュールを追加する。

エディタは問わないが、 =/etc/initramfs-tools/modules= を開いて、以下を末尾に追加する。
root権限が必要なので注意。ちなみに、このリストは[[https://github.com/linux-surface/linux-surface/wiki/Disk-Encryption][ここ]]からとってきた。
#+BEGIN_SRC shell -n
  surface_aggregator
  surface_aggregator_registry
  surface_hid_core
  surface_hid
  intel_lpss
  intel_lpss_pci
  8250_dw
#+END_SRC
その後、以下を実行する。こちらも ~sudo~ が必要。
#+BEGIN_SRC shell -n
update-initramfs -u
#+END_SRC

** おわり
あとは再起動すれば、SurfaceのロゴとともにLUKSのパスワードを聞かれるので、Surface備え付けのキーボードで
パスワードを打てることがわかる。

** 参考
:PROPERTIES:
:CUSTOM_ID: surface-linux-reference
:END:
- https://zenn.dev/sprout2000/articles/52caaffa9ad3fa
- https://github.com/linux-surface/linux-surface
* DONE 電子書籍リーダで読みやすくするために、サイズを変えずにPDFの余白をバッサリとる
CLOSED: [2022-02-01 Tue 17:43]
:PROPERTIES:
  :EXPORT_FILE_NAME: 2022-d37970ce-9dcd-6534-422b-1df7983164bc
:EXPORT_HUGO_TAGS: PDF e-book
:END:
** 結論
下記URLにある =pdfcrop.sh= をつかう。 =pdfcrop.sh -m 0 input.pdf output.pdf= 。
https://tex.stackexchange.com/questions/42236/pdfcrop-generates-larger-file

** はじめに
電子書籍リーダで読む場合、LaTeXで吐いたPDFとかだと、あきらかに余白が大きい。
製本するならそれでもよいが、電子書籍リーダで読むなら余白は邪魔なだけだ。
これをばっさりなくしたい。

** pdfcrop
余白をバッサリとってくれるツールとして、 =pdfcrop= というものがある。
TeX系のユーティリティとしてついてくる。しかしこのツールには問題があり、
ページ数の多いものなど、一部のPDFを異常に大きなサイズとしてしまう。
Send-to-kindleだと50MBまでしか送れないし、そもそも電子書籍リーダはたいして容量がないので、
あまりよろしくない。ちなみに私が使ったときはサイズが20倍とかに膨れ上がった。

** 解決
解決法をさがしていたところ、以下のStackExchangeに出会った。

https://tex.stackexchange.com/questions/42236/pdfcrop-generates-larger-file

ここに載っている =pdfcrop.sh= を保存して使うと、みごとに余白を削れた。もちろんサイズは変わっていない。
丁寧に作られていて、helpもあるので詳しくはそれを参照してほしいが、基本的な使いかたは、 ~-m~ で
空白(margin)のサイズを指定し、引数として入力PDFと出力PDFを与える。
余白をまったくなくしたければ、 =pdfcrop.sh -m 0 input.pdf output.pdf= とすればよい。

** おわりに
ま、まだ電子書籍リーダもってないんですけどね。Fire HD 8しかない。おすすめおしえてほしい。
* DONE GNU Guix Systemをインストールし、日本語を表示・入力できるようにするまで
CLOSED: [2022-05-07 Sat 05:20]
:PROPERTIES:
:EXPORT_FILE_NAME: 2022-ea617625-23b7-03b4-5273-69d79d393b85
:EXPORT_HUGO_TAGS: GNU-Guix-System GNU-Guix IME
:END:
** はじめに
GNU Guix System(以下Guix System)とは、GNUの開発するLinuxディストロのひとつで、GNU Guix(以下Guix)という
パッケージマネージャと密結合している。GuixはSchemeで管理できるパッケージマネージャで、
隔離された環境によるビルドやロールバック可能な操作が特徴で、再現性と環境の隔離に重点を置いている。
これをWindowsの入ったx64のPCにインストールする。面倒なので新しいディスクを用意してそちらにインストールした。
Windowsのディスクはそのまま残したので、起動時にF12を連打してブートディスクを選択すればWindowsも起動できる。

** 必要なもの
- インストール先のPC :: 私はWindows 10、Bitlockerで暗号化されたディスクの組み合わせのPCにインストールした。
  注意として、(たぶん)このPCはインターネットに繋がっていなければならない。
- USBメモリかDVDドライブ :: インストールディスクを一時的に作る必要がある。容量は8GBあれば余裕だと思う(たぶん2GBもない)。
- 内蔵SSDかHDD :: 必須ではないが、Windowsと共存させたい場合、ディスクを分けるのが最も楽。元のWindowsを潰してよいなら
  そこに上書きすればよいと思うが、保証はできない。あんまりやらないけど、外付けでも同様にできるとは思う。

** ディスクの準備
私はWindowsユーザーなので、Rufusを使ってUSBにインストールディスクを作成した。LinuxのPCがある場合は
[[https://guix.gnu.org/manual/en/html_node/USB-Stick-and-DVD-Installation.html][公式のドキュメント]]のとおりにやるとよいと思います。

まず、[[https://guix.gnu.org/ja/download/][公式サイト]]からGNU Guix SystemのISOファイルをダウンロードして、適当なUSBメモリやDVDに焼く。

Rufusでディスクイメージを作る際に注意点がある。
ISOモードではなくDDモードで焼いてほしい。そうしないとちゃんとbootできない。
これはRufusのはじめの画面では選択できず、「スタート」を押した後に聞いてくるので、
そのときに「ISOモード(推奨)」ではなく「DDモード」を選択して欲しい。

** ブートディスクの変更
PCのメーカーや購入時期によって違うと思うので詳しい説明は省く。
先程作ったインストールディスクからブートされるよう、BIOSやUEFIの設定を変えておけばよい。
また、インストールディスクを抜いたらGuix Systemをそのまま立ち上がるよう、
2番目のブートディスクをこれからインストールするディスクにしておく。

** GUI(風)インストーラでインストール
あんまり需要はないかもしれないが、言葉だけだとわかりにくいかもしれないので、画像を付けておく。

さて、インストールディスクからのブートが成功すると、以下のような画面が得られる。
Locale languageなので「日本語」を選択。ちなみに日本語を選んでもインストーラは英語のまま。
#+caption: Locale language
#+attr_latex: scale=0.75
#+label: fig:locale-language
[[images:locale-language.png]]

次に、Locale locationで「日本」を選択。
#+caption: Locale location
#+attr_latex: scale=0.75
#+label: fig:locale-location
[[images:locale-location.png]]

ここでインストーラの選択画面が表れる。GUI風のインストーラを使いたいので
「Graphical install using a terminal based interface」を選択。
#+caption: GNU Guix install
#+attr_latex: scale=0.75
#+label: fig:gnu-guix-install
[[images:gnu-guix-install.png]]

タイムゾーンを「Asia」「Tokyo」と選択。
#+caption: Timezoneの大まかな地域選択
#+attr_latex: scale=0.75
#+label: fig:timezone-1
[[images:timezone-1.png]]
#+caption: Timezoneの選択
#+attr_latex: scale=0.75
#+label: fig:timezone-2
[[images:timezone-2.png]]

次にキーボードレイアウトを選択。日本語配列なら「日本語」を選択。
#+caption: (キーボードの)Layout
#+attr_latex: scale=0.75
#+label: fig:layout
[[images:layout.png]]

キーボードレイアウトにもバリエーションがあるので、それを選択。
こだわりがなければ「日本語」にしておけばよい。
#+caption: (キーボードレイアウトの)Variant
#+attr_latex: scale=0.75
#+label: fig:variant
[[images:variant.png]]

PCの名前を入力する。
#+caption: Hostname
#+attr_latex: scale=0.75
#+label: fig:hostname
[[images:hostname.png]]

代替サーバの検索を有効にするか選択。
このオプションをオンにすると、LAN内のサーバからビルド済みバイナリを探して、インストールでそれも利用するようにする。
これをオンにすればダウンロードの速度の向上が期待される。(おそらくハッシュ値を利用して)純正であると確認された
ものだけを使うので、セキュリティリスクはないが、盗聴している人がいる場合はなにをインストールしているか見ることが
できる。
#+caption: Substitute server discovory.
#+attr_latex: scale=0.75
#+label: fig:substitute-server-discovery
[[images:substitute-server-discovery.png]]

rootのパスワードを入力。ある程度強いものにしておきましょう。
#+caption: System administrator password
#+attr_latex: scale=0.75
#+label: fig:system-administrator-password
[[images:system-administrator-password.png]]
#+caption: (System administrator passwordの) Password confirmation required
#+attr_latex: scale=0.75
#+label: fig:password-confirmation-required
[[images:password-confirmation-required.png]]

ユーザの作成。 =TAB= キーで「Add」を選択し、 =Enter= してユーザ情報を入力。「Name」がユーザ名になる。
#+caption: User creation
#+attr_latex: scale=0.75
#+label: fig:user-creation-1
[[images:user-creation-1.png]]

#+caption: User creation(新規追加画面)
#+attr_latex: scale=0.75
#+label: fig:user-creation-2
[[images:user-creation-2.png]]

#+caption: User creation(パスワードの確認)
#+attr_latex: scale=0.75
#+label: fig:user-creation-password-confirm-required
[[images:user-creation-password-confirm-required.png]]

#+caption: User creation(ユーザ追加後)
#+attr_latex: scale=0.75
#+label: fig:user-creation-3
[[images:user-creation-3.png]]

デスクトップ環境を選択。=SPC= でチェックをつけられる。
複数選択可なので、今後使ってみたいものは気軽に入れてしまってもいいかも。
複数選んでもデフォルトは勝手にGNOMEになったので、違うものを入れてしまって戸惑うみたいなことには
ならなそう。私はとりあえずデフォルトの「GNOME」と今後使ってみたい「Emacs EXWM」を追加した。
#+caption: Desktop environment
#+attr_latex: scale=0.75
#+label: fig:desktop-environment
[[images:desktop-environment.png]]

ネットワークサービスを選択。基本はデフォルトのままでよさそう。
SSHで外から入りたい場合はOpenSSHのデーモンを有効にしないといけないかもしれない(よくしらない)。
#+caption: Network service
#+attr_latex: scale=0.75
#+label: fig:network-service
[[images:network-service.png]]

パーティションをどのように切るかの流れを選択。パーティションとは、ざっくり言えばディスクの切り分けのこと(なはず)。
よく知らない場合は、「Guided - using the entire disk」か「Guided using the entire disk with encryption」
を選んでおくとよい。後者を選ぶとディスクが暗号化される。立ち上げる前にパスワードを要求されるようになるが、
ディスクを盗まれたり廃棄したり警察に押収されたりしたときに中身を勝手に見られることを防ぐことができるので、
なるべくこちらを選ぶことをおすすめする。ここでも後者を選択する。
「Manual」にすれば、一つのディスクで複数のOSを取り回せると思うが、試していない。上級者向け。
#+caption: Partitioning method
#+attr_latex: scale=0.75
#+label: fig:partitioning-method
[[images:partitioning-method.png]]

使うディスクを選択。ここで間違ったディスクを選択するとそのディスクの中身は二度と戻りません。慎重に選びましょう。
#+caption: Disk
#+attr_latex: scale=0.75
#+label: fig:disk-2
[[images:disk-2.png]]

パーティションの切り方を選択。といってもhomeディレクトリを別のパーティションとして切るか否かを聞いている。
homeディレクトリを分けることによって、今回のようにOSをインストールする際にhome以下のデータをそのままとっておける。
私はそこまで魅力を感じなかった(それよりもパーティションが分かれることによる管理コストのほうが面倒そう)ので、
「Everything is one partition」を選択。
#+caption: Partition scheme
#+attr_latex: scale=0.75
#+label: fig:partition-scheme
[[images:partition-scheme.png]]

最後の確認。選択したディスクが消えてもよいディスクかしっかり確認して、「OK」を選択。
#+caption: Guided partitioning
#+attr_latex: scale=0.75
#+label: fig:guided-partitioning
[[images:guided-partitioning.png]]

ディスクの暗号化に使うパスワードを入力。これもそこそこの長さにしておこう。
ディスクに対するパスワードなので、ネットワーク経由の攻撃とは違い、総当たりに対してソフトウェア的なブロックは見込めない。
総当たりされても一生解読されないくらいの長さにしましょう。
#+caption: (ディスク暗号化の)Password required
#+attr_latex: scale=0.75
#+label: fig:encrypt-password-required
[[images:encrypt-password-required.png]]
#+caption: (ディスク暗号化の)Password confirmation required
#+attr_latex: scale=0.75
#+label: fig:encrypt-password-confirmation-required
[[images:encrypt-password-confirmation-required.png]]

本当にフォーマットして(パーティション切って)よいか最後の確認。「Continue」を押すと二度と戻れません。
ここで確認できることは多くないですが、よいと思ったら「Continue」を選択。
#+caption: Format disk?
#+attr_latex: scale=0.75
#+label: fig:format-disk
[[images:format-disk.png]]

すると以下の画面になるので、少し待つ。
#+caption: Preparing partitions
#+attr_latex: scale=0.75
#+label: fig:preparing-partitions
[[images:preparing-partitions.png]]

ここで、はじめてSchemeが出てくる。guixはここに書いてあるとおりにシステムを構築してくれる。
最初にLocaleとして日本語を選択したが、日本語フォントはOSに含まれていないので、
このまま進むと豆腐だらけのOSを使うことになる。
これを防ぐため、システムのconfigureを変更する。 =TAB= で「Edit」を選択。
#+caption: Configuration file
#+attr_latex: scale=0.75
#+label: fig:configuration-file-2
[[images:configuration-file-2.png]]

するとnanoというエディタが立ち上がる。
#+caption: nanoによる =/etc/configure.scm= の編集画面
#+attr_latex: scale=0.75
#+label: fig:nano-before-region
[[images:nano-before-region.png]]

そこに、このような節があるはずだ。
#+BEGIN_SRC scheme -n
  (pacakges
   (append
    (list
     ;; このへんはEmacs EXWMをDesktop environmentとして選んだときだけ
     (specification->package "emacs")
     (specification->package "emacs-exwm")
     (specification->package
      "emacs--desktop-environment")
     (specification->package "nss-certs"))
    %base-packages))
#+END_SRC
ここにはグローバルにインストールされるパッケージが羅列されている。
この =specification->package= の列にの日本語フォントのパッケージを追加すればよい。
つまり、以下のように変更する。
#+BEGIN_SRC scheme -n
  (pacakges
   (append
    (list
     ;; このへんはEmacs EXWMをDesktop environmentとして選んだときだけ
     (specification->package "emacs")
     (specification->package "emacs-exwm")
     (specification->package
      "emacs--desktop-environment")
     (specification->package "nss-certs")
     (specification->package "fontconfig")
     (specification->package "font-google-noto"))
    %base-packages))
#+END_SRC
そうしたら、 =C-x= (つまりコントロールを押しながらx)を押し、そのまま =Enter= を押して保存する。
#+caption: nanoによる =/etc/configure.scm= の編集画面(編集後)
#+attr_latex: scale=0.75
#+label: fig:nano-after-region
[[images:nano-after-region.png]]

次の画面が表示されるのでそのまま従って =Enter= を押下。
#+caption: Press enter to contiunue
#+attr_latex: scale=0.75
#+label: fig:press-enter-to-continue
[[images:press-enter-to-continue.png]]

すると、次のようにインストールが始まる。ここでしばらく待機。
なお、shepherdとは一般的なLinuxにおけるsystemdに相当するもので、サービスマネージャである。
guix-daemonはguixを走らせるために重要なデーモンで、guixはこれを通じて操作することで管理者権限なしで
=/gnu/store/= 以下を触ることができる(らしい)。
#+caption: インストール開始画面
#+attr_latex: scale=0.75
#+label: fig:console-1
[[images:console-1.png]]

インストールが終わると、以下のような画面が現れる。指示に従って、 =Enter= を押す。
#+caption: インストールの終わりの画面
#+attr_latex: scale=0.75
#+label: fig:console-3
[[images:console-3.png]]

これでインストールは終了だ。以下のような画面が出てくるので、指示に従い、インストールディスクを
抜いて再起動する。
#+caption: Installation complete
#+attr_latex: scale=0.75
#+label: fig:installation-complete
[[images:installation-complete.png]]

** 起動
再起動すると、GRUBが立ち上がる。GRUBはBoot loaderで、OSの立ち上げを担う。
私はもともとメインで使っていたディスクをBitlockerで暗号化していたため、
マスターブートキーを入力させられている。おそらくそうでない人はここでなにも聞かれないのではなかろうか。
#+caption: マスターブートキーの入力
#+attr_latex: scale=0.75
#+label: fig:nano-before-region
[[images:nano-before-region.png]]

その後、以下のようなGRUBのグラフィカルな画面が現れる。ほっておけば先に進むし、 =Enter= を押してもよい。
#+caption: GRUBのOS選択画面
#+attr_latex: scale=0.75
#+label: fig:guix-select
[[images:guix-select.png]]

すると、Guix Systemをインストールしたディスクの暗号化のパスワードを聞かれるので、入力。
#+caption: ディスク暗号化のパスワードを入力
#+attr_latex: scale=0.75
#+label: fig:decrypt.png
[[images:decrypt.png]]

これで、Guix Systemが立ち上がる。日本語を表示できることを確認。
#+caption: Guix Systemのログイン画面
#+attr_latex: scale=0.75
#+label: fig:login
[[images:login.png]]

あとはGNOMEのUIなので、普通にログインできるだろう。

** 日本語を表示したい
今、日本語を表示できることを確認した。
このままGuix Systemに一切のカスタマイズを加えるつもりがないのならば、この章は飛ばしても構わない。
しかし、おそらくGuix Systemを使う人は、ほとんど全員カスタマイズしたくなる性分の人だろう。
特にGuixは自由ソフトウェアを思想としており、プロプライエタリなドライバはデフォルトでは利用できない。
後述する手順を踏めば利用可能だが、それはここで言うカスタマイズに相当することに留意して欲しい。
また、ひとつ後の章では =guix= コマンドによるパッケージのインストールも扱うので、
もしエディタにEmacsを使いたいという場合は、この章を次の章の後に行うとよい。

実は今日本語が表示できているのが奇跡な状態である。
詳細はわかっていないが、インストール時特有のプロセスによって日本語が表示できている。
カスタマイズしたくなり、 =guix system reconfigure /etc/config.scm= したあかつきには、
もれなく文字が豆腐になった無惨なGuix System(というかGNOME)を見ることになる。
これを解決するため、 =/var/lib/gdm/.config/fontconfig/fonts.conf= を作成し、以下のように書く。
場所的にルート権限が必要なので注意。
特にこだわりがなければ =sudo nano /var/lib/gdm/.config/fontconfig/fonts.conf=
#+BEGIN_SRC xml -n
  <?xml version='1.0'?>
  <!DOCTYPE fontconfig SYSTEM 'fonts.dtd'>
  <fontconfig>
    <dir>/run/current-system/profile/share/fonts/</dir>
  </fontconfig>
#+END_SRC

gdmとはGNOME Display Managerのことであり、内部的なユーザとして扱われている。
しかしこいつはグローバルにインストールされたフォントの場所を知らないため、これを教えてあげようというわけだ。
その後、フォントのキャッシュを更新するために以下のコマンドを実行する。
#+BEGIN_SRC bash -n
  fc-cache -fv
#+END_SRC

これで =guix system reconfigure /etc/config.scm= しても日本語が表示できるようになった。
ちなみに、 =/etc/config.scm= ファイル(厳密には、別に場所はここである必要はないし、名前も自由)に作ってもらうことも
可能らしい。[[https://git.sr.ht/~taiju/taix/tree/e396904863e26f04c87c2a4ebd76b1b34fbd7ae7/item/guix-config/system-config.scm#L59][Taijuさんの設定ファイル]]にあるように、 =services= に以下を追加すればよい。
#+BEGIN_SRC scheme -n
  (extra-special-file "/var/lib/gdm/.config/fontconfig/fonts.conf"
                      (plain-file "gdm-fonts.conf"
                                  "<?xml version='1.0'?>
  <!DOCTYPE fontconfig SYSTEM 'fonts.dtd'>
  <fontconfig>
    <dir>/run/current-system/profile/share/fonts/</dir>
  </fontconfig>
  "))
#+END_SRC

** パッケージのインストールのしかた
まずはじめに、
#+BEGIN_SRC bash -n
  guix pull
#+END_SRC
を走らせる必要がある。このコマンドはチャンネルから情報を取ってきて、各パッケージをアップデートしてくれる。
チャンネルとは、ざっくり言えばパッケージの定義の集合である。
厳密に言えば、Guile(Schemeの処理系のひとつ)のモジュールと呼ばれる単位で公開されているので、もっと柔軟でなんでもできる。
=guix pull= 自体がアップデートなしても実行に体感何分かかかること、guix自身がそこそこ頻繁にアップデートされること、
アップデートが入ると体感10分くらいかかることに留意してほしい。要は、 =guix pull= はそこそこ遅い。

インストール基本的には以下のようなものを実行すればよい。これでEmacsをインストールできる。
#+BEGIN_SRC bash -n
  guix install emacs
  #+END_SRC
また、アンインストールは以下のコマンド。
#+BEGIN_SRC bash -n
  guix remove emacs
#+END_SRC
ちなみに =guix insall= は =guix package -i= のエイリアスで、
パッケージに関する操作はすべて =guix package= に集約されている。たとえば、
#+BEGIN_SRC bash -n
  guix package --roll-back
  #+END_SRC
とすれば、前の世代に戻れる。
私もあまり詳しくないが、ざっくり言えば、インストールやアンインストールをするたびに世代が進む(たぶん)。

インストールされたパッケージをリストするには
#+BEGIN_SRC bash -n
  guix package -I
#+END_SRC
で、インストールできるパッケージをリストするには
#+BEGIN_SRC bash -n
  guix package -A
#+END_SRC
また、正規表現にマッチするパッケージを検索するには
#+BEGIN_SRC bash -n
  guix search regexp
#+END_SRC
とする。

** 日本語IMEを入れる
私はSKK使いだが、残念ながら未だGuixのIMEにSKKを使う方法を知らない。
とりあえず最低限日本語を入力するため、 ibusとibus-anthyをインストールする。
#+BEGIN_SRC bash -n
  guix install ibus ibus-anthy
#+END_SRC
そして、[[https://issues.guix.gnu.org/35610#7-lineno19][issue]]にあるように、 =~/.bash_profile= に以下を追記する。なければ新規作成。
#+BEGIN_SRC bash -n
  export GUIX_GTK2_IM_MODULE_FILE="$HOME/.guix-profile/lib/gtk-2.0/2.10.0/immodules-gtk2.cache"
  export GUIX_GTK3_IM_MODULE_FILE="$HOME/.guix-profile/lib/gtk-3.0/3.0.0/immodules-gtk3.cache"
  export IBUS_COMPONENT_PATH="$HOME/.guix-profile/share/ibus/component"
  export GTK_IM_MODULE=ibus
  export XMODIFIERS=@im=ibus
  export QT_IM_MODULE=ibus
#+END_SRC
もし =~/.cache/ibus= が存在するなら、全て削除し、再起動する。

再起動したあと、画面右上のボタンから設定に移行し、左のメニューからキーボードを選択する。
すると、以下のようになるはずだ。
#+caption: IME変更前の状態
#+attr_latex: scale=0.75
#+label: fig:ime-before
[[images:ime-before.png]]

画面に写ったプラスボタンをクリックし、「日本語」を選択すると、
「日本語(Anthy)」が出ているので、それを選択する。
#+caption: 言語の選択
#+attr_latex: scale=0.75
#+label: fig:ime-select-1
[[images:ime-select-1.png]]
#+caption: IMEの選択
#+attr_latex: scale=0.75
#+label: fig:ime-select-2
[[images:ime-select-2.png]]

すると、以下のようになる。
#+caption: IME変更後の状態
#+attr_latex: scale=0.75
#+label: fig:ime-after
[[images:ime-after.png]]

「Japanese」や「English(US)」は不要なので、右のスリードットを押して得られるメニューで削除を選択。
#+caption: 不要なIMEの削除
#+attr_latex: scale=0.75
#+label: fig:ime-delete
[[images:ime-delete.png]]

これで無事日本語が入力できるはずだ。

** 不自由なソフトウェア
不自由なソフトウェア(プロプライエタリなドライバやファームウェア含む)を使いたい場合、
デフォルトのguixチャンネルは利用できない。
そのために、非公式のチャンネルとして[[https://gitlab.com/nonguix/nonguix][nonguix]]というものが存在する。
この章ではこのチャンネルを導入する。不自由なソフトウェアを利用したくない場合は、この章は飛ばしてよい。

READMEにあるように、 =~/.config/guix/channels.scm= に以下を書く。
このファイルはユーザが利用するguixのチャンネルを定義する。自分でGitレポジトリを作ってチャンネルとすることも可能だ。
#+BEGIN_SRC scheme -n
  (cons* (channel
          (name 'nonguix)
          (url "https://gitlab.com/nonguix/nonguix")
          ;; Enable signature verification:
          (introduction
           (make-channel-introduction
            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
            (openpgp-fingerprint
             "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
         %default-channels)
#+END_SRC
これを書いたら、 =guix pull= しておこう。

次に、Linuxカーネル及び不自由なファームウェア、ドライバを導入する。
これもREADMEにあるように、 =/etc/config.scm= を以下のように変更する。
編集には管理者権限が必要であることに注意。
#+BEGIN_SRC scheme -n
  ;; (use-modules (gnu)) の行を以下に変更
  (use-modules (gnu)
               (nongnu packages linux)
               (nongnu system linux-initrd))

  (operating-system
   ;; 以下の行を追記
   (kernel linux)
    (initrd microcode-initrd)
    (firmware (list linux-firmware))
    ...
    )
#+END_SRC

最後に、以下のコマンドを実行。こちらにも管理者権限が必要なので =sudo= がついている。
=guix system reconfigure= は、Guix Systemそのものの設定を読み直し、適宜ビルドするコマンドである。
そこそこに時間がかかるため、気長に待とう。
#+BEGIN_SRC bash -n
  sudo guix system reconfigure /etc/config.scm
#+END_SRC

** おわりに
Guix SystemやGuixの日本語情報はあまりなく、大変かもしれないが、是非使ってみて欲しい。
日本語の記事を書いてくれるとさらに嬉しい。

** 謝辞など
Guix Systemを導入し、さらにこの記事を書くにあたり、 [[https://libre.taiju.info/][Taiju]]さんにとてもお世話になりました。
この場を借りて感謝の意を表したいと思います。本当にありがとうございました。

また、Taijuさんと共に[[https://join.slack.com/t/guix-jp/shared_invite/zt-17aoza5yo-KAVDj5aPPwsJ9X7e4lJteg][Guix-jp]]というGNU Guix及びGNU Guix Systemの日本語コミュニティを立ち上げました。
すこしでもGuixに興味を持った方は、是非遊びにきてください!!
* TODO Emacsのパッケージをつくってみよう
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-df7edb45-d0ce-7cd4-5c6b-1a3efa8b4b4c
  :EXPORT_HUGO_TAGS: Emacs Emacs-Lisp
  :END:
[[https://qiita.com/advent-calendar/2022/emacs][https://img.shields.io/badge/Emacs%20Advent%20Calendar%202022-12%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]
* TODO 自分専用のELPA(Emacs Lisp Package Archive)をGitHubでホストしよう
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-11f6e993-0310-7aa4-0563-ea30d0f25c5d
  :EXPORT_HUGO_TAGS: Emacs package.el GitHub
  :END:
[[https://qiita.com/advent-calendar/2022/emacs][https://img.shields.io/badge/Emacs%20Advent%20Calendar%202022-13%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]
* TODO MELPAにパッケージを提出してみんなに使ってもらおう
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-c6b38d7a-1974-ad04-8ebb-ee117a8a1d2d
  :EXPORT_HUGO_TAGS: EMacs MELPA
  :END:
[[https://qiita.com/advent-calendar/2022/emacs][https://img.shields.io/badge/Emacs%20Advent%20Calendar%202022-14%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]
* DONE Guixのパッケージをつくってみよう-その1: 簡単なフォントのパッケージを作る
CLOSED: [2022-12-05 Mon 04:43]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-770eb4b6-5c63-62d4-bbcb-475d92404603
  :EXPORT_HUGO_TAGS: GNU-Guix Scheme
  :END:
[[https://qiita.com/advent-calendar/2022/guix][https://img.shields.io/badge/GNU%20Guix%20Advent%20Calendar%202022-5%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]
** 序文
GNU Guixでは、簡単にパッケージを作り、自分でそれを利用することができます。
GNU Guixでは、パッケージ定義群は「チャンネル」という名前がついています。
各々が自分だけのチャンネルを作り、それを公開するなりローカルに保持するなりし、Guixにそれを教えてあげることで、
そのチャンネルを経由してパッケージを利用することができるようになります。

この記事では、おそらく最も簡単であるフォントのパッケージを実際に作り、チャンネルを経由して配信するところまでを扱います。

** 前提
GNU Guix自体はインストールされていて、使えるようになっていることを前提とします。

** チャンネルを用意する
チャンネルは、(試したことないですが)ローカルに用意することもできますし、GitHubやGitLabのレポジトリホスティングサービスを使うこともできます。
チャンネルにしたいレポジトリかディレクトリ直下に、以下のような内容のファイル =.guix-channel= をおいてください。
=<your-channel-URL>= は、ローカルの場合は =file:///path/to/channel/= 、
GitHubやGitLabレポジトリの場合は =https://gitlab.com/username/channel= の形式のURLに置き換えてください。
また、レポジトリを利用する場合はコミットしてプッシュするのを忘れないでくださいね。
#+BEGIN_SRC scheme
  (channel
   (version 0)
   (url "<your-channel-URL>"))
#+END_SRC
これはチャンネルの宣言です。依存関係がある場合や、チャンネルをサブディレクトリに置きたい場合には、
ここで一緒に宣言します。詳しくは[[https://guix.gnu.org/en/manual/devel/en/guix.html#Creating-a-Channel][公式のドキュメント(英語)]]をご覧ください。

次に、チャンネルの位置をGuixに教えてあげます。
=~/.config/guix/channels.scm= に以下を書いてください。
=<your-channel-URL>= は先程と同様に置き換えてください。また、 =your-channel-name= は任意の名前です。
好きな名前を付けて愛着を湧かせましょう。
#+BEGIN_SRC scheme
  (cons* (channel
          (name 'your-channel-name)
          (url "<your-channel-URL>")
          ;; もしレポジトリのデフォルトブランチが `main' の場合は以下を追記
          ;; (branch "main")
          )
         %default-channels)
#+END_SRC

これで登録は完了です。以下のコマンドを実行し、今登録したチャンネルからパッケージ定義を取り寄せていることを確認しましょう。
#+BEGIN_SRC shell
  guix pull
#+END_SRC
もし成功していれば、以下のような表示が得られます。
#+begin_example
  Updating channel 'your-channel-name' from Git repository at '<your-channel-URL>'...
  Updating channel 'guix' from Git repository at 'https://git.savannah.gnu.org/git/guix.git'...
  Building from these channels:
    guix      https://git.savannah.gnu.org/git/guix.git	a4d52f0
    your-channel-name    https://github.com/ROCKTAKEY/roquix	0000000
  (後略)
#+end_example

これで準備は完了です。

** パッケージを定義する
さて、パッケージを定義していきましょう。
まず、先程のディレクトリの下に =your-channel-name= 、及び =your-channel-name/packages= ディレクトリを作成してください。
これは単なる慣習です。基本的には =your-channel-name/packages/= 以下にパッケージ定義を置いていきます。

今回は、[[https://github.com/miiton/Cica][Cica]]というフォントのパッケージを作成していきます。
先にコードを貼っておきます。 =your-channel-name/packages/fonts.scm= に以下を書いてください。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages fonts)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download)
    #:use-module (guix build-system font))

  (define-public font-cica
    (package
      (name "font-cica")
      (version "5.0.3")
      (source (origin
                (method url-fetch)
                (uri (string-append
                      "https://github.com/miiton/Cica/releases/download/"
                      "v"
                      version
                      "/Cica_v"
                      version
                      ".zip"))
                (sha256
                 (base32
                  "0vshn2cd70mnbavsw9cbagcasa95wiv9qdj4wkzxn7gxygqvrlfb"))))
      (build-system font-build-system)
      (home-page "https://github.com/miiton/Cica")
      (synopsis "Japanese monospaced font for programming")
      (description
       "Cica is a Japanese monospaced font for programming.
  Hack + DejaVu Sans Mono is used for ASCII, and Rounded Mgen+ for the other.
  In addition, Nerd Fonts, Noto Emoji, Icons for Devs, and some adjustment forked from
  the Ricty generator are converted and adjusted.")
      (license license:silofl1.1)))
#+END_SRC

このコードはSchemeという言語で書かれています。
Lispに慣れていないと括弧に圧倒されるかもしれませんが、基本的には =(関数名 引数1 引数2...)= が関数呼び出しとなっています(このような塊をS式と呼びます)。
ただし、評価されないS式も多々出てきます(S式を関数呼び出しとして解釈して実行することを評価と呼びます)。
それは上位の関数的なもの(マクロと呼び、関数と全く同様な呼び出し記法で呼び出す)が各引数を評価するかどうか自由に決めることができるからですが、
理解できなくても構いません。ひとつずつ解説していくので安心してください。

まずは、冒頭にある =define-module= の式をご覧ください。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages fonts)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download)
    #:use-module (guix build-system font))
#+END_SRC
これは名前の通り、「モジュールを定義する」部分になります。実はパッケージは、Schemeのモジュールという機構によって定義されます。
ここではそれを定義することでこのファイルをモジュールとし、Guixがモジュールとしてファイルを読み込むことができるようにします。

第一引数である =(your-channel-name packages fonts)= は、ちょうどディレクトリの構造及びファイル名を反映していなければなりません。
第二引数と第三引数、及びそれ以降の引数の組は =#:use-module (guix packages)= のような形をしています。
これは、このモジュールがなんのモジュールに依存しているかを表しています。
依存が足りなかったら後でエラーが出て、「○○を =use-module= してなくない？」と教えてくれるので、
厳密にどのパッケージがどこにあるか覚えていなくても問題にならないことが多いです。
ちなみに =#:prefix license:= の行では、「このモジュールでエクスポートされた変数は =license:= という接頭辞を付けてアクセスする」という指定が付いています。

さて、いよいよパッケージ定義です。外側から順番にみていきましょう。
#+BEGIN_SRC scheme
  (define-public font-cica
    ...)
#+END_SRC
=define-public= は、変数を定義する =define= の亜種です。
こちらも変数を定義しますが、それに加えて「モジュールの外からも見えるようにする(つまり公開状態(public)にする)」という機能があります。
先程も言ったように、Guixはモジュールを経由してパッケージ定義を得ます。そのため、パッケージ定義は公開されている必要があります。
第一引数は変数の名前で、第二引数がその値です。

さて、以下のようなものが値として与えられていました。
#+BEGIN_SRC scheme
  (package
   (name "font-cica")
   (version "5.0.3")
   (source ...)
   (build-system font-build-system)
   (home-page ...)
   (synopsis ...)
   (description ...)
   (license ...))
#+END_SRC
=package= というのは、 =package= というオブジェクトを生成する、所謂コンストラクタにあたるものです
(たぶん。違ったらすみません。普段使っているLispの方言と色々違っていてまだ完全にSchemeを習得できていません)。
各引数は =(name "font-cica")= のようになっています。 =(フィールド名 値)= の形で各フィールドの値を与えています。
名前(フィールド名)付きの引数(値)を複数渡せるようになっていると考えるとわかりやすいかもしれません。ちなみに順不同です。

この =(フィールド名 値)= のS式は評価されない(評価されたらフィールド名が関数名と解釈されて評価後の値が =package= の引数となってしまうため、
=package= コンストラクタがフィールド名を知る術がなくなる)ため、 =package= コンストラクタはマクロだろうと推測できます(これも定かではない)。
なお、 =値= の部分は評価されます。

少し話が逸れましたが、ここまで来ればあと少しです。 =package= コンストラクタに渡す引数をひとつひとつ見ていきましょう。
まずは =name= と =version= です。
#+BEGIN_SRC scheme
  (package
    (name "font-cica")
    (version "5.0.3")
   ...)
#+END_SRC
=name= は、文字通りパッケージの名前です。
この値は、コマンドラインからパッケージをインストールする場合に使います(例: =guix install font-cica=)。
バージョン違いなど、パッケージとなる対象が同じ場合、名前は他のパッケージと被っても構いません。
複数の定義がある場合はデフォルトで最も新しいものがインストールされます。
バージョンを指定してインストールすることも可能(例: =guix install gcc-toolchain@10=)なため、
バージョン違いで名前を被せることはむしろ有用です。

=version= はバージョンを表す文字列です。
おそらく形式に決まりはないですが、先頭に"v"を付けずに"5.0.3"のようにする場合が多いです。

一番説明が面倒な =source= と =build-system= を一旦飛ばして、 =home-page= 、 =synopsis= 、 =description= に移ります。
#+BEGIN_SRC scheme
  (package
    ...
    (home-page "https://github.com/miiton/Cica")
    (synopsis "Japanese monospaced font for programming")
    (description
     "Cica is a Japanese monospaced font for programming.
  Hack + DejaVu Sans Mono is used for ASCII, and Rounded Mgen+ for the other.
  In addition, Nerd Fonts, Noto Emoji, Icons for Devs, and some adjustment forked from
  the Ricty generator are converted and adjusted.")
    ...)
#+END_SRC
この3つは割と見たまんまで、 =home-page= にはパッケージの対象のホームページを、 =synopsis= にはパッケージの1行の概要を、
=description= はパッケージの説明を文字列で与えます。なお、 =description= に[[https://www.gnu.org/software/texinfo/manual/texinfo/texinfo.html][texinfo]]の記法を使えます。

次は =license= です。
#+BEGIN_SRC scheme
  (package
    ...
    (license license:silofl1.1))
#+END_SRC
ここにはライセンスを指定します。ライセンスを表す定数は =(guix licenses)= モジュールで定義されています。
利用できるパッケージは[[https://git.savannah.gnu.org/cgit/guix.git/tree/guix/licenses.scm][公式レポジトリ]]で見ることができます。MITライセンスの名前は =expat= なので注意。
モジュール定義の際に =#:prefix license:= を指定したため、 =silofl1.1= の代わりに =license:silofl1.1= となっています。

次は先程飛ばした =source= です。
#+BEGIN_SRC scheme
  (package
    ...
    (source (origin
              (method url-fetch)
              (uri (string-append
                    "https://github.com/miiton/Cica/releases/download/"
                    "v"
                    version
                    "/Cica_v"
                    version
                    ".zip"))
              (sha256
               (base32
                "0vshn2cd70mnbavsw9cbagcasa95wiv9qdj4wkzxn7gxygqvrlfb"))))
    ...)
#+END_SRC
=source= は少し複雑ですが、基本的にはほとんどイディオムで、普段は専らコピペしています。
=source= フィールドには =origin= オブジェクトを渡しています。 =origin= オブジェクトはその場で生成して渡しています。
=origin= オブジェクトのコンストラクタの部分を抜き出してみます。
#+BEGIN_SRC scheme
  (origin
    (method url-fetch)
    (uri (string-append
          "https://github.com/miiton/Cica/releases/download/"
          "v"
          version
          "/Cica_v"
          version
          ".zip"))
    (sha256
     (base32
      "0vshn2cd70mnbavsw9cbagcasa95wiv9qdj4wkzxn7gxygqvrlfb")))
#+END_SRC
フィールドは =method= 、 =uri= 、 =sha256= の3つあることがわかります。

=method= としてここで与えているのは =url-fetch= です。
他には =git-fetch= を使うことが多いと思います。
その場合、 =uri= フィールドではgitレポジトリの情報を与えなければならないため、以下のような形になります。
#+BEGIN_SRC scheme
  (uri (git-reference
        (url "https://example.com/your/git/repo")
        ;; コミットハッシュの代わりにタグを使うこともできます。
        ;; (commit (string-append "v" version))
        (commit "0000000")))
#+END_SRC

=uri= として与えているのは文字列です。 =string-append= は単に文字列を結合する関数で、引数に文字列を与えてそれを呼び出しています。
マクロの力(たぶん、もしかしたらScheme自体の特徴かも)により、
=version= という名前で先程 =(version "5.0.3")= として渡した =version= フィールドの値 ="5.0.3"= にアクセスできるため、
呼び出した結果は以下のようになるはずです。
#+BEGIN_SRC scheme
  ;; S式
  (string-append
            "https://github.com/miiton/Cica/releases/download/"
            "v"
            version
            "/Cica_v"
            version
            ".zip")

  ;; 評価後の値
  "https://github.com/miiton/Cica/releases/download/v5.0.3/Cica_v5.0.3.zip"
#+END_SRC

=sha256= には、 謎の文字列を =base32= に渡したものが与えられています。
これはいわゆる「ハッシュ値」というもので、与えられたディレクトリの内容から一意に定まります。
URIから得られたファイルがパッケージを定義した人と一致していない場合、偽物を掴まされたことになりますが、
ハッシュ値を比較することで偽物であることを感知できます。
これにより、偽物を掴まされたことに気付かずにそのパッケージを使用してウイルスやマルウェアに侵されることを防ぎます。
この方法ではパッケージを定義した人がマルウェアを配信している場合に感知することはできないので、信頼できるチャンネルだけを登録しましょう。

このハッシュ値は、 =guix download <URL>= と入れることで得ることができます。
対象がgitレポジトリの場合、そのレポジトリをクローンして =guix hash -rx /path/to/repo= とすることで得ることができます。
後者の場合、異なるコミットやタグにチェックアウトしている場合は異なるハッシュ値が返るので注意してください。
また、裏技として、適当なハッシュ値を入れてパッケージをビルドすると「ハッシュ値が間違ってるよ」と言いながら実際のハッシュ値を教えてくれます。

最後は =build-system= です。
#+BEGIN_SRC scheme
  (package
    ...
    (build-system font-build-system)
    ...)
#+END_SRC
=build-system= では、「パッケージをどのようにビルド・インストールするか」を与えます。
フォント専用の =font-build-system= の場合は既にあるファイルを所定のディレクトリに配置する作業が主です。
フォント以外、例えばソースコードからビルドするような場合には、ビルド方法を指定する必要があります。
ビルド方法によって色々定義されています。詳細は[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Systems][公式マニュアル]]にあります。
明日の記事で詳しく触れる予定です。

** パッケージをビルドしてみる
さて、これでパッケージの定義が終わりました。実際に使ってみましょう。
まずはパッケージをあなたのチャンネルに配信しましょう、と言いたいところですが、
実際に動くかわからないコードをいきなりプッシュするのは怖いですよね。
=guix= コマンドは =-L= オプションでチャンネルとなる(つまりロード対象となる)ディレクトリを渡すことで、
一時的にそのチャンネルを登録したかのように振舞います。
今定義したパッケージ =font-cica= をビルドすべく、以下を実行してみましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel/ font-cica
#+END_SRC
正常にビルドが成功すれば、大量のログの末尾に =/gnu/store/p6v2bm5s9diamkanr9z6c7r63ikzibb5-font-cica-5.0.3= のような表示が出ていると思います
(ただしハッシュ値は違う可能性があります)。

次に、それをインストールした環境に入ってみます。
#+BEGIN_SRC scheme
  guix shell -L /path/to/your/channel/ font-cica
#+END_SRC
=guix shell= は、指定したパッケージが *追加で*インストールされた環境に一時的に入ります
(元々入っていたパッケージは引き継がれた上で、新しい環境に入ります
もしまっさらな環境に指定パッケージだけが入った環境へ一時的に移りたい場合は、 =--pure= オプションを付ければよいです)。
shellのプロンプトに =[env]= が追加されていたら正常に移行できています。

とはいっても、フォントをインストールした場合はなにかを実行できるわけではなく、
このような環境に入ったところでよくわからないので、一旦 =exit= してください。
実行ファイルがビルドされるようなパッケージであれば、ここで実際に動くか試すことが可能です。

フォントが入っているか確かめるために、以下のコマンドを実行してまた新しい環境に移動してみましょう。
#+BEGIN_SRC shell
  guix shell --container -L /path/to/your/channel/ font-cica fontconfig grep
#+END_SRC
これは先程定義した =font-cica= に加えて、 =fontconfig= 、 =grep= をインストールした環境へ一時的に移行するコマンドです。
今回は =--container= オプションを付けています。これにより、指定したパッケージだけをインストールした(つまり今の環境にあるパッケージは含まない)、
ファイルシステムを含めて完全に独立した環境へ一時的に移行するオプションです。
=--pure= オプションの場合も指定したパッケージだけをインストールした環境へと一時的に移行するという点では同じですが、
ファイルシステムが独立していないという点が異なります。
これは本筋と全く関係のない話なので無視して構いませんが、ここで =--pure= ではなく =--container= を利用している理由は、
=fontconfig= がキャッシュをユーザーディレクトリに残すからか、
ファイルシステムが共有の =--pure= では元の環境にインストールされているフォントが漏れ出してしまうからです。

さて、新しい環境で以下を実行してみましょう。
#+BEGIN_SRC shell
  fc-list | grep Cica
#+END_SRC
これは =fc-list= で得られたフォントの一覧を、 =grep= コマンドで "Cica" を含むものだけに絞りこんでいます。
ここでなんらかの出力が得られれば、成功です。無事フォントをインストールできていることが確認できます。
終わったら =exit= を打って環境を戻しておきましょう。

念のため、なにもない環境でなんの出力も出ないかどうかを確認してみましょう。
#+BEGIN_SRC shell
  guix shell --container font-cica fontconfig grep
  fc-list | grep Cica
#+END_SRC
ここでなにも出ないことが確認できれば、 =font-cica= パッケージを入れたことによってフォントがインストールできたことの証明になります。

ちなみに余談ですが、 =guix shell= である環境に一時的に移行してあるコマンドを実行してすぐ戻ってくる、という操作は簡略化できます。
具体的には、以下のように末尾に =-- 実行したいコマンド= とすればよいです。
#+BEGIN_SRC shell
  guix shell --container font-cica fontconfig grep -- fc-list | grep Cica
#+END_SRC
ただし、上記の場合パイプ =|= の後ろの =grep= は一時環境から戻ってきた後に実行されているため、
現環境に =grep= がインストールされている必要があることに注意してください。つまり以下のように解釈されています。
#+BEGIN_SRC shell
  (guix shell --container font-cica fontconfig grep -- fc-list) | grep Cica
#+END_SRC
私もこれに対する解法は持ち合わせていません。
パイプや =&&= を =guix shell= に渡す方法があれば教えていただけると幸いです。

** パッケージをチャンネルに配信する
これでパッケージの動作確認が終わりました。最後に =lint= と =style= をかけておきましょう。
#+BEGIN_SRC shell -n
  guix style -L /path/to/your/channel/ font-cica
  guix lint -L /path/to/your/channel/ font-cica
#+END_SRC
lintについては必要以上に厳しい場合があるので、脆弱性など重要そうなものでなければ無視しても構いません。
特に上流のレポジトリに対して「tagが打たれてない」とか「GitHubでReleaseが作られてない」とか言われますが、大抵の場合どうしようもないです。
一行の長さなどは従っておきましょう。

Gitレポジトリのホスティングサービスを使っている人は、変更をコミットしてプッシュしてください。
ローカルの人はそのままでよいです。

そうしたら、また以下のコマンドを打ってください。
#+BEGIN_SRC shell
  guix pull
#+END_SRC
これによって、新しいパッケージ定義がGNU Guixに読み込まれました。
パッケージ定義が読み込まれているか確認するために、以下のコマンドを打ってみましょう。
#+BEGIN_SRC shell
  guix show font-cica
#+END_SRC
これで今登録したパッケージの詳細が表示されれば成功です。もしそのままインストールしたければ
#+BEGIN_SRC shell
  guix install font-cica
#+END_SRC
とすればよいですし、取り除きたければ
#+BEGIN_SRC shell
  guix remove font-cica
#+END_SRC
とできます。また、一つ前の状態に戻したい(たとえば入れたパッケージがやっぱりいらなかったので入れなかったことにする、など)場合は、
#+BEGIN_SRC shell
  guix package --roll-back
#+END_SRC
とすればよいです。

** 最後に
この記事では、フォントという比較的簡単な対象に対してパッケージ定義を行いました。
この「簡単」という言葉に驚くかもしれませんが、そもそもパッケージ定義自体に加えてその周辺知識についても一緒に説明しているため、
フォントのパッケージ定義自体は簡単でも、記事としてはかなり密度が高くなっています。
実際に =font-cica= に書いた定義自体も30行程度と短いですし、フォントのパッケージ定義自体よりもその周辺知識に頭を使ったと考えてください。
難しく感じるのも無理はありません。もしなにか質問などあれば、コメントなりメールなりで受け付けます。
また、Guixの日本語コミュニティである[[https://guix-jp.gitlab.io/][Guix-jp]]もあります(ちなみに今回作ったパッケージと同じものが[[https://gitlab.com/guix-jp/channel][Guix-jp公式チャンネル]]にあります)。
そちらには私以上のエキスパートの人がいますので、是非そちらもご興味あれば覗いてみてください。

*** 次回の記事
次回の記事は「[[https://blog.rocktakey.com/information-science/2022-c5b823db-a6b6-23a4-5783-c7741fd0f420/][Guixのパッケージをつくってみよう-その2: ビルドが必要なパッケージを作る]]」です。

* DONE Guixのパッケージをつくってみよう-その2: ビルドが必要なパッケージを作る
CLOSED: [2022-12-07 Wed 03:45]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-c5b823db-a6b6-23a4-5783-c7741fd0f420
  :EXPORT_HUGO_TAGS: GNU-Guix Scheme
  :END:
[[https://qiita.com/advent-calendar/2022/guix][https://img.shields.io/badge/GNU%20Guix%20Advent%20Calendar%202022-6%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]

** 序文
[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/][前回の記事]]では、フォントのパッケージ定義を通じて、パッケージ定義の流れを解説しました。
この記事では一歩進んで、ビルドを伴うパッケージの定義を行っていきます。

実はGNU Guixはその思想上、この「ビルド」というプロセスをきちんと行うことを大切にしています。
[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/][前回の記事]]で、ハッシュ値を確認することで偽物を掴まされていないことを確認するプロセスがあることを説明したと思いますが、
その一方で配信元がウイルスやマルウェアなどの悪意のあるコードを仕込んでいる場合は感知することはできません。
これを防ぐための究極の方法は、ソースコードから直接ビルドすることです。
公開されているソースコードからビルドすれば、ソースコードを確認することで悪意のあるコードが混入していないかを確認することができます。
一方公開されているバイナリを直接インストールする方法の場合、悪意のあるコードが混入していることを確認する術はありません。
元のソースコードが公開されていても、そのバイナリがそのソースコードからビルドされたことを確かめられないので無意味です。

このような理由で、GNU Guixはあらゆるパッケージを自分の手元でビルドすることを信条としています。
もちろんサイズが大きいパッケージをたくさん使うような場合、全てビルドするのは大変な場合もあります。
そのため、「このサーバーのビルドしたパッケージは信用できるので、ビルドする代わりにバイナリからインストールする」というのを実現する機能があります。
この機能はSubstitutesと呼ばれています。デフォルトではGNUのサーバーだけが登録されています。詳しくは[[https://guix.gnu.org/en/manual/devel/en/guix.html#Substitutes][公式マニュアル]]をご覧ください。
また、この機能はあくまでも「ビルド手順をパッケージ定義として示した上で、その手順と全く同一の手順を踏んでいるであろうバイナリを提供するサーバーを信用する」
という機能であることに注意してください。ビルド手順の記述を省略するようなことはできません。
そのへんに落ちているバイナリから直接インストールする機能は[[https://blog.rocktakey.com/information-science/2022-6353e393-4e0b-6ad4-754b-0d84ebd31c97/][次回の記事]]で説明します。

** 前提
GNU Guix自体はインストールされていて、使えるようになっていることを前提とします。
また、[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/][前回の記事]]の設定が残っていることが前提となっています。
ただし、試すだけなら必ずしもGitレポジトリを使う必要はなく、 =-L /path/to/channel= オプションを毎回使ってもよいです。
大抵のサブコマンドには対応しています。

** パッケージを定義する
今回は、[[https://geoff.greer.fm/ag/][ag]]というバイナリのパッケージを作成していきます。
agは高速なgrepとして開発されたCLIツールで、パッケージは[[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/code.scm#n337][GNU Guixの公式チャンネル]]に含まれています。
そこから引用されたコードはGPLv3 or laterによってライセンスされていることに留意してください。

前回はパッケージ定義の概要を説明するためにパッケージ定義を先に示しましたが、
今回はパッケージを作るときの流れを実際に体験してもらうため、先に最終形を示すことはしません。

まずは前回同様、モジュールを定義していきます。
チャンネルの下の =your-channel-name/packages/ag.scm= に以下を書きましょう。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages ag)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download))
#+END_SRC
この3つのモジュールはほぼ必ず =#:use-module= することになるため、これを雛形としてもよいと思います。
前回と異なるのは一行目の =(your-channel-name packages ag)= のファイル名にあたる最後の =ag= の部分くらいです。
あと、今回はフォントではないので =(gnu build-system font)= を =#:use-module= しないようにしました。

次にパッケージ定義を書いていきます。今回は本家との名前の衝突を避けるために =my-ag= という名前にしましょう。
ビルドのしかたは[[https://github.com/ggreer/the_silver_searcher#building-a-release-tarball][agのREADME]]に書いてあります。
それによると、[[https://geoff.greer.fm/ag/][ここ]]にあるtarballからビルドする場合は以下のようなコマンドでインストールできるらしいです。
ソースコードは "https://geoff.greer.fm/ag/releases/the_silver_searcher-2,2,0.tar.gz" にあるようです(リンク先のリンクにあります)。
#+BEGIN_SRC scheme
  ./configure
  make
  make install
#+END_SRC
このようなビルドの手順はLinuxにおいて非常によく使われる典型的なものです。
まずはこの典型的なビルドをできるようになって欲しいため、このパッケージを題材にしました。

この情報を元に、パッケージ定義を書いてみます。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
     (name "my-ag")
     (version "2.2.0")
     (source (origin
              (method url-fetch)
              (uri (string-append
                    "https://geoff.greer.fm/ag/releases/the_silver_searcher-"
                    version ".tar.gz"))
              (sha256
               (base32
                "0w1icjqd8hd45rn1y6nbfznk1a6ip54whwbfbhxp7ws2hn3ilqnr"))))
     (build-system gnu-build-system)
     (home-page "https://geoff.greer.fm/ag/")
     (synopsis "Fast code searching tool")
     (description
      "The Silver Searcher (@command{ag}) is a tool for quickly searching large
    numbers of files.  It's intended primarily for source code repositories, and
    respects files like @file{.gitignore} and @file{.hgignore}.  It's also an order
    of magnitude faster than its inspiration, @command{ack}, and less specialised
    tools such as @command{grep}.")
     (license license:asl2.0)))
#+END_SRC
上記のフィールドのほとんどは[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/][前回の記事]]と全く同様のため、詳細は省きますが、 =my-ag= という名前のパッケージを定義しています。
基本的に上記に示したフィールドは全て必須であるため、これをテンプレートとして穴埋めすることでパッケージを作るのが手っ取り早いです。

さて、今書いた中で最も大事なフィールドは =(build-system gnu-build-system)= です。
この変数の定義は =(guix build-system gnu)= というモジュールにあるので、このモジュールを =#:use-module= しておいてください。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages ag)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download)
    #:use-module (guix build-system gnu))
#+END_SRC

先程のフィールドでは、 =build-system= を =gnu-build-system= と指定しています。
この =gnu-build-system= は、実は正に =./configure && make && make install= の典型的なビルド手順を表しています
(詳細な仕様が知りたい方は[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Systems][公式マニュアル(英語)]]を参照)。

ただし、 =./configure && make && make install= をそのまま走らせているわけではないということに注意してください。
GNU Guixはその特性上 =/bin/= や =/lib/= の代わりに =/gnu/store/xxxxxxxxxxxxxxxxx-my-ag-2.2.0/bin/= や
=/gnu/store/xxxxxxxxxxxxxxxxx-my-ag-2.2.0/lib/= に生成物をインストールする必要があります。
そのため、 =./configure= にインストール先の接頭辞を指定する =--prefix= を付ける、などを行っています。
具体的な実装を見たい場合は、
GNU Guix公式レポジトリの[[https://git.savannah.gnu.org/cgit/guix.git/tree/guix/build/gnu-build-system.scm][guix/build/gnu-build-system.scm]]か[[https://git.savannah.gnu.org/cgit/guix.git/tree/guix/build-system/gnu.scm][guix/build-system/gnu.scm]]をご覧ください。
=#:use-module= したのは前者ですが、ビルド手順自体は主に後者に実装されています。

ビルドは具体的にどのような手順で行われるのでしょうか。これも[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Phases][公式マニュアル(英語)]]に記載されています。
=gnu-build-system= では以下のような手順で行われます。これらの各手順はフェイズ(phase)と呼ばれています。
なお、他のビルドシステムも大抵は =gnu-build-system= を継承して作られているため、似たような流れになります。
また、ソースのダウンロード自体はビルドシステムが走るよりも前に行われており、
ビルドシステムが走る環境は外のネットワークには一切繋がりません。
これはソースのハッシュ値が等しいことと成果物が等しいことを等価にするのに必要です
(ネットワークに繋がってしまうと、ソースコードが同じでもネットワーク経由の入力によって成果物が変わり得る)。
- =set-paths= :: ソースのダウンロードやビルドのための環境を用意するフェイズです。
  各種依存へパスを通したりします。
- =unpack= :: =source= に指定したソースコードのtarballやzipを展開し、ビルド用の環境へとコピーします。
- =patch-source-shebangs= :: シェルスクリプトのshebangを変更します。
  GNU GuixはFHSに従ったディレクトリ構造をしておらず、 =bash= や =sh= をも =/gnu/store/= 以下に閉じ込めているため、
  その位置をシェルスクリプトに伝えるべく =#!/bin/sh= や =#!/bin/bash= を
  =#!/gnu/store/xxxxxxxxxxxxx-bash-0.0/bin/sh= や =#!/gnu/store/xxxxxxxxxxxxx-bash-0.0/bin/bash= に置き換えます。
- =configure= :: =./configure= を実行します。先程述べたように、 =--prefix= 引数によってインストール先が変更されます。
  また、後述の =#:confiugre-flags= 引数によって追加のオプションを指定できます。
- =build= :: =make= を実行します。他のビルドシステムの場合でも、このフェイズで実際のビルドが走ることが多いです。
  なお、前述のとおり、ここではネットワークには一切繋がりません。
  そのため、外からダウンロードしてくる操作がビルドスクリプトに含まれていると失敗します。
  その場合、外からダウンロードしてくる操作自体をビルドスクリプトから取り除くか実行されないようにして、
  ダウンロードされてくる部分を別のパッケージとして定義し、それを依存としたパッケージを定義する必要があります。
  この作業はかなり大変です。後述の =#:phases= 引数を使ってこのフェイズ自体を一から書き直したり、
  [[https://guix.gnu.org/en/manual/devel/en/guix.html#index-substitute_002a][=substitute=]]マクロ(前述のバイナリ提供サーバーとしてのsubstituteとは無関係。 =#:phases= の詳細説明を参照)
  を使ってビルドスクリプトを修正するフェイズをビルド前に追加したりすることで対応することになります。
  ここはどうしてもアドホックになりがちなところです。
- =check= :: =make check= を実行します。後述の =#:tests?= 引数によって抑制できます。
- =install= :: =make install= を実行します。 =./configure= に渡された =--prefix= オプションにより、
  =/gnu/store/= 直下にある専用のインストール先にインストールされます。
- =patch-shebangs= :: =patch-source-shebangs= とほとんど同じです。
  今回はソースコードではなくインストールされた実行ファイルに適用されます。
- =strip= :: 生成されたバイナリからデバッグ情報を取り除きます。
  なにをしているのかをあまり気にすることはないのですが、このフェイズでたまにコケるので、
  その場合は後述の =#:strip-binaries?= 引数を =#f= とするとよいです。
- =validate-runpath= :: 生成されたバイナリの =RUNPATH= を確認し、依存するライブラリがきちんと存在するかどうかを検証します。
  このフェイズも引数を用いて飛ばすことは可能ですが、ここでコケるのはライブラリの依存が足りていない証拠なので、
  「足りない」と言われた依存を適宜追加してください。

さて、ビルドシステムの説明も終わったことなので、先程書いたパッケージを一旦ビルドしてみましょう。
#+BEGIN_SRC scheme
  guix build -L /path/to/your/channel my-ag
#+END_SRC
すると、たくさんのビルドログの下のほうに、エラーが出るはずです。
実は、一番下を見てもあまり有用な情報は出てきません。なぜなら末尾のエラーはScheme及びGNU Guixがコケたことによるエラーだからです。
少し上に、コケた根本の原因、すなわちどこかのフェイズで実行された実際のコマンドのエラーのログがあるはずです。
今回は、以下のような =configure= フェイズのエラーが出ているはずです。
#+BEGIN_SRC
  configure: error: The pkg-config script could not be found or is too old.  Make sure it
#+END_SRC
これが出るのは正常です。 =ag= のビルドに必要な依存を一切入れていないからです。
[[https://github.com/ggreer/the_silver_searcher#building-a-release-tarball][agのREADMEのBuilding a Release tarball]]と[[https://github.com/ggreer/the_silver_searcher#building-master][Building master]]を読むと、以下が必要そうだとわかります。
- =automake=
- =pkg-config=
- =PCRE=
- =LZMA=
このうち  =automake= は =gnu-build-system= においては自動で利用可能になっているので、気にする必要はありません。
とりあえず、 =pkg-config= を依存として追加してみましょう。

依存は =package= オブジェクトに =inputs= フィールドや =native-inputs= として渡します(それらの違いは後述)。
渡す値は =package= オブジェクトのリストになります。
つまり、依存パッケージを格納している変数がどのモジュールで定義されているか知る必要があります。
パッケージの検索には =guix search= や =guix package -A= を使います。
=guix search= では説明文も含めて検索しますが、 =guix package -A= の場合はパッケージ名だけが検索の対象になります。
また、ブラウザでは[[https://packages.guix.gnu.org/][こちら]]で検索することも可能です。
#+BEGIN_SRC shell
  guix search pkg-config
#+END_SRC
結構たくさん候補が出てくるのですが、一番上に =pkg-config= というそのままのパッケージがあります。
ある特定のパッケージの情報だけを見たい場合は、 =guix show= を使います。
#+BEGIN_SRC shell
  guix show pkg-config
#+END_SRC
すると以下のような表示が得られます。
ブラウザの検索の場合は[[https://packages.guix.gnu.org/packages/pkg-config/0.29.2/][こちら]]をご覧ください。
#+begin_example
name: pkg-config
version: 0.29.2
outputs:
+ out: everything
systems: x86_64-linux i686-linux
dependencies:
location: gnu/packages/pkg-config.scm:37:2
homepage: https://www.freedesktop.org/wiki/Software/pkg-config
license: GPL 2+
synopsis: Helper tool used when compiling applications and libraries
description: pkg-config is a helper tool used when compiling applications and libraries.  It helps you insert the correct compiler options on the command
+ line so an application can use gcc -o test test.c `pkg-config --libs --cflags glib-2.0` for instance, rather than hard-coding values on where to find glib
+ (or other libraries).  It is language-agnostic, so it can be used for defining the location of documentation tools, for instance.
#+end_example
=location= が =gnu/packages/pkg-config.scm= となっていることから、このパッケージは =(gnu packages pkg-config)= モジュールに定義されていることがわかります。
行数は現時点でのものなので今後変更されているかもしれません。念のため定義を見ておきましょう。locationはブラウザでもコマンドラインでもリンクになっています。
公式レポジトリでいうと[[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/pkg-config.scm#n37][こちら]]になります。そこには以下のような定義が書いてあります。
#+BEGIN_SRC scheme
  ;; This is the "primitive" pkg-config package.  People should use `pkg-config'
  ;; (see below) rather than `%pkg-config', but we export `%pkg-config' so that
  ;; `fold-packages' finds it.
  (define-public %pkg-config
    (package
     (name "pkg-config")
     (version "0.29.2")
     ...))
#+END_SRC
どうやら変数自体は =%pkg-config= だけど、普通に =pkg-config= を使ってくれと書いてあります。
今回の場合は該当しませんが、変数名とパッケージ名は異なる場合がたまにあるので、このように確認する作業が必要になります。

さて、どのモジュールのどの変数に =pkg-config= のパッケージが保存されているかわかったので、それを依存に入れていきます。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (native-inputs
       (list pkg-config))
      ...))
#+END_SRC
=native-inputs= は「ビルドを行うプラットフォームで必要なパッケージ」を指定します。
実はGNU Guixは今いるプラットフォームとは別のプラットフォーム用のパッケージをビルドする機能があります。
「ビルドには必要だけど実際使うときにはいらないパッケージ」と捉えていただいて構いません。
一方 =inputs= は実行時にも必要な依存を記述します。なお、 =propagated-inputs= というものも存在します。
=propagated-inputs= に指定された依存は親パッケージをインストールすると一緒にインストールされます。

さて、これで再びビルドしてみましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel my-ag
#+END_SRC
すると、以下のようなエラーが得られます。
#+begin_example
ice-9/eval.scm:223:20: In procedure proc:
error: pkg-config: unbound variable
hint: Did you forget `(use-modules (gnu packages pkg-config))'?
#+end_example
そういえば、 =pkg-config= が定義されているモジュール =(gnu packages pkg-config)= を指定していませんでしたね。
このようにモジュールを指定せずに変数を使ってしまっても、かなりの確率で教えてくれます。
勘で依存パッケージの変数を書いてビルドして、ヒントでどこにあるか確認するという横着もできてしまいます(私もけっこうやる)。
#+BEGIN_SRC scheme
scheme
  (define-module (your-channel-name packages ag)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download)
    #:use-module (guix build-system gnu)
    #:use-module (gnu packages pkg-config))
#+END_SRC

これでもう一度ビルドしましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel my-ag
#+END_SRC
今度は最初とは別のエラーが =configure= フェイズで出ています。
#+begin_example
configure: error: Package requirements (libpcre) were not met:

No package 'libpcre' found
#+end_example
先程言ったように、  =PCRE= が依存として必要でした。他にも =LZMA= が必要とのことだったので、一気に解決を試みましょう。

先程と同様に =guix search= やブラウザでの検索を行うと、 =pcre= は =(gnu packages pcre)= モジュールにある =pcre= という変数に束縛されたパッケージに
あるとわかります。ここでは詳細を省きます。 =pkg-config= のときと全く同じなので、是非実際に試してみてください。


=LZMA= についても同様に検索しますが、どうも =lzma= という名前のパッケージはないようです。
これでは埒があかないので、とりあえずビルドして =./configure= がどんなエラーを吐くか見てみましょう。
=(gnu packages pcre)= モジュールを =use-module= しつつ、以下のようにパッケージ定義を変更しましょう。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (native-inputs
       (list pkg-config))
      (inputs
       (list pcre))
      ...))
#+END_SRC
依存として =inputs= に =PCRE= を追加しました。ビルドしてみましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel my-ag
#+END_SRC
すると以下のようなエラーが =build= フェイズで得られます。 =configure= フェイズはどうやら正常に通ったようです。
#+begin_example
  src/zfile.c:63:9: error: unknown type name ‘z_stream’
     63 |         z_stream gz;
        |         ^~~~~~~~
  (後略)
#+end_example
ここからはGNU Guixに限った話ではなく、ただただビルドを通るまで依存を追加していく作業になります。
幸い =z_stream= でググると =zlib= の話が大量に出てくるので、 =zlib= に定義されていることがすぐわかります。
また、もう一度基本に戻って[[https://github.com/ggreer/the_silver_searcher#building-master][公式のビルド手順]]を見てみると、Fedoraにおける依存解決のしかたが書いてあります。
#+BEGIN_SRC shell
  yum -y install pkgconfig automake gcc zlib-devel pcre-devel xz-devel
#+END_SRC
どうも、ここでも =zlib= が必要なことがわかります。(もうひとつ =xz= というのも入っていますが、とりあえず無視しておきます。)
GNU Guixでのビルド方法の情報は少ないため、このような他のディストロの情報を利用するのも大切です。

先程と同じように =zlib= というパッケージを探し出していきます。
ここも詳細は省きますが、 =(gnu packages compression)= モジュールに =zlib= が定義されています。
=#:use-module= しつつまた依存を追加していきます。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (native-inputs
       (list pkg-config))
      (inputs
       (list pcre zlib))
      ...))
#+END_SRC
ここでビルドすると、 =build= フェイズの最後に行うリンクでコケます。
#+begin_example
    CCLD     ag
  ld: src/log.o:/tmp/guix-build-my-ag-2.2.0.drv-0/the_silver_searcher-2.2.0/src/log.h:12: multiple definition of `print_mtx'; src/ignore.o:/tmp/guix-build-my-ag-2.2.0.drv-0/the_silver_searcher-2.2.0/src/log.h:12: first defined here
  ld: src/log.o:/tmp/guix-build-my-ag-2.2.0.drv-0/the_silver_searcher-2.2.0/src/util.h:15: multiple definition of `out_fd'; src/ignore.o:/tmp/guix-build-my-ag-2.2.0.drv-0/the_silver_searcher-2.2.0/src/util.h:15: first defined here
  (後略)
#+end_example
=ag multiple definition of= で検索してみると、どうやら [[https://github.com/ggreer/the_silver_searcher/issues/1378][=ag= 自体のバグ]]なようです。そこの説明文をみるに、
GCC-10(=gnu-build-system= で利用されるデフォルトのGCCのバージョンは2022/12/7現在では10です)では
=./configure= に ~CFLAG=-fcommon~ を付けないと動かないとのこと。このような場合、どうすればよいでしょうか。

実は「ビルドシステム」というのは引数を取ることができます。
引数は =package= のフィールドとして直接与えます。つまり以下のように書きます。
#+BEGIN_SRC scheme
  (define-public example
    (package
     (name "example")
     (version "0")
     ...
     (arguments
      '(#:tests? #f
        #:configure-flags '("--some-option" "--other-option")))
     (build-system gnu-build-system)
     ...))
#+END_SRC
使用するビルドシステムによって取れる引数は異なりますが、
ほとんどのビルドシステムは =gnu-build-system= を継承して作られているため、代表的なものは他のビルドシステムでも
利用できます。折角なのでいくつか紹介しておきます。[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Systems][公式マニュアル(英語)]]で一覧を見ることができます。
- =#:configure-flags= :: =./configure= に渡されるオプションを文字列のリストで渡します。
  典型的にはオプションの機能をオンにしたりオフにしたりするのに使います。
- =#:make-flags= :: =make= 、 =make check= 、 =make install= に渡されるオプションを文字列のリストで渡します。
  あまり利用頻度は多くないです。
- =#:tests?= :: テスト(=make check=)をするかどうか、すなわち =check= フェイズを行うかどうか真偽値で渡します。
  デフォルトでは =#t= (Schemeにおけるtrue)となっていて、
  ネットワークがないとテストが通らない場合やそもそもテストがない場合には
  =#f= (Schemeにおけるfalse)を指定してテストをしないようにします。
- =#:strip-binaries?= :: 生成されたバイナリからデバッグ情報を取り除くかどうか、
  すなわち =strip= フェイズを行うかどうかを真偽値で渡します。
- =#:phases= :: この引数が最も柔軟にビルド内容を変更できます。
  具体的には、ビルドプロセスの1手順(phase)をまるっと別のものに入れ替えたり、ある手順の前や後ろに別の手順を追加したりできます。
  詳細の書き方を以下に置いておきますが、かなり難しい内容になっているため、一旦飛ばしても構いません。

#+begin_details
#+begin_summary
=#:phases= 引数を利用するための詳細な説明
#+end_summary
各フェイズ自体もSchemeで書かれているため、無名関数を与えるだけで新しいフェイズを与えることができます。
この引数として与える式は、ほとんどが =(modify-phases %standard-phases ...)= という形です。
=%standard-phases= というのは =build-system= を経由して与えられるフェイズ群で、
これを修正した新しいフェイズ群を与えることでフェイズの変更を達成しています。

=(modify-phases %standard-phases ...)= のうち =...= の部分には以下の4つをいくつでも書くことができます。
- =(delete 'phase-name)= :: =phase-name= という名前のフェイズを削除します。
- =(replace 'old-phase-name 無名関数)= :: =old-phase-name= という名前のフェイズを新しいフェイズに置き換えます。
- =(add-before 'base-phase-name 'new-phase-name 無名関数)= ::
  =base-phase-name= という名前のフェイズの前に =new-phase-name= という名前の新しいフェイズを追加します。
- =(add-after 'base-phase-name 'new-phase-name 無名関数)= ::
  =base-phase-name= という名前のフェイズの後に =new-phase-name= という名前の新しいフェイズを追加します。
無名関数は新しいフェイズの定義になります。
無名関数はキーワード引数を受け取ります。
受け取れる引数は =#:make-flags= などの各種引数と、 =inputs= や =outputs= といった連想リストです。
=inputs= は、キーを依存の名前、値を依存として与えられたディレクトリ(読取専用)へのパスとした連想リストです。
=outputs= は、キーを出力の名前(普通に定義したパッケージは"out"のみをキーとする)、
値を出力先(インストール先)のディレクトリへのパスとした連想リストです。
これらを用いることで、新しいフェイズから依存のディレクトリやインストール先のディレクトリを直接触ることができます。
たとえばデフォルトの出力先である"out"に対応するディレクトリを取り出す場合は、 =(assoc-ref outputs "out")= とします。

以下に例を示します。この例は[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Phases][公式マニュアル(英語)]]からの引用です。
#+BEGIN_SRC scheme
  (define-public example
    (package
      (name "example")
      ;; other fields omitted
      (build-system gnu-build-system)
      (arguments
       '(#:phases (modify-phases %standard-phases
                    (delete 'configure)
                    (add-before 'build 'set-prefix-in-makefile
                      (lambda* (#:key outputs #:allow-other-keys)
                        ;; Modify the makefile so that its
                        ;; 'PREFIX' variable points to "out".
                        (let ((out (assoc-ref outputs "out")))
                          (substitute* "Makefile"
                            (("PREFIX =.*")
                             (string-append "PREFIX = "
                                            out "\n")))))))))))
#+END_SRC
この例では2つのフェイズ修正を行っています。
一つ目は =(delete 'configure)= による =configure= フェイズの削除です。
二つ目は =(add-before 'build 'set-prefix-in-makefile ...)= による新しいフェイズの追加です。

Schemeでキーワード引数を受け取る無名関数を作りたい場合、
=(lambda* (#:key key1 key2 #:allow-other-keys) ...)= のように書きます。
特に =#:allow-other-keys= は必要のないキーワード引数を受け取ってもエラーにならないようにするもので、
フェイズのようにどんな引数が渡されるかわからないような状況では便利です。

今回受け取って引数として束縛するキーワード引数は =outputs= だけです。
前述のようにここには連想リストが束縛されています。
その後、 =let= 節を用いて =(assoc-ref outputs "out")= すなわちインストール先のディレクトリへのパスを
=out= 一時変数に束縛しています。
さらにその後 =substitute*= マクロを使っています。
このマクロは、第一引数に与えられたファイルにおいて、第二引数以降で指定された置換を実行します。
第二引数以降は =((regexp...) body...)= の形を取っていて、 =(regexp...)= には置換したい対象を表す正規表現のリストを、
=body= は順次評価したときに最後の評価結果が置換後の文字列になるようなS式群を表しています。
これにより =Makefile= の中にある 「PREFIX=.*」にマッチする文字列すべてが、
「PREFIX=パッケージにおけるインストール先のディレクトリの絶対パス」へと置き換わります。

=arguments= として与えられたリストはクオートされていることに注意してください。
すなわち、 *今の無名関数を含めた =arguments= 下にあるS式は、現環境では評価されません。*
これがなにを意味するかというと、現在のモジュールで =#:use-module= 宣言をいくらしたところで、
さきほどの無名関数からそのモジュールの機能には一切アクセスできません。
なぜなら各 =arguments= が評価される環境は現在のモジュールを定義した環境ではなく、
=guix= がパッケージをビルドしようとしたときの環境だからです。
もしなんらかのモジュールを無名関数で利用したい場合、
無名関数の中で =use-modules= マクロを呼び出すことであらためてモジュールの使用を宣言してください。
以下は =(ice-9 match)= モジュールと =(srfi srfi-26)= モジュールを無名関数の中で使う場合の例です。
#+BEGIN_SRC scheme
  (lambda* (#:key outputs #:allow-other-keys)
   (use-modules (ice-9 match)
                (srfi srfi-26))
   ...)
#+END_SRC
#+end_details

つまり、今回の場合は =#:configure-flags= として ~CFLAG=-fcommon~ が与えられればよいわけです。
つまり以下のように書きます。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (arguments
       '(#:configure-flags (list "CFLAGS=-fcommon")))
      ...))
#+END_SRC
この状態で再びビルドしてみましょう。

すると、エラーが全く出ずに最後まで実行できました。ビルド成功です。しかしまだ喜んではいけません。
それがインストールされた環境へ入って実行してみましょう。今回は =--pure= でも =--container= でも構いません。
#+BEGIN_SRC shell
  guix shell --pure -L /path/to/your/channel my-ag
#+END_SRC
たとえば今作っていたチャンネルのディレクトリに入り、 =ag home-page= と実行してみましょう。
すると、我々が今作成したパッケージや、前回の記事で作ったフォントのパッケージの =home-page= フィールドがきちんとみつけられました。
きちんと動いています。

#+begin_details
#+begin_summary
=xz= について
#+end_summary

先程見た[[https://github.com/ggreer/the_silver_searcher#building-master][公式のビルド手順]]には、Fedoraにおける依存解決のしかたが書いてありました。
#+BEGIN_SRC shell
  yum -y install pkgconfig automake gcc zlib-devel pcre-devel xz-devel
#+END_SRC
ここには、 =xz= というみたことのない依存を入れています。
なくても動きますが、[[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/code.scm#n338][公式のチャンネル]]の定義では入れています。
せっかくなので =xz= を入れていきましょう。

まずは、 =xz= を検索してみます。今度は =guix package -A= を使ってみましょう。
#+BEGIN_SRC shell
  guix pacakge xz
#+END_SRC
すると以下のようなリストが得られます。
#+begin_example
  java-xz             	1.9  	out       	gnu/packages/java-compression.scm:288:2
  pixz                	1.0.7	out       	gnu/packages/compression.scm:1059:2
  rust-xz2            	0.1.6	out       	gnu/packages/crates-io.scm:67762:2
  xz                  	5.2.5	out,static	gnu/packages/compression.scm:509:2
  xzgv                	0.9.2	out       	gnu/packages/image-viewers.scm:983:2
#+end_example
ずばり =xz= という名前のパッケージがあるので、これを使うとよさそうです。
=guix show xz= で詳細情報も確認しておくと確実です(LZMAに触れられています)。
モジュールは =zlib= と同様なので新しく =use-module= する必要はなさそうです。
変数名もそのまま =xz= であることを確認し、依存として =inputs= に =xz= も追加します。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (native-inputs
       (list pkg-config))
      (inputs
       (list pcre zlib xz))
      ...))
#+END_SRC
これでも同様に動きますが、動作に必要あるかは不明です(もしかしたら =xz= がないと特定の機能だけ動かない可能性もある)。
#+end_details

** =guix import= で手抜きできる場合がある
ビルドが必要なパッケージの定義を実際に行っていきました。それなりに大変だったと思います。
使いたいパッケージの度にこれを行うのは億劫だという人もいると思います。
実は、比較的簡単にパッケージを定義できる場合があります。それは、 =guix import= が利用できる場合です。

=guix imort= は、インポーターというものを使って自動でパッケージ定義を書く機能です。
インポーターの一覧など、詳しくは[[https://guix.gnu.org/en/manual/devel/en/guix.html#Invoking-guix-import][公式マニュアル(英語)]]にありますが、例えば以下のようにしてパッケージを生成できます。
#+BEGIN_SRC shell
guix import go gopkg.in/yaml.v2 --recursive
#+END_SRC
=go= というのがインポーターを表していて、[[https://proxy.golang.org/]]からメタデータを取得することでパッケージ定義を生成します。
=--recursive= は依存を再帰的に辿ってパッケージ定義を生成するオプションで、付けないと依存が足りずにビルドがコケます。
また、デフォルトでは標準出力に定義を吐くため、ファイルにでも流しこんでください。
モジュール定義 や =#:use-module= は行ってくれないので、自分で行ってください。

もちろん =guix import= だけで全てのパッケージ定義を賄うことはできないですし、これを用いてもビルドが失敗することはあります。
それでも、依存先のパッケージなども含めて一気に定義できるのは有用ですし、
ビルドが失敗しても今回の記事のようにビルドを成功へ導いてあげればよいです。
是非利用してみてください。

** 最後に
今回の記事では、ビルドの必要なパッケージ定義を扱いました。
これをマスターすればあなたも =guix= の玄人です。

前回とおなじ締めですが、もしなにか質問などあれば、コメントなりメールなりで受け付けます。
また、Guixの日本語コミュニティである[[https://guix-jp.gitlab.io/][Guix-jp]]もあります。
そちらには私以上のエキスパートの人がいますので、是非そちらもご興味あれば覗いてみてください。

* TODO Guixのパッケージをつくってみよう-その3: どうしてもビルドできないときはバイナリを直接使ったパッケージを作る
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-6353e393-4e0b-6ad4-754b-0d84ebd31c97
  :EXPORT_HUGO_TAGS: GNU-Guix Scheme nonguix
  :END:
[[https://qiita.com/advent-calendar/2022/guix][https://img.shields.io/badge/GNU%20Guix%20Advent%20Calendar%202022-7%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]

* TODO micを使って自分だけのuse-pacakgeを定義し、init.elを管理する
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-48b1a128-e423-8444-202b-3c25fd244198
  :END:
* TODO GNU Guixとはなにか
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-0a6933eb-cb7e-7cd4-db1b-af5a8571d6d5
  :EXPORT_HUGO_TAGS: GNU-Guix GNU-Guix-System advent-calendar
  :END:
** 序文
この記事では、GNU Guixというパッケージマネージャ、及びそれと密に関連するGNU Guix SystemというLinuxのディストロを紹介します。
** TL;DR
- GNU Guixは汎用パッケージマネージャ
  - =apt= などと共存可能
  - 環境を自由にいったりきたりできる(=guix package --roll-back= 、 =guix shell=)
  - 環境を宣言的に記述できる(=manifest.scm=)
  - パッケージ定義群を自分で書いて自分で使える(=~/.config/guix/channels.scm=)
- GNU Guix SystemはLinuxのディストロ
  - 標準でGNU Guixが搭載
  - パッケージだけでなく、カーネル自体やカーネルオプションなども宣言的に記述可能(=config.scm=)
** GNU Guixとは？
GNU Guixは、パッケージマネージャの一種です。
パッケージマネージャには =npm= 、 =cargo= 、 =opam= のような言語特化のものと、
=apt= や =yum= のような汎用のものがありますが、GNU Guixは後者、すなわち汎用パッケージマネージャにあたります。
汎用なパッケージマネージャは通常OS標準のものを使うと思います。
GNU Guixはどのようなディストロにも後から入れられて、OS標準のパッケージマネージャと干渉することはないので、
少しずつ乗り換えることも可能です。

GNU Guixの最大の特徴は、「環境を自由にいったりきたりできる」ということです。
あるパッケージを入れたけどやっぱり微妙だったとか、なんか動作が不調になったとかがあれば、すぐに元に戻せます。
また、一時的に全く別の環境(つまり現環境とは全く別のパッケージ群の入った環境)に入ったり、
今の環境に追加で新しいパッケージを入れた新環境を一時的に使う、といったことが可能です。
さらに、ファイルシステムを完全に切り離したコンテナ環境を用意することも可能です。望むならdockerイメージも生成できます。

もうひとつ特徴を挙げるとすれば、「環境を宣言的に記述できる」ところです。
=manifest.scm= と呼ばれるファイルで環境を記述しておけば、誰のPCでもその環境を用意して実行が可能ですし、
新しいパソコンを買ったあとの環境構築も自動化できます。
このあたりはdockerを始めとしたコンテナ技術と雰囲気が近いかもしれませんが、デフォルトの環境、一時的な環境、コンテナの環境のすべてを
統一的に扱っているという点では少し異なります。
ちなみに、 =manifest.scm= はSchemeというプログラミング言語で書かれているため、やろうと思えばだいたいなんでもできます。

さらにもう一つ推しポイントがあります。それは、「パッケージ定義群を自分で書いて自分で使える」ということです。
これは地味ですがかなり便利です。
=apt= で「あれ、あのパッケージデフォルトにないのか、どうやってやるんだっけな、検索しよ」というのをUbuntu入れ直すたびにやっている私としては革命でした。
一度パッケージ定義を書いておけば、あとはGNU Guixを経由して入れるだけでよいです。
さらに言えば、GNU Guix経由でパッケージを入れておけば、前述のメリットが全て享受できます。
すなわち、環境をいったりきたりしたり、宣言的に記述したりという対象に、新しく自分で定義したパッケージも含めることができます。
**
