#+title: Information Science
#+author: ROCKTAKEY

#+options: ^:{}

#+hugo_base_dir: ../
#+hugo_section: information-science

#+link: files file+sys:../static/files/
#+link: images https://raw.githubusercontent.com/ROCKTAKEY/images/blog/%(my-org-netlify)
# ~my-org-netlify~ can be gotten from https://gist.github.com/ROCKTAKEY/e67ec5f1db4fbc9f1976fb7a3b27e2ef

* DONE Information Science
  CLOSED: [2020-08-05 Wed 17:37]
 :PROPERTIES:
 :EXPORT_FILE_NAME: _index
 :EXPORT_HUGO_LASTMOD: [2020-08-06 Wed 12:33]
 :END:

  主にEmacsの話になりそう。C++や競技プログラミングの話もするかも。
* DONE tab-bar-modeを探検する
  CLOSED: [2020-08-21 Fri 19:22]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2020-d99103ba-db6f-5424-3053-087c12ab74be
  :EXPORT_HUGO_TAGS: Emacs Emacs-Lisp tab-bar-mode
  :END:
** 導入
   Emacs-27.1で、 ~tab-bar-mode~ と ~tab-line-mode~ が追加された。

   ~tab-line-mode~ では、[[fig:tab-line-mode]]にあるように、
   ウィンドウ[fn:1:Emacsにおいては、一般に言うウィンドウをフレームと言い、フレームを分割したものをウィンドウと言う。]
   上部(ヘッダラインという)にバッファ一覧が
   タブとして表示される。バッファ切り替えを行うときにそれをクリックすることで
   バッファを切り替えられる。
   実装を見ると、どうやら ~window-next-buffers~ と ~window-prev-buffers~ を用いて
   表示するバッファを決めているようなので、さしあたりでは ~C-x b~ (~switch-bufer~)
   の一部代替、及び ~next/previous-buffer~ の代替が目的だろう。
   バッファリストが表示されるという点では ~C-x C-b~ (~list-buffer~)や ~ibuffer~ の
   代替とも捉えられるが、横幅に限りがあることと、そもそも ~window-next/prev-buffer~
   では全バッファを網羅できないことを踏まえると、完全に置き換えるには貧弱だろう。
   ~tab-line-mode~ に関しては、バッファ切り替えを文字以外で行うのに
   慣れることができそうもないので、ここまでにしておく。

   #+caption: ~global-tab-line-mode~ をオンにしたEmacs。各ウィンドウにタブ欄がある。
   #+attr_latex: scale=0.75
   #+label: fig:tab-line-mode
   [[images:tab-line-mode.png]]

   私が今回説明したいのは、 ~tab-bar-mode~ である。こちらは先程とは違い、
   *1つのフレーム[fn:1]につき1つ* 、一番上にタブ欄が表示される。
   このタブが切り替えるのはウィンドウ構成、つまりどの位置になんのバッファを表示した
   ウィンドウがあるかの情報、である。これはとても有用だ。
   単純に表示領域が足りないからというのもあるが、やはり大きいのは、
   突然別のことをやりたくなったときに今の状態を保持してさっと移り、
   終わったら戻ってこれることだ。だれしも一度は経験した、「さっきなに見てたっけ」
   「さっきまでなにがしたかったんだっけ」というのが格段に減ることだろう。
   現実世界にもはやく実装されてほしい。今まで机の上を保存したいと何度思ったことか。

   #+caption: ~tab-bar-mode~ をオンにしたEmacs。ウィンドウは複数あるがタブ欄は1つだけだ。
   #+attr_latex: scale=0.75
   #+label: fig:tab-bar-mode
   [[images:tab-bar-mode.png]]

*** ~elscreen~ との比較
   同じことをしてくれるパッケージには、
   [[https://github.com/knu/elscreen][~elscreen~]] がある。こちらも同様にウィンドウ構成を切り替えられ、今まで利用してきたが、
   いくつか欠点がある。

   一つは、タブの表示が貧弱なことだ。
   基本的にヘッダラインに表示しているので、(同じ内容なのに)全てのウィンドウで表示されたり、
   左右に分割されているウィンドウでは半分しか見えなかったりといった感じで、
   痒いところに手が届かない。やはりタイトルバーのようにフレーム一杯に広がっている領域が1つだけ欲しい。
   そういうわけで過去に[[https://github.com/conao3/navbar.el][navbar.el]]というものの制作([[https://github.com/papaeye/emacs-navbar][元]]があるので正確には改修)に少しだけ携わった
   ことがある(今もメンテナではあります)が、いかんせん古いコードだったので、かなりバギーで、
   動作が怪しい。それに比べると、 ~tab-bar-mode~ はかなり優秀だと思う。
   先程述べたとおり、 ~tab-bar-mode~ では1フレームにつき一つ、タブ一覧がフレーム一杯に広がっている。
   それでいて、GNU Emacsに取り込まれていることからある程度の動作は保証されているからだ。

   もう一つは、前段落とやや被るが、 ~elscreen~ は外部パッケージであることだ。
   あくまでもGNU Emacsの外の存在である。ウィンドウ構成周りは元々複雑でバグが入りやすいため、
   ウィンドウ構成の管理が外部パッケージだと、どうしても怪しい動作が目立つ。
   その点 ~tab-bar-mode~ はGNU Emacsに取り込まれているので、安心できる。
   もちろんバグが絶対にないわけではないが、本家に入っているなら安定性は重視されているだろう。

   ただし、もちろん利点もある。 ~elscreen~ はかなりの古参なので、拡張がたくさんある。
   ~elscreen-persist~ なんかは(MELPAからは消えているとはいえ)その筆頭だろう。
   ~tab-bar-mode~ にそのような類のものはまだないので、
   永続化したい人は乗り換えを待ったほうがいいかもしれない。


** 基本的な使い方とキーバインド
   まず、 ~M-x tab-bar-mode~ で ~tab-bar-mode~ をオンにすることで上部にタブが出てくる
   [fn:2:なお、この操作は必須ではない。名前とは矛盾するが、 ~tab-bar-mode~ がオフでも
   ~tab~ 系の関数を使うことができる。]。
   気に入ったら ~init.el~ に以下のように書けばよい。
   #+begin_src emacs-lisp :tangle yes
   (tab-bar-mode +1)
   #+end_src

   見た目については、アクティブなタブは ~tab-bar-tab~ 、
   非アクティブなタブは ~tab-bar-tab-inactive~ のfaceを変更すれば変えられる。
   といってもどちらも ~tab-bar~ にinheritしているので、
   ~tab-bar~ のほうのfaceを変えるのがお手軽かもしれない。

   と、ここまではただの見た目だ。これはとりあえず見た目を他と合わせたい自分用。
   とりあえず、先にキーバインドを示しておく。prefixは ~C-x t~ で ~tab-prefix-map~
   に登録されているので、もしこれを変えたければ適宜 ~define-key~ すればよい。

   #+caption: ~tab-bar~ 系のキーバインド(~C-x t~ は省略)
   | key        | function                     | summary                    |
   |------------+------------------------------+----------------------------|
   | ~2~        | ~tab-new~                    | タブの新規作成             |
   | ~1~        | ~tab-close-other~            | 現在のタブ以外全て削除     |
   | ~0~        | ~tab-close~                  | 現在のタブの削除           |
   | ~o~        | ~tab-next~                   | 次のタブへ移動             |
   | ~m~        | ~tab-move~                   | 現在のタブの位置を移動     |
   | ~r~        | ~tab-rename~                 | タブに名前を付ける         |
   | ~RET~      | ~tab-bar-select-tab-by-name~ | 名前でタブを選択           |
   | ~b~        | ~switch-to-buffer-other-tab~ | バッファを新しいタブで開く |
   | ~C-f~, ~f~ | ~find-file-other-tab~        | ファイルを新しいタブで開く |


   各コマンドの詳細はこれから書くが、基本は ~C-x t 2~ でさくっとタブを作り、
   おわったら ~C-x t 0~ で消す運用だろう。名前はお好みで ~C-x t r~ を使って付ける。
   一斉に消したければ ~C-x t 1~ 。これくらい覚えていれば使えると思う。

*** 各キーの説明
   ~2~ (~tab-new~)、 ~1~ (~tab-close-other~)、 ~0~ (~tab-close~)、 ~o~ (~tab-next~)に関しては、
   バッファやウィンドウを操作する ~C-x~ 系の
   ~split-window-below~ (~C-x 2~)、 ~delete-other-windows~ (~C-x 1~)、
   ~delete-window~ (~C-x 0~)、 ~other-window~ (~C-x o~)に倣っているようだ。
   たしかに、間に ~t~ を挟むだけだし、手に馴染んでいるのでわかりやすい。
   3ストロークはちと多い気もするが、連発するものでもないのでそこまで問題なさそうだ。

   ~m~ (~tab-move~)はすこしわかりづらいかもしれないが、要は表示されたタブの並び換えに使う
   ものだ。現在のタブを一つ右に移動させる。並べ替えにどれほどの需要があるかは
   不明だが、複数の関連するウィンドウ構成をまとめておきたいときには有用だろう。

   ~r~ (~tab-rename~)はタブに名前を付けるものだ。renameの名が冠されているが、
   デフォルトではタブには名前がなく、カレントバッファの名前が動的に表示される
   ([[#tab-bar-tab-name-function][こちら]]で変更可能)ので、
   名前を最初につけるときにも使うことになる。フランクに使うなら
   わざわざ名前はつけなくてもいいかもしれない。

   ~RET~ (~tab-bar-select-tab-by-name~)は名前を入力してタブを選択する形だ。
   名前がついてない場合はカレントバッファが候補の名前となる。
   ~completing-read~ を直で呼んでいるので、 ~ido~ や ~ivy~ を使いたければ 他と同様に
   ~completing-read-function~ を ~ido-completing-read~ や ~ivy-completing-read~ とすればよいだろう。

   ~b~ (~switch-to-buffer-other-tab~)、 ~f~ 、 ~C-f~ (~find-file-other-tab~)も ~C-x~ 系に倣っている。
   それぞれ選択したバッファ、ファイルを新しいタブで開くもので、丁度
   ~C-x b~ (~switch-to-buffer~)と ~C-x C-f~ (~find-file~)に対応している。

*** ~tab-bar-history-mode~
    また、 ~tab-bar-history-mode~ というものもある。これは各タブでウィンドウ構成の履歴を
    辿れるようにするものだ。よほど重たいのでなければ、オンにしない手はない。
    #+begin_src emacs-lisp :tangle yes
    (tab-bar-history-mode +1)
    #+end_src
    利用できる関数は2つだけ。 ~tab-bar-history-back~ と ~tab-bar-history-forward~ だ。
    それぞれがウィンドウ構成履歴を戻る、進む役割をもつ。
    また、タブ一覧の一番左側にでてくる2つの矢印にも同じものが割り当てられている。

** Custom variables
   この節ではカスタマイズ変数の説明をする。括弧内は初期値。
   あまり重要でなさそうなのは載せてないので、各自で調べてね☆

*** ~tab-bar-show~ (~t~)
    先述のようなタブ操作系のキーバインドを使ったときに、自動で ~tab-bar-mode~ を
    オンにして、タブを表示するかどうか。 ~t~ なら常にそうする。
    ~nil~ なら常にそうしない。 ~1~ なら2つ以上のタブがあるときだけ表示する。

*** ~tab-bar-new-tab-choice~ (~t~)
    新規タブがどの状態で始まるかどうか。 ~t~ ならカレントバッファ1つ。
    ~nil~ なら現在のタブを複製。
    文字列ならその名前のバッファ、なければファイルやディレクトリを探して開く。
    関数ならその返り値のバッファを開く。個人的には動的に決められるようになっているのが
    とても好み。よき。

*** ~tab-bar-new-button-show~ (~t~)、 ~tab-bar-close-button-show~ (~t~)
    新規タブボタン、タブ削除ボタンを表示するかどうか。~t~ なら表示、 ~nil~ なら
    非表示。 ~tab-bar-close-button-show~ の場合、 さらに
    ~selected~ (カレントタブでのみ表示)と ~non-selected~ (カレントタブ以外で表示)の二つも可能。

*** ~tab-bar-tab-hints~ (~nil~)
    タブに連番を表示するかどうか。

*** ~tab-bar-tab-name-function~ (~tab-bar-tab-name-current~)
    :PROPERTIES:
    :CUSTOM_ID: tab-bar-tab-name-function
    :END:
    名前がないとき、名前をどう決めるか。デフォルトではカレントバッファ名
    を返す ~tab-bar-tab-name-current~ ([[fig:tab-bar-tab-name-current]])となっているが、
    任意の関数に変更可能。
    windowの数を数えて付け加えてくれる ~tab-bar-tab-name-current-with-count~
    ([[fig:tab-bar-tab-name-current-with-count]])、
    長さが ~tab-bar-tab-name-truncated-max~ を超えると省略してくれる
    ~tab-bar-tab-name-truncated~ ([[fig:tab-bar-tab-name-truncated]])、
    表示されている全バッファの名前をカンマで繋げてくれる
    ~tab-bar-tab-name-all~ ([[fig:tab-bar-tab-name-all]])が用意されている。
    自身で作った関数でももちろんOK。

    #+caption: ~tab-bar-tab-name-current~ のとき(デフォルト)
    #+attr_latex: scale=0.75
    #+label: fig:tab-bar-tab-name-current
    [[images:tab-bar-tab-name-current.png]]

    #+caption: ~tab-bar-tab-name-current-with-count~ のとき
    #+attr_latex: scale=0.75
    #+label: fig:tab-bar-tab-name-current-with-count
    [[images:tab-bar-tab-name-current-with-count.png]]

    #+caption: ~tab-bar-tab-name-truncated~ のとき
    #+attr_latex: scale=0.75
    #+label: fig:tab-bar-tab-name-truncated
    [[images:tab-bar-tab-name-truncated.png]]

    #+caption: ~tab-bar-tab-name-all~ のとき
    #+attr_latex: scale=0.75
    #+label: fig:tab-bar-tab-name-all
    [[images:tab-bar-tab-name-all.png]]

*** ~tab-bar-new-tab-to~ (~right~)
    新しいタブをどこに作るか。 ~left~ や ~right~ なら現在のタブの左右に、
    ~leftmost~ や ~rightmost~ なら一番左や一番右に作る。

*** ~tab-bar-close-tab-select~ (~recent~)
    現在のタブを閉じたとき、どのタブに移動するか。
    ~recent~ なら最近利用したタブに、 ~left~ や ~right~ なら元々あったタブの左右の
    タブに移動する。

*** ~tab-bar-close-last-tab-choice~ (~nil~)
    最後の1つのタブを閉じたときにどうするか。
    ~nil~ ならなにもしない。 ~delete-frame~ なら現在のフレームを削除。
    ~tab-bar-mode-disable~ なら ~tab-bar-mode~ をオフにする。
    また、関数を渡すと閉じたときに関数を実行してくれる。

** 改造
   せっかく1フレーム1つの領域を手に入れたので、自由に表示したい。
   日付や時計、場合によってはbranchなんかも、1フレーム1つで十分だろう。

   というわけで、しくみをざっくりと見て、真似してみようではないか。
   と思って見てみると、なんだかおもしろい記述が。

   #+caption: tab-bar-mode.el L197-199
   #+begin_src emacs-lisp :tangle yes
   (global-set-key [tab-bar]
                   `(menu-item ,(purecopy "tab bar") ignore
                               :filter tab-bar-make-keymap))
   #+end_src
   どうやら ~[tab-bar]~ にメニューアイテムを割り当てると画面上部に表示できるらしい。
   おもしろい試みだ。 ~navbar.el~ ではバッファを表示させていたのに対し、
   専用の領域を用意したわけか。(試しに ~[tab-bar2]~ に同じものを割り当ててみたが、
   なにも表示されなかったので、おそらく新しく専用の領域を作ったのだろう。)

   恥ずかしながら ~menu-item~ 形式の ~global-set-key~ は初めて見たので、
   ~define-key~ のヘルプをみてみると、InfoファイルのExtended Menu Itemsの項に
   説明があるらしい。(日本語版は(24.5のものだが)[[https://ayatakesi.github.io/emacs/24.5/elisp_html/Extended-Menu-Items.html][ここ]]にある。ほとんどかわっていないので
   問題ない。)これを読むと、どうやら ~:filter~ に渡された関数 ~tab-bar-make-keymap~ は、
   3番目の ~ignore~ というシンボルを受けとり(~tab-bar~ では使ってないので適当なシンボル
   をおいているっぽい)、キーマップを返すものらしい。本来は ~ignore~ の位置に
   キーマップを直接置くが、動的に生成したいときは ~:filter~ を使う、という感じのようだ。

   ~tab-bar-make-keymap~ は内部的には ~tab-bar-make-keymap-1~ を呼んでいるだけだが、
   この関数は通常我々が使うようなキーマップとは毛色が異なり、
   ~cdr~ の各要素のほとんどは /~(symbol~/ ~menu-item~ /~string function)~/ となっている。
   /~symbol~/ は識別子で、 /~string~/ が表示される文字列だ。クリックすることで
   /~function~/ が呼び出される。もし単に文字を表示したければ、 ~tab-bar~ の
   セパレータの表示に倣って /~function~/ を ~ignore~ にすればよいだろう。

   さあこれで準備は整った。要は ~tab-bar-make-keymap-1~ をハックして、
   さっきの形式で文字列をいれてやればいいのだろう。

   というわけで ~tab-bar-display~ というパッケージを作った。

   [[https://github.com/ROCKTAKEY/tab-bar-display][https://gh-card.dev/repos/ROCKTAKEY/tab-bar-display.svg]]

   使いかたは簡単で、 ~tab-bar-display-before~ と ~tab-bar-display-after~ に
   ~format-mode-line~ 形式で表示したいものを書いて、 ~tab-bar-display-mode~
   を ~tab-bar-mode~ と共にオンにしておけば、タブ一覧の前後にそれが表示される。

   #+caption: ~tab-bar-display-mode~ を用いた例
   #+attr_latex: scale=0.75
   #+label: fig:tab-bar-display-mode
   [[images:tab-bar-display.png]]

** まとめ
   ~tab-bar-mode~ はとても便利というはなしでした。
   かなり便利そうなので ~elcreen~ を捨てて乗り換えようかしら。
* DONE chocolateyのインストールをするとMcAfeeに邪魔される
  CLOSED: [2020-08-23 Sun 21:13]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2020-0536cd60-b6e5-2e44-26db-e9d895d148be
  :EXPORT_HUGO_TAGS: chocolatey McAfee
  :END:
  Haskellのコンパイラのghcをインストールしようとしたら、
  chocolateyが必要と言われた。気になってはいたので、いれてみようと一念発起。

  [[https://chocolatey.org/install][chocolateyのインストールセクション]]にPowershell用のインストールコマンドがあるので、
  (~ExecutionPolicy AllSigned~ したあと)ペーストして実行した。が、謎のエラーが。
  #+BEGIN_SRC text -n
$ Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
発生場所 行:1 文字:1
+ Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.Service ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
このスクリプトには、悪質なコンテンツが含まれているため、ウイルス対策ソフトウェアによりブロックされています。
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : ScriptContainedMaliciousContent
  #+END_SRC
  こいつとともにMcAfeeが「ウイルスいたから殺しといたわ!」と通知してきたので、
  たぶんMcAfeeのせいだろう。ファイアウォールとリアルタイムスキャンを無効にするも、
  変わらず。お手上げかと思ったが、[[https://qiita.com/konta220/items/95b40b4647a737cb51aa#2-chocolatey%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E5%AE%9F%E8%A1%8C][Qiitaの記事]]をみつけた。ここにある画像の、3つ目のスクリプトは
  全文みえているので、一か八かで実行。
  #+BEGIN_SRC shell -n
  iwr https://chocolatey.org/install.ps1 -UseBasic Parsing | iex
  #+END_SRC
  最初のスクリプトとなんの差があったのかはわからないが、無事インストールできた。
  よかった。

* DONE grugru.el ― カーソル下のthingをじゅんぐりに入れ替える
CLOSED: [2021-11-30 Tue 23:59]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2021-eb9f86f0-ee65-1824-4063-ed0d0ba15dbf
  :EXPORT_HUGO_TAGS: Emacs Emacs-Lisp grugru
  :END:
  [[https://qiita.com/advent-calendar/2021/emacs][https://img.shields.io/badge/Emacs%20Advent%20Calendar%202021-22%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]
** 導入
   さてみなさん、突然ですが、コードを書いていて、「あっやっぱり ~true~ じゃなくて ~false~ だった」
   「 ~&&~ じゃなくて ~||~ だった」などということが多々あるのではないでしょうか。そして、往々にして、
   入れ替えることになる組み合わせは決まっているのではないでしょうか。こういうとき、いちいちバックスペースを
   連打して打ち直すのは、思考のノイズになってしまってよくありません。そこで、単一のコマンドを使って、
   あらかじめ登録しておいた一連の ~thing~ をじゅんぐりに出してくれる ~grugru.el~ というパッケージを開発しました。

   [[https://github.com/ROCKTAKEY/grugru][https://gh-card.dev/repos/ROCKTAKEY/grugru.svg]]

   とりあえず使ってみたい人は、 =M-x package-install RET grugru RET= してください
   (インストールできない場合は、[[https://emacs-jp.github.io/packages/package][ここ]]を参照)。
   その後、
   #+begin_src emacs-lisp :tangle yes
     (grugru-default-setup)
     (global-set-key (kbd "C-:") #'grugru)
     (grugru-highlight-mode)
   #+end_src
   を評価するなり =init.el= に貼り付けて再起動するなりしてみましょう。すると、じゅんぐりに変えられる
   =thing= をハイライトしてくれるようになります。そこで ~C-:~ を押下すると、次の =thing= へと置き換えてくれます。

   口で言ってもわかりにくいので、例として、C++の以下のようなソースコードを開いてみましょう。
   #+BEGIN_SRC cpp
     #include <iostream>
     #include <vector>
     #include <array>
     #include <deque>

     class c{
     private:
         float f;
     };

     int main(){
         bool b = false;

         std::vector<int> v(1, 1);

         double d;

         std::cin >> d;

         if (d || b) {
             std::cout << d << "\n";
         } else {
             std::cout << b << "\n";
         }

         return 0;
     }
   #+END_SRC
   ここにある シンボルはほとんどが ~grugru~ 可能です。以下にgifを置いておきます。
   適当なところにカーソルをもっていって、ハイライトされたら ~C-:~ を押してみてください。
   連打してもよいです。実際に使ってみたgifを以下においておきます。
   #+caption: C++におけるgrugruのデモ
    #+attr_latex: scale=0.75
    #+label: fig:c++-grugru-demo
   [[https://raw.githubusercontent.com/ROCKTAKEY/images/35e323db33f4da1545c289f2741782c4ac04968b/c++-mode.gif]]

** 自分で定義する
   ここでは ~grugru-default-setup~ を使ってあらかじめ用意されたものを ~grugru~ していますが、
   自分で定義することも可能です。定義するための関数は主に3つあります。
   - ~(grugru-define-global GETTER STRINGS-OR-GENERATOR)~
   - ~(grugru-define-on-major-mode MAJOR GETTER STRINGS-OR-GENERATOR)~
   - ~(grugru-define-local GETTER STRINGS-OR-GENERATOR)~
   書き方はとても簡単です。 ~GETTER~ の部分には、 ~symbol~ 、 ~word~ 、 ~char~ など、
   どの範囲をひとつの ~thing~ としてみなすかを指定します。
   ~STRINGS-OR-GENERATOR~ には、 ~grugru~ したい一連の文字列のリストを渡します。
   ~grugru-define-global~ はEmacs全体を通じてそれらの文字列が ~grugru~ できるようになり、
   ~grugru-define-on-major-mode~ は ~MAJOR~ で指定したメジャーモード(リストによる複数指定可)全体、
   ~grugru-define-local~ は現在のバッファのみで ~grugru~ できるようになる、という違いがあります。
   書き方の例を示します。
   #+begin_src emacs-lisp :tangle yes
     (grugru-define-global 'word '("aaaa" "bbbb" "cccc"))
     (grugru-define-on-major-mode '(c-mode c++-mode) 'symbol '("unsigned" "signed"))
     (grugru-define-local 'char '("a" "b" "c"))
     #+end_src

   基本的には、 ~GETTER~ には ~symbol~ (Lispにおける識別子的な意味合い)を選んでおけば大丈夫です。
   もし「camelCase」の「camel」の部分だけ、といった ~symbol~ 内の単語を対象にしたい場合は
   ~word~ を、連続する記号類 (~&&~ や ~>>=~ など)を対象にしたい場合は ~non-alphabet~
   を使用します。自前で定義することも可能ですが、高度な内容になるため[[#technical-configuration][高度な内容]]に預けます。

   もし大文字小文字の情報を無視して定義したい場合は、 ~STRINGS-OR-GENERATOR~ に以下のように
   書けばよいです。
   #+begin_src emacs-lisp :tangle yes
     ;; 誤植があったためコードを修正しました
     (grugru-define-global 'word (grugru-metagenerator-keep-case '("aaa" "bbb" "ccc")))
     ;; AAA -> BBB -> CCC のような `grugru' が可能!
   #+end_src
   実は ~STRINGS-OR-GENERATOR~ には ~GENERATOR~ と呼ばれる関数を書くことができますが、
   高度な内容になるため[[#technical-configuration][高度な内容]]に預けます。

   また、 ~grugru-define-global~ と ~grugru-define-on-major-mode~ はいっぺんに定義するためのマクロが
   用意されています。以下の3つは全て等価になります(上2つはLispの文法上等しい)。
   #+begin_src emacs-lisp :tangle yes
     (grugru-define-multiple
      (fundamental-mode
       . ((word . ("aaa" "bbb" "ccc"))
          (symbol . ("xxx" "yyy" "zzz"))
          (word . ("abc" "def" "ghi"))))
       (word . ("aaaa" "bbbb" "cccc"))
       (symbol . ("xxxx" "yyyyy" "zzzzz"))
       (word . ("abcd" "defd" "ghid")))

     (grugru-define-multiple
      (fundamental-mode
        (word "aaa" "bbb" "ccc")
        (symbol "xxx" "yyy" "zzz")
        (word "abc" "def" "ghi"))
       (word "aaaa" "bbbb" "cccc")
       (symbol "xxxx" "yyyyy" "zzzzz")
       (word "abcd" "defd" "ghid"))

     (progn
       (progn
          (grugru-define-on-major-mode 'fundamental-mode 'word '("aaa" "bbb" "ccc"))
          (grugru-define-on-major-mode 'fundamental-mode 'symbol '("xxx" "yyy" "zzz"))
          (grugru-define-on-major-mode 'fundamental-mode 'word '("abc" "def" "ghi")))
        (grugru-define-global 'word '("aaaa" "bbbb" "cccc"))
        (grugru-define-global 'symbol '("xxxx" "yyyyy" "zzzzz"))
        (grugru-define-global 'word '("abcd" "defd" "ghid")))
   #+end_src

   ちなみに、複雑な ~grugru~ にも対応すべく、 ~GETTER~ や ~STRING-OR-GENERATOR~ には関数を
   与えることが可能になっています。詳細はここでは省きますが、
   ~GETTER~ は引数なしでカーソル位置から ~thing~ の始点と終点のコンスセルを返し、
   ~STRING-OR-GENERATOR~ は第一引数として貰った候補が有効なら次の候補(第二引数が ~non-nil~ なら前の候補)
   を返せばよいです。

*** 高度な内容
    :PROPERTIES:
    :CUSTOM_ID: technical-configuration
    :END:
    この項の内容はやや高度です。Emacs Lispをある程度理解している方向けになります。興味のないかたは飛ばしていただいて
    かまいません。

    ~grugru-define-*~ における ~GETTER~ と ~STRINGS-OR-GENERATOR~ は、本質的には関数です。
    ~GETTER~ で指定できる ~symbol~ や ~word~ は ~grugru-getter-alist~ から ~alist-get~ を通じて関数に置き換えられます。
    ~STRINGS-OR-GENERATOR~ で指定できる文字列のリストは、 ~grugru-strings-metagenerator~ に格納された高階関数に通すことで
    関数 ~GENERATOR~ に置き換えられます。以下はそれらを内部で行っている関数です。
    #+begin_src emacs-lisp :tangle yes
      (defun grugru--get-getter-function (getter)
        "Get getter function from GETTER."
        (setq getter (or (cdr (assq getter grugru-getter-alist)) getter))
        (pcase getter
          ((pred functionp)
           getter)
          ((pred integerp)                    ;「local な `grugru' をinteractiveに定義する」を参照
           (apply-partially #'grugru--metagetter-with-integer getter))
          (_ `(lambda () ,getter))))

      (defun grugru--get-generator (strings-or-generator)
        "Return generator from STRINGS-OR-GENERATOR."
        (if (functionp strings-or-generator) strings-or-generator
          (funcall grugru-strings-metagenerator strings-or-generator)))
    #+end_src

**** Getter
    ~GETTER~ は、引数をとらず、2つのポイントをコンスセルにして返す関数です。
    返り値は ~bounds-of-thing-at-point~ と同じで、 ~car~ は現在のバッファにおける開始位置、 ~cdr~ は終了位置のポイントになります。
    ~grugru~ は、この間にある部分を ~GENERATOR~ に渡し、次の候補を得ようと試みます。

    ~GETTER~ の例として、 ~word~ に対応する ~GETTER~ を以下に示しておきます。
    #+begin_src emacs-lisp :tangle yes
      (defun grugru--getter-word ()
        "Get beginning/end of word at point."
        (if (or (eq (point) (point-at-eol))
                (string-match "[-\\[\\]_:;&+^~|#$!?%'()<>=*{}.,/\\\\\n\t]\\| "
                              (buffer-substring (point) (1+ (point)))))
            (save-excursion (cons (subword-left) (subword-right)))
          (save-excursion
            (let ((x (subword-right))
                  (y (subword-left)))
              (cons y x)))))
    #+end_src

**** Generator
    ~GENERATOR~ は、1つの引数と1つの省略可能引数をとり、 文字列 ~next-string~ 、 ~(valid-bounds . next-string)~、 ~nil~ のどれかを返します。
    一つ目の引数は文字列 ~STRING~ で、 ~GENERATOR~ はこの文字列の次の文字列を返します。もし省略可能な第二引数 ~REVERSE~ が
    ~non-nil~ である場合、次の文字列の代わりに *前* の文字列を返します。次の文字列として該当するものがない場合は ~nil~ を
    返します。 ~valid-bounds~ は ~(BEGIN . END)~ のリストです。
    これは ~bounds-of-thing-at-point~ の返り値とほぼ同じ意味合いですが、 ~STRING~ の開始位置を ~0~ としたときの位置になります。
    ~valid-bounds~ を指定するち、指定した範囲のどこにもカーソルがない場合は該当する文字列なし(つまり返り値 ~nil~)として扱ってくれます。
    次の文字列を算出するのにより広い範囲の文字列を必要とするが、事実上のターゲット文字列はもっと狭い、もしくは
    カーソル位置がある位置にない場合は対象にするべきでない、というようなケースで使えます
    (例: 関数の呼び出しに用いられている括弧だけを対象にしたい。/
    関数名を ~grugru~ するときに、一緒に引数の順番も入れ替えたいが、カーソルが引数上にあるときは対象にしたくない。)。

    ~GENERATOR~ の例として、 ~grugru-default.el~ で定義されている ~grugru-default@emacs-lisp+nth!aref~ を以下に示しておきます。
    この ~generator~ は、カーソルが ~nth~ か ~aref~ にある場合に限り、 ~(nth 1 lst)~ と ~(aref lst 1)~ のような組み合わせを
    ~grugru~ します。
    なお、 ~grugru-utils-lisp-exchange-args~ は関数呼び出し形をしたS式として ~read~ できる文字列と
    数学的な意味での置換(permutation)を与えることで、引数部分を置換した文字列を返してくれる関数です。
    #+begin_src emacs-lisp :tangle yes
      (defun grugru-default@emacs-lisp+nth!aref (str &optional _)
        "Return STR exchanged `nth' and `aref' with argument permutation."
        (cond
         ((string-match "^(\\_<\\(nth\\)\\_>" str)
          (cons
           (cons (match-beginning 1) (match-end 1))
           (grugru-utils-lisp-exchange-args
            (replace-match "aref" nil nil str 1)
            '(2 1))))
         ((string-match "^(\\_<\\(aref\\)\\_>" str)
          (cons
           (cons (match-beginning 1) (match-end 1))
           (grugru-utils-lisp-exchange-args
            (replace-match "nth" nil nil str 1)
            '(2 1))))))
    #+end_src

** local な ~grugru~ をinteractiveに定義する
   :PROPERTIES:
   :CUSTOM_ID: interactive-grugru-define
   :END:
   実は、 ~grugru-define-local~ は、interactiveに定義することができます。
   バッファ使い捨ての ~grugru~ をぱっと定義したいときに有用です。実行すると、単に置換したい
   2つの文字列を聞かれます。略語の展開のような意図で使うことを想定しているため、デフォルトの ~GETTER~ は
   「カーソルから1つ目の候補の文字列の長さ分前に戻った部分まで」となっています。
   また、リージョンがアクティブなら中身を2つ目の文字列として自動で入力されます。
   もし ~GETTER~ や置換したい文字列の数を指定したい場合は、前置引数 ~C-u~ を付けて実行してください。

   #+caption: ~grugru-define-local~ をinteractiveに使う
   #+attr_latex: scale=0.75
   #+label: fig:grugru-define-local-interactively
   [[https://raw.githubusercontent.com/ROCKTAKEY/images/698f33489645a6e7b0c29d879771dbb15fa3fcd9/grugru-define-local.gif]]

** 選択肢の中から ~grugru~ を選んで適用する
   さて、たくさんの ~grugru~ を定義すると、同じ ~thing~ に対して複数の ~grugru~ 候補がある場合が出てくる
   かもしれません。その場合、 ~grugru~ コマンドは単に一番優先度の高いものを実行します。優先度は
   「local>major-mode>global」になっていて、同じ優先度の中では「後に定義されるほど強い」というふうに
   なっています。

   しかし、せっかく定義しても使えなければ意味がありません。そこで、 ~grugru-select~ というものが用意
   されています。とても素直な関数なので使ってみればわかると思いますが、
   (あれば)複数の ~grugru~ 候補の中から適用したいものを選択し、さらにどの文字列へと置換するのかを選択する、
   というものです。この関数は、複数の ~grugru~ 候補がある場合だけでなく、 ~grugru~ をたくさん連打しないと
   目的の文字列まで到達できない時に、絞り込みによって一気に到達するのにも有用です。画像では使って
   いませんが、 ~ivy~ などの候補選択ライブラリと一緒に使うとより快適だと思います。
   #+caption: ~grugru-select~ による置換先の選択画面
   #+attr_latex: scale=0.75
   #+label: fig:grugru-select
   [[images:grugru-select.png]]

** ~grugru~ を再定義する
   ~grugru~ を実行して、やっぱりこれは違うな、と思ったとき、その場でサクっと再定義できると便利ですよね。
   設定ファイルにこだわりがない場合は、 ~grugru-edit~ を利用するとよいです。現在のカーソルで有効な
   ~grugru~ を再定義できます。

   この関数で再定義した値のうち、グローバルなものとメジャーモードローカルのものは
   ~grugru-edit-save-file~ に保存されます。 ~init.el~ に以下のような記述をすれば、
   その設定は次回起動時にも読み込まれます。
   #+begin_src emacs-lisp :tangle yes
     (grugru-edit-load)
   #+end_src
   保存されたファイルは単なるEmacs Lispの式ですので、気に入らないことがあれば手で編集しても構いません。

   ただし、 ~grugru-edit~ を使うと設定が分散してしまうので、 ~init.el~ に設定を集約することにこだわりがある人には
   おすすめできません。 ~leaf~ のキーワードにも対応していますし、当然直接定義を書いても問題ないので、
   そういう人は素直に ~init.el~ に書いてください。

   再定義関数は ~grugru-redefine-*~ のような名前になっていて、最後の引数として新しい ~STRING-OR-GENERATOR~
   を与えることで再定義できます。 ~nil~ を与えれば無効にできます。
   ~init.el~ に直接書く場合、自分で定義したものは書き換えれば済むので、
   主にデフォルトの挙動を変えたいときに使うことになりそうです。

** 独立した ~grugru~ を定義する
   ここまで、なるべく負荷を減らすべく、 ~grugru~ という単一のコマンドによって =thing= の置換を
   行うようにしてきました。しかし、時には、もしくは人によっては、「いくつかの =thing= だけを
   置換するようなコマンドを独立して定義したい」ということがあると思います。そういう人のために、
   ~grugru-define-GENERATOR~ というものが用意されています。基本的な引数は ~defun~ に準じます。
   ~body~ 部の文法はメジャーモード指定ができない以外は ~grugru-define-multiple~ と同様です。
   たとえば以下の ~three-state~ は、"water"、"ice"、"vapor"の3つと、"solid"、"liquid"、"gas"の3つ
   のみを順に置換することができ、それ以外はいっさい置換できません。
   #+begin_src emacs-lisp :tangle yes
     (grugru-define-generator three-state ()
      "Docstring. This is optional."
      (symbol . ("water" "ice" "vapor"))
      (symbol . ("solid" "liquid" "gas")))
   #+end_src

** 結論
   ここに書ききれていないことも多々ありますので、詳細は[[https://github.com/ROCKTAKEY/grugru#readme][README.org]]
   を見てね!! 質問などあれば、コメント欄、githubのDiscussionやissue(日本語可能)、メールなどなんでもいいのでぜひ
   ご連絡ください!!

   みなさんも ~grugru~ といっしょに、ストレスのないコーディングを楽しみましょう!!

** お願い
   私があまり知らない言語では、どのような =thing= が置換されうるのかが分からないため、デフォルトが
   あまり充実していないのが現状です。issueでもPRでも、SlackやTwitterのDMでも構いませんし、
   フォーマットの有無や日本語英語も問いませんので、どの言語(どれかひとつの言語で構いません)に
   どのような ~grugru~ できそうなペアがあるか(1つだけでも構いません)、教えていただけると嬉しいです。

   あと、良かったら投げ銭してってね!

* DONE Surface Laptop 1にUbuntuを(LUKSによる暗号化つきで)インストールする
CLOSED: [2022-01-31 Mon 02:50]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-27ba711f-28e9-35b4-5c13-5fb121b8023d
  :EXPORT_HUGO_TAGS: Surface-Laptop-1 Ubuntu LUKS
  :END:
基本的には[[#surface-linux-reference][参考]]にあるサイトに準拠しています。
** 必要なもの
- USBハブ (USB端子が1つしかないため、以下の2つを同時に接続するために必要)
- USBキーボード (途中までSurfaceにもとからついているキーボードは使えません)
- USBメモリ (Ubuntuのブート用)

** ブート用のUbuntuをUSBメモリに用意する
基本[[https://zenn.dev/sprout2000/articles/52caaffa9ad3fa#1.-usb-%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%AE%E4%BD%9C%E6%88%90][ここ]]のとおりにやればよい。あらかじめ作っておいてある人もいそう。ここ以外にもたくさん文献があると思うので
ここでは説明しない。

** UEFIでセキュアブートを無効にする
音量アップボタン(F6)を押しつづけながら、電源を入れる。
もしくは、Windowsを立ち上げて「設定>更新とセキュリティ>PCの起動をカスタマイズする>今すぐ再起動>
トラブルシューティング>詳細オプション>UEFIファームウェアの設定」と行く。UEFIは、BIOSの進化版みたいな
ものらしい。

UEFIに入ったら、「Security>Secure Boot>Change configuration」をクリックして、「Microsoft only」から
「None」に変更する。LUKSで暗号化すればどうせSSDの中身はパスワードなくして読めないので、
セキュアブートはなくても問題ない気がしている(本当か？)。
後でLUKSのパスワードを求められたときには堅牢なパスワードにしておきましょう。

最後に、Boot configurationタブで、USB Storageを一番上にもっていく。これで、Windowsではなく
USBにあるUbuntuが先に立ち上がるようになる。

** Ubuntuを起動する
まず、SurfaceにUbuntuの入ったUSBとキーボードを、USBハブ経由で繋ぐ。
そして、「exit>Restart now」すると、Ubuntuが立ち上がる。

** Ubuntuをインストール
基本は下記のURLに従ってもらえればいいが、暗号化するのに注意がある。
「インストールの種類」のタイミングで、「ディスクを削除してUbuntuをインストール」すると思うが、
ここで「高度な機能」をクリックし、「新しいUbuntu」の「インストールにLVMを使用する」を選択し、
「安全のために新しいUbuntuのインストールを暗号化する」にチェックを入れて欲しい。
これで、bitlockerと同様にディスクが暗号化される。

URLは[[https://linuxfan.info/ubuntu-20-04-install-guide][これ]]。「ストレージ設定」の見出しのところに
その画面がある。この記事では暗号化をしていないので、一切触れられていない。
この後パスワードを入力させられる(パスワードなしでもいけるが、セキュアブートなしだと危うそう)。
そのとき、バックアップキーが表示されるので、パスワードを忘れたときのためにどこかにメモっておく。

** Surface用のカーネルを導入
次に、Surfaceの各種デバイスが使えるよう、専用のカーネルをインストールする。
基本は[[https://github.com/linux-surface/linux-surface/wiki/Installation-and-Setup#debian--ubuntu][ここ]]に買いてある通りでよい。ただし、
#+BEGIN_SRC shell -n
  sudo apt install linux-surface-secureboot-mok
  sudo update-grub
#+END_SRC
に関しては、セキュアブートしないのならば必要ない。
私はこれを実行した上で、UEFIにおいてセキュアブートを「Microsoft and 3rd party CA」としても
セキュアブートできなかったので断念した。余力があればチャレンジしてほしい。

** キーボードをLUKSパスワード入力時にも使えるようにする
このまま再起動すると、起動時にLUKSのパスワードを聞かれる。
しかし、その時点で読み込まれるファイルシステムはSurfaceのキーボードのドライバを含んでいないらしく、
外部キーボードでしか入力できない。これでは使いものにならないので、最初に読まれるモジュールを追加する。

エディタは問わないが、 =/etc/initramfs-tools/modules= を開いて、以下を末尾に追加する。
root権限が必要なので注意。ちなみに、このリストは[[https://github.com/linux-surface/linux-surface/wiki/Disk-Encryption][ここ]]からとってきた。
#+BEGIN_SRC shell -n
  surface_aggregator
  surface_aggregator_registry
  surface_hid_core
  surface_hid
  intel_lpss
  intel_lpss_pci
  8250_dw
#+END_SRC
その後、以下を実行する。こちらも ~sudo~ が必要。
#+BEGIN_SRC shell -n
update-initramfs -u
#+END_SRC

** おわり
あとは再起動すれば、SurfaceのロゴとともにLUKSのパスワードを聞かれるので、Surface備え付けのキーボードで
パスワードを打てることがわかる。

** 参考
:PROPERTIES:
:CUSTOM_ID: surface-linux-reference
:END:
- https://zenn.dev/sprout2000/articles/52caaffa9ad3fa
- https://github.com/linux-surface/linux-surface
* DONE 電子書籍リーダで読みやすくするために、サイズを変えずにPDFの余白をバッサリとる
CLOSED: [2022-02-01 Tue 17:43]
:PROPERTIES:
  :EXPORT_FILE_NAME: 2022-d37970ce-9dcd-6534-422b-1df7983164bc
:EXPORT_HUGO_TAGS: PDF e-book
:END:
** 結論
下記URLにある =pdfcrop.sh= をつかう。 =pdfcrop.sh -m 0 input.pdf output.pdf= 。
https://tex.stackexchange.com/questions/42236/pdfcrop-generates-larger-file

** はじめに
電子書籍リーダで読む場合、LaTeXで吐いたPDFとかだと、あきらかに余白が大きい。
製本するならそれでもよいが、電子書籍リーダで読むなら余白は邪魔なだけだ。
これをばっさりなくしたい。

** pdfcrop
余白をバッサリとってくれるツールとして、 =pdfcrop= というものがある。
TeX系のユーティリティとしてついてくる。しかしこのツールには問題があり、
ページ数の多いものなど、一部のPDFを異常に大きなサイズとしてしまう。
Send-to-kindleだと50MBまでしか送れないし、そもそも電子書籍リーダはたいして容量がないので、
あまりよろしくない。ちなみに私が使ったときはサイズが20倍とかに膨れ上がった。

** 解決
解決法をさがしていたところ、以下のStackExchangeに出会った。

https://tex.stackexchange.com/questions/42236/pdfcrop-generates-larger-file

ここに載っている =pdfcrop.sh= を保存して使うと、みごとに余白を削れた。もちろんサイズは変わっていない。
丁寧に作られていて、helpもあるので詳しくはそれを参照してほしいが、基本的な使いかたは、 ~-m~ で
空白(margin)のサイズを指定し、引数として入力PDFと出力PDFを与える。
余白をまったくなくしたければ、 =pdfcrop.sh -m 0 input.pdf output.pdf= とすればよい。

** おわりに
ま、まだ電子書籍リーダもってないんですけどね。Fire HD 8しかない。おすすめおしえてほしい。
* DONE GNU Guix Systemをインストールし、日本語を表示・入力できるようにするまで
CLOSED: [2022-05-07 Sat 05:20]
:PROPERTIES:
:EXPORT_FILE_NAME: 2022-ea617625-23b7-03b4-5273-69d79d393b85
:EXPORT_HUGO_TAGS: GNU-Guix-System GNU-Guix IME
:END:
** はじめに
GNU Guix System(以下Guix System)とは、GNUの開発するLinuxディストロのひとつで、GNU Guix(以下Guix)という
パッケージマネージャと密結合している。GuixはSchemeで管理できるパッケージマネージャで、
隔離された環境によるビルドやロールバック可能な操作が特徴で、再現性と環境の隔離に重点を置いている。
これをWindowsの入ったx64のPCにインストールする。面倒なので新しいディスクを用意してそちらにインストールした。
Windowsのディスクはそのまま残したので、起動時にF12を連打してブートディスクを選択すればWindowsも起動できる。

** 必要なもの
- インストール先のPC :: 私はWindows 10、Bitlockerで暗号化されたディスクの組み合わせのPCにインストールした。
  注意として、(たぶん)このPCはインターネットに繋がっていなければならない。
- USBメモリかDVDドライブ :: インストールディスクを一時的に作る必要がある。容量は8GBあれば余裕だと思う(たぶん2GBもない)。
- 内蔵SSDかHDD :: 必須ではないが、Windowsと共存させたい場合、ディスクを分けるのが最も楽。元のWindowsを潰してよいなら
  そこに上書きすればよいと思うが、保証はできない。あんまりやらないけど、外付けでも同様にできるとは思う。

** ディスクの準備
私はWindowsユーザーなので、Rufusを使ってUSBにインストールディスクを作成した。LinuxのPCがある場合は
[[https://guix.gnu.org/manual/en/html_node/USB-Stick-and-DVD-Installation.html][公式のドキュメント]]のとおりにやるとよいと思います。

まず、[[https://guix.gnu.org/ja/download/][公式サイト]]からGNU Guix SystemのISOファイルをダウンロードして、適当なUSBメモリやDVDに焼く。

Rufusでディスクイメージを作る際に注意点がある。
ISOモードではなくDDモードで焼いてほしい。そうしないとちゃんとbootできない。
これはRufusのはじめの画面では選択できず、「スタート」を押した後に聞いてくるので、
そのときに「ISOモード(推奨)」ではなく「DDモード」を選択して欲しい。

** ブートディスクの変更
PCのメーカーや購入時期によって違うと思うので詳しい説明は省く。
先程作ったインストールディスクからブートされるよう、BIOSやUEFIの設定を変えておけばよい。
また、インストールディスクを抜いたらGuix Systemをそのまま立ち上がるよう、
2番目のブートディスクをこれからインストールするディスクにしておく。

** GUI(風)インストーラでインストール
あんまり需要はないかもしれないが、言葉だけだとわかりにくいかもしれないので、画像を付けておく。

さて、インストールディスクからのブートが成功すると、以下のような画面が得られる。
Locale languageなので「日本語」を選択。ちなみに日本語を選んでもインストーラは英語のまま。
#+caption: Locale language
#+attr_latex: scale=0.75
#+label: fig:locale-language
[[images:locale-language.png]]

次に、Locale locationで「日本」を選択。
#+caption: Locale location
#+attr_latex: scale=0.75
#+label: fig:locale-location
[[images:locale-location.png]]

ここでインストーラの選択画面が表れる。GUI風のインストーラを使いたいので
「Graphical install using a terminal based interface」を選択。
#+caption: GNU Guix install
#+attr_latex: scale=0.75
#+label: fig:gnu-guix-install
[[images:gnu-guix-install.png]]

タイムゾーンを「Asia」「Tokyo」と選択。
#+caption: Timezoneの大まかな地域選択
#+attr_latex: scale=0.75
#+label: fig:timezone-1
[[images:timezone-1.png]]
#+caption: Timezoneの選択
#+attr_latex: scale=0.75
#+label: fig:timezone-2
[[images:timezone-2.png]]

次にキーボードレイアウトを選択。日本語配列なら「日本語」を選択。
#+caption: (キーボードの)Layout
#+attr_latex: scale=0.75
#+label: fig:layout
[[images:layout.png]]

キーボードレイアウトにもバリエーションがあるので、それを選択。
こだわりがなければ「日本語」にしておけばよい。
#+caption: (キーボードレイアウトの)Variant
#+attr_latex: scale=0.75
#+label: fig:variant
[[images:variant.png]]

PCの名前を入力する。
#+caption: Hostname
#+attr_latex: scale=0.75
#+label: fig:hostname
[[images:hostname.png]]

代替サーバの検索を有効にするか選択。
このオプションをオンにすると、LAN内のサーバからビルド済みバイナリを探して、インストールでそれも利用するようにする。
これをオンにすればダウンロードの速度の向上が期待される。(おそらくハッシュ値を利用して)純正であると確認された
ものだけを使うので、セキュリティリスクはないが、盗聴している人がいる場合はなにをインストールしているか見ることが
できる。
#+caption: Substitute server discovory.
#+attr_latex: scale=0.75
#+label: fig:substitute-server-discovery
[[images:substitute-server-discovery.png]]

rootのパスワードを入力。ある程度強いものにしておきましょう。
#+caption: System administrator password
#+attr_latex: scale=0.75
#+label: fig:system-administrator-password
[[images:system-administrator-password.png]]
#+caption: (System administrator passwordの) Password confirmation required
#+attr_latex: scale=0.75
#+label: fig:password-confirmation-required
[[images:password-confirmation-required.png]]

ユーザの作成。 =TAB= キーで「Add」を選択し、 =Enter= してユーザ情報を入力。「Name」がユーザ名になる。
#+caption: User creation
#+attr_latex: scale=0.75
#+label: fig:user-creation-1
[[images:user-creation-1.png]]

#+caption: User creation(新規追加画面)
#+attr_latex: scale=0.75
#+label: fig:user-creation-2
[[images:user-creation-2.png]]

#+caption: User creation(パスワードの確認)
#+attr_latex: scale=0.75
#+label: fig:user-creation-password-confirm-required
[[images:user-creation-password-confirm-required.png]]

#+caption: User creation(ユーザ追加後)
#+attr_latex: scale=0.75
#+label: fig:user-creation-3
[[images:user-creation-3.png]]

デスクトップ環境を選択。=SPC= でチェックをつけられる。
複数選択可なので、今後使ってみたいものは気軽に入れてしまってもいいかも。
複数選んでもデフォルトは勝手にGNOMEになったので、違うものを入れてしまって戸惑うみたいなことには
ならなそう。私はとりあえずデフォルトの「GNOME」と今後使ってみたい「Emacs EXWM」を追加した。
#+caption: Desktop environment
#+attr_latex: scale=0.75
#+label: fig:desktop-environment
[[images:desktop-environment.png]]

ネットワークサービスを選択。基本はデフォルトのままでよさそう。
SSHで外から入りたい場合はOpenSSHのデーモンを有効にしないといけないかもしれない(よくしらない)。
#+caption: Network service
#+attr_latex: scale=0.75
#+label: fig:network-service
[[images:network-service.png]]

パーティションをどのように切るかの流れを選択。パーティションとは、ざっくり言えばディスクの切り分けのこと(なはず)。
よく知らない場合は、「Guided - using the entire disk」か「Guided using the entire disk with encryption」
を選んでおくとよい。後者を選ぶとディスクが暗号化される。立ち上げる前にパスワードを要求されるようになるが、
ディスクを盗まれたり廃棄したり警察に押収されたりしたときに中身を勝手に見られることを防ぐことができるので、
なるべくこちらを選ぶことをおすすめする。ここでも後者を選択する。
「Manual」にすれば、一つのディスクで複数のOSを取り回せると思うが、試していない。上級者向け。
#+caption: Partitioning method
#+attr_latex: scale=0.75
#+label: fig:partitioning-method
[[images:partitioning-method.png]]

使うディスクを選択。ここで間違ったディスクを選択するとそのディスクの中身は二度と戻りません。慎重に選びましょう。
#+caption: Disk
#+attr_latex: scale=0.75
#+label: fig:disk-2
[[images:disk-2.png]]

パーティションの切り方を選択。といってもhomeディレクトリを別のパーティションとして切るか否かを聞いている。
homeディレクトリを分けることによって、今回のようにOSをインストールする際にhome以下のデータをそのままとっておける。
私はそこまで魅力を感じなかった(それよりもパーティションが分かれることによる管理コストのほうが面倒そう)ので、
「Everything is one partition」を選択。
#+caption: Partition scheme
#+attr_latex: scale=0.75
#+label: fig:partition-scheme
[[images:partition-scheme.png]]

最後の確認。選択したディスクが消えてもよいディスクかしっかり確認して、「OK」を選択。
#+caption: Guided partitioning
#+attr_latex: scale=0.75
#+label: fig:guided-partitioning
[[images:guided-partitioning.png]]

ディスクの暗号化に使うパスワードを入力。これもそこそこの長さにしておこう。
ディスクに対するパスワードなので、ネットワーク経由の攻撃とは違い、総当たりに対してソフトウェア的なブロックは見込めない。
総当たりされても一生解読されないくらいの長さにしましょう。
#+caption: (ディスク暗号化の)Password required
#+attr_latex: scale=0.75
#+label: fig:encrypt-password-required
[[images:encrypt-password-required.png]]
#+caption: (ディスク暗号化の)Password confirmation required
#+attr_latex: scale=0.75
#+label: fig:encrypt-password-confirmation-required
[[images:encrypt-password-confirmation-required.png]]

本当にフォーマットして(パーティション切って)よいか最後の確認。「Continue」を押すと二度と戻れません。
ここで確認できることは多くないですが、よいと思ったら「Continue」を選択。
#+caption: Format disk?
#+attr_latex: scale=0.75
#+label: fig:format-disk
[[images:format-disk.png]]

すると以下の画面になるので、少し待つ。
#+caption: Preparing partitions
#+attr_latex: scale=0.75
#+label: fig:preparing-partitions
[[images:preparing-partitions.png]]

ここで、はじめてSchemeが出てくる。guixはここに書いてあるとおりにシステムを構築してくれる。
最初にLocaleとして日本語を選択したが、日本語フォントはOSに含まれていないので、
このまま進むと豆腐だらけのOSを使うことになる。
これを防ぐため、システムのconfigureを変更する。 =TAB= で「Edit」を選択。
#+caption: Configuration file
#+attr_latex: scale=0.75
#+label: fig:configuration-file-2
[[images:configuration-file-2.png]]

するとnanoというエディタが立ち上がる。
#+caption: nanoによる =/etc/configure.scm= の編集画面
#+attr_latex: scale=0.75
#+label: fig:nano-before-region
[[images:nano-before-region.png]]

そこに、このような節があるはずだ。
#+BEGIN_SRC scheme -n
  (pacakges
   (append
    (list
     ;; このへんはEmacs EXWMをDesktop environmentとして選んだときだけ
     (specification->package "emacs")
     (specification->package "emacs-exwm")
     (specification->package
      "emacs--desktop-environment")
     (specification->package "nss-certs"))
    %base-packages))
#+END_SRC
ここにはグローバルにインストールされるパッケージが羅列されている。
この =specification->package= の列にの日本語フォントのパッケージを追加すればよい。
つまり、以下のように変更する。
#+BEGIN_SRC scheme -n
  (pacakges
   (append
    (list
     ;; このへんはEmacs EXWMをDesktop environmentとして選んだときだけ
     (specification->package "emacs")
     (specification->package "emacs-exwm")
     (specification->package
      "emacs--desktop-environment")
     (specification->package "nss-certs")
     (specification->package "fontconfig")
     (specification->package "font-google-noto"))
    %base-packages))
#+END_SRC
そうしたら、 =C-x= (つまりコントロールを押しながらx)を押し、そのまま =Enter= を押して保存する。
#+caption: nanoによる =/etc/configure.scm= の編集画面(編集後)
#+attr_latex: scale=0.75
#+label: fig:nano-after-region
[[images:nano-after-region.png]]

次の画面が表示されるのでそのまま従って =Enter= を押下。
#+caption: Press enter to contiunue
#+attr_latex: scale=0.75
#+label: fig:press-enter-to-continue
[[images:press-enter-to-continue.png]]

すると、次のようにインストールが始まる。ここでしばらく待機。
なお、shepherdとは一般的なLinuxにおけるsystemdに相当するもので、サービスマネージャである。
guix-daemonはguixを走らせるために重要なデーモンで、guixはこれを通じて操作することで管理者権限なしで
=/gnu/store/= 以下を触ることができる(らしい)。
#+caption: インストール開始画面
#+attr_latex: scale=0.75
#+label: fig:console-1
[[images:console-1.png]]

インストールが終わると、以下のような画面が現れる。指示に従って、 =Enter= を押す。
#+caption: インストールの終わりの画面
#+attr_latex: scale=0.75
#+label: fig:console-3
[[images:console-3.png]]

これでインストールは終了だ。以下のような画面が出てくるので、指示に従い、インストールディスクを
抜いて再起動する。
#+caption: Installation complete
#+attr_latex: scale=0.75
#+label: fig:installation-complete
[[images:installation-complete.png]]

** 起動
再起動すると、GRUBが立ち上がる。GRUBはBoot loaderで、OSの立ち上げを担う。
私はもともとメインで使っていたディスクをBitlockerで暗号化していたため、
マスターブートキーを入力させられている。おそらくそうでない人はここでなにも聞かれないのではなかろうか。
#+caption: マスターブートキーの入力
#+attr_latex: scale=0.75
#+label: fig:nano-before-region
[[images:nano-before-region.png]]

その後、以下のようなGRUBのグラフィカルな画面が現れる。ほっておけば先に進むし、 =Enter= を押してもよい。
#+caption: GRUBのOS選択画面
#+attr_latex: scale=0.75
#+label: fig:guix-select
[[images:guix-select.png]]

すると、Guix Systemをインストールしたディスクの暗号化のパスワードを聞かれるので、入力。
#+caption: ディスク暗号化のパスワードを入力
#+attr_latex: scale=0.75
#+label: fig:decrypt.png
[[images:decrypt.png]]

これで、Guix Systemが立ち上がる。日本語を表示できることを確認。
#+caption: Guix Systemのログイン画面
#+attr_latex: scale=0.75
#+label: fig:login
[[images:login.png]]

あとはGNOMEのUIなので、普通にログインできるだろう。

** 日本語を表示したい
今、日本語を表示できることを確認した。
このままGuix Systemに一切のカスタマイズを加えるつもりがないのならば、この章は飛ばしても構わない。
しかし、おそらくGuix Systemを使う人は、ほとんど全員カスタマイズしたくなる性分の人だろう。
特にGuixは自由ソフトウェアを思想としており、プロプライエタリなドライバはデフォルトでは利用できない。
後述する手順を踏めば利用可能だが、それはここで言うカスタマイズに相当することに留意して欲しい。
また、ひとつ後の章では =guix= コマンドによるパッケージのインストールも扱うので、
もしエディタにEmacsを使いたいという場合は、この章を次の章の後に行うとよい。

実は今日本語が表示できているのが奇跡な状態である。
詳細はわかっていないが、インストール時特有のプロセスによって日本語が表示できている。
カスタマイズしたくなり、 =guix system reconfigure /etc/config.scm= したあかつきには、
もれなく文字が豆腐になった無惨なGuix System(というかGNOME)を見ることになる。
これを解決するため、 =/var/lib/gdm/.config/fontconfig/fonts.conf= を作成し、以下のように書く。
場所的にルート権限が必要なので注意。
特にこだわりがなければ =sudo nano /var/lib/gdm/.config/fontconfig/fonts.conf=
#+BEGIN_SRC xml -n
  <?xml version='1.0'?>
  <!DOCTYPE fontconfig SYSTEM 'fonts.dtd'>
  <fontconfig>
    <dir>/run/current-system/profile/share/fonts/</dir>
  </fontconfig>
#+END_SRC

gdmとはGNOME Display Managerのことであり、内部的なユーザとして扱われている。
しかしこいつはグローバルにインストールされたフォントの場所を知らないため、これを教えてあげようというわけだ。
その後、フォントのキャッシュを更新するために以下のコマンドを実行する。
#+BEGIN_SRC bash -n
  fc-cache -fv
#+END_SRC

これで =guix system reconfigure /etc/config.scm= しても日本語が表示できるようになった。
ちなみに、 =/etc/config.scm= ファイル(厳密には、別に場所はここである必要はないし、名前も自由)に作ってもらうことも
可能らしい。[[https://git.sr.ht/~taiju/taix/tree/e396904863e26f04c87c2a4ebd76b1b34fbd7ae7/item/guix-config/system-config.scm#L59][Taijuさんの設定ファイル]]にあるように、 =services= に以下を追加すればよい。
#+BEGIN_SRC scheme -n
  (extra-special-file "/var/lib/gdm/.config/fontconfig/fonts.conf"
                      (plain-file "gdm-fonts.conf"
                                  "<?xml version='1.0'?>
  <!DOCTYPE fontconfig SYSTEM 'fonts.dtd'>
  <fontconfig>
    <dir>/run/current-system/profile/share/fonts/</dir>
  </fontconfig>
  "))
#+END_SRC

** パッケージのインストールのしかた
まずはじめに、
#+BEGIN_SRC bash -n
  guix pull
#+END_SRC
を走らせる必要がある。このコマンドはチャンネルから情報を取ってきて、各パッケージをアップデートしてくれる。
チャンネルとは、ざっくり言えばパッケージの定義の集合である。
厳密に言えば、Guile(Schemeの処理系のひとつ)のモジュールと呼ばれる単位で公開されているので、もっと柔軟でなんでもできる。
=guix pull= 自体がアップデートなしても実行に体感何分かかかること、guix自身がそこそこ頻繁にアップデートされること、
アップデートが入ると体感10分くらいかかることに留意してほしい。要は、 =guix pull= はそこそこ遅い。

インストール基本的には以下のようなものを実行すればよい。これでEmacsをインストールできる。
#+BEGIN_SRC bash -n
  guix install emacs
  #+END_SRC
また、アンインストールは以下のコマンド。
#+BEGIN_SRC bash -n
  guix remove emacs
#+END_SRC
ちなみに =guix insall= は =guix package -i= のエイリアスで、
パッケージに関する操作はすべて =guix package= に集約されている。たとえば、
#+BEGIN_SRC bash -n
  guix package --roll-back
  #+END_SRC
とすれば、前の世代に戻れる。
私もあまり詳しくないが、ざっくり言えば、インストールやアンインストールをするたびに世代が進む(たぶん)。

インストールされたパッケージをリストするには
#+BEGIN_SRC bash -n
  guix package -I
#+END_SRC
で、インストールできるパッケージをリストするには
#+BEGIN_SRC bash -n
  guix package -A
#+END_SRC
また、正規表現にマッチするパッケージを検索するには
#+BEGIN_SRC bash -n
  guix search regexp
#+END_SRC
とする。

** 日本語IMEを入れる
私はSKK使いだが、残念ながら未だGuixのIMEにSKKを使う方法を知らない。
とりあえず最低限日本語を入力するため、 ibusとibus-anthyをインストールする。
#+BEGIN_SRC bash -n
  guix install ibus ibus-anthy
#+END_SRC
そして、[[https://issues.guix.gnu.org/35610#7-lineno19][issue]]にあるように、 =~/.bash_profile= に以下を追記する。なければ新規作成。
#+BEGIN_SRC bash -n
  export GUIX_GTK2_IM_MODULE_FILE="$HOME/.guix-profile/lib/gtk-2.0/2.10.0/immodules-gtk2.cache"
  export GUIX_GTK3_IM_MODULE_FILE="$HOME/.guix-profile/lib/gtk-3.0/3.0.0/immodules-gtk3.cache"
  export IBUS_COMPONENT_PATH="$HOME/.guix-profile/share/ibus/component"
  export GTK_IM_MODULE=ibus
  export XMODIFIERS=@im=ibus
  export QT_IM_MODULE=ibus
#+END_SRC
もし =~/.cache/ibus= が存在するなら、全て削除し、再起動する。

再起動したあと、画面右上のボタンから設定に移行し、左のメニューからキーボードを選択する。
すると、以下のようになるはずだ。
#+caption: IME変更前の状態
#+attr_latex: scale=0.75
#+label: fig:ime-before
[[images:ime-before.png]]

画面に写ったプラスボタンをクリックし、「日本語」を選択すると、
「日本語(Anthy)」が出ているので、それを選択する。
#+caption: 言語の選択
#+attr_latex: scale=0.75
#+label: fig:ime-select-1
[[images:ime-select-1.png]]
#+caption: IMEの選択
#+attr_latex: scale=0.75
#+label: fig:ime-select-2
[[images:ime-select-2.png]]

すると、以下のようになる。
#+caption: IME変更後の状態
#+attr_latex: scale=0.75
#+label: fig:ime-after
[[images:ime-after.png]]

「Japanese」や「English(US)」は不要なので、右のスリードットを押して得られるメニューで削除を選択。
#+caption: 不要なIMEの削除
#+attr_latex: scale=0.75
#+label: fig:ime-delete
[[images:ime-delete.png]]

これで無事日本語が入力できるはずだ。

** 不自由なソフトウェア
不自由なソフトウェア(プロプライエタリなドライバやファームウェア含む)を使いたい場合、
デフォルトのguixチャンネルは利用できない。
そのために、非公式のチャンネルとして[[https://gitlab.com/nonguix/nonguix][nonguix]]というものが存在する。
この章ではこのチャンネルを導入する。不自由なソフトウェアを利用したくない場合は、この章は飛ばしてよい。

READMEにあるように、 =~/.config/guix/channels.scm= に以下を書く。
このファイルはユーザが利用するguixのチャンネルを定義する。自分でGitレポジトリを作ってチャンネルとすることも可能だ。
#+BEGIN_SRC scheme -n
  (cons* (channel
          (name 'nonguix)
          (url "https://gitlab.com/nonguix/nonguix")
          ;; Enable signature verification:
          (introduction
           (make-channel-introduction
            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
            (openpgp-fingerprint
             "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
         %default-channels)
#+END_SRC
これを書いたら、 =guix pull= しておこう。

次に、Linuxカーネル及び不自由なファームウェア、ドライバを導入する。
これもREADMEにあるように、 =/etc/config.scm= を以下のように変更する。
編集には管理者権限が必要であることに注意。
#+BEGIN_SRC scheme -n
  ;; (use-modules (gnu)) の行を以下に変更
  (use-modules (gnu)
               (nongnu packages linux)
               (nongnu system linux-initrd))

  (operating-system
   ;; 以下の行を追記
   (kernel linux)
    (initrd microcode-initrd)
    (firmware (list linux-firmware))
    ...
    )
#+END_SRC

最後に、以下のコマンドを実行。こちらにも管理者権限が必要なので =sudo= がついている。
=guix system reconfigure= は、Guix Systemそのものの設定を読み直し、適宜ビルドするコマンドである。
そこそこに時間がかかるため、気長に待とう。
#+BEGIN_SRC bash -n
  sudo guix system reconfigure /etc/config.scm
#+END_SRC

** おわりに
Guix SystemやGuixの日本語情報はあまりなく、大変かもしれないが、是非使ってみて欲しい。
日本語の記事を書いてくれるとさらに嬉しい。

** 謝辞など
Guix Systemを導入し、さらにこの記事を書くにあたり、 [[https://libre.taiju.info/][Taiju]]さんにとてもお世話になりました。
この場を借りて感謝の意を表したいと思います。本当にありがとうございました。

また、Taijuさんと共に[[https://join.slack.com/t/guix-jp/shared_invite/zt-17aoza5yo-KAVDj5aPPwsJ9X7e4lJteg][Guix-jp]]というGNU Guix及びGNU Guix Systemの日本語コミュニティを立ち上げました。
すこしでもGuixに興味を持った方は、是非遊びにきてください!!
* DONE Emacsのパッケージを作る際の手引き
CLOSED: [2022-12-19 Mon 04:32]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-df7edb45-d0ce-7cd4-5c6b-1a3efa8b4b4c
  :EXPORT_HUGO_TAGS: Emacs Emacs-Lisp
  :END:
[[https://qiita.com/advent-calendar/2022/emacs][https://img.shields.io/badge/Emacs%20Advent%20Calendar%202022-12%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]
** 序文
Emacsは完全に素のまま使うと若干不便なところがたくさんあるので、
Emacs Lispを利用してカスタマイズすることがあるかと思います。
単にEmacsの変数を触る程度であれば問題はありませんが、自分の欲しい機能を設定ファイル =init.el= に直接書いていると、
保守の観点であまりよろしくありませんし、人に使ってもらうのも大変になってしまいます。

一方、ある程度大きくなった機能をパッケージへと切り出しておけば、履歴も設定ファイルとは別に管理できますし、
人に使ってもらうのも簡単です。この記事では、Emacs Lispのパッケージの雛形を詳細に解説し、
みなさんがパッケージを作る一助にしたいと思います。

なお、この記事は雛形の展開結果を元に話を進めていますが、この記事はこの雛形を利用して欲しいがために作ったというより、
パッケージを作り方を伝授するために作ったものです。なので、別にこのテンプレートを利用しなくてもよいですし、
しなくてもよいように説明します。

** 今回利用するサービス及びソフトウェア
*** 外部サービス
この記事では、開発を便利に進めるためにいくつかの外部サービスを利用します。
それらの外部サービスを利用したくない場合はテンプレートをそのまま利用はできませんが、
それぞれのファイルの役割は逐一解説し、各自で個々の要素を利用できるよう努めます。

以下に、利用する外部サービスを列挙します。
- [[https://github.com/][GitHub]]
  - GitHubによるgitホスティング
  - [[https://docs.github.com/ja/actions][GitHub Actions]]
    - GitHub上でテストなどを行うために計算リソースを使わせてくれるサービス
    - テスト及びlintを行うために利用
  - 利用する場合、[[https://github.com/join][ここ]]からアカウントを作っておいてください。
- [[https://about.codecov.io/][CodeCov]]
  - テストカバレッジを取得してまとめてくれるサービス
  - 利用する場合は[[https://docs.codecov.com/docs][ここ]]に示されるようにアカウントを作り、GitHubと連携しておいてください。publicレポジトリなら =CODECOV_TOKEN= は不要です。
- [[https://shields.io/][shields.io]]
  - バッジを生成してくれるサービス
  - READMEにおいてテストの状態やライセンス、タグなどを表示するのに使用
  - アカウントは必要ありません
  - いいサービスだと思ったら是非[[https://opencollective.com/shields][寄付]]して差し上げましょう

*** ローカルで利用するソフトウェア
以下に、ローカルで利用するソフトウェアを示します。
- [[https://www.gnu.org/software/emacs/][Emacs]]
- [[https://github.com/conao3/keg.el][keg.el]]
  - Emacs Lispのプロジェクトの依存を管理するパッケージマネージャ及び便利ツール
  - グローバル環境(つまりユーザーのEmacs環境)を汚さずにパッケージの依存をインストールできる(=npm= みたいなもの)
  - 類似ツールとして[[https://github.com/cask/cask][Cask]]、[[https://github.com/doublep/eldev][eldev]]、[[https://github.com/emacs-eask/cli][eask]]などがある
  - インストールは簡単で =git clone https://github.com/conao3/keg.el.git ~/.keg= を実行して =~/.keg= ディレクトリに =keg.el= をインストールした後、
    =PATH=$HOME/.keg/bin:$PATH= としてパスを通すだけです。
- [[https://github.com/cookiecutter/cookiecutter][Cookiecutter]]
  - テンプレートを展開するソフトウェア
  - [[https://docs.github.com/ja/repositories/creating-and-managing-repositories/creating-a-template-repository][GitHubのテンプレート機能]]はレポジトリの内容をまるまるコピーすることしかできないため、
    テンプレートの展開時に対話的に入力を入れられるこのソフトウェアを選んだ

** Cookiecutterを利用してテンプレートを展開してみる
まずはテンプレートを展開し、それにより生成されたコードを解説していく方向でいこうと思います。
もしテンプレートを利用したくない場合、この章は飛ばして構いません。
私の作成した、今回使うテンプレートは[[https://github.com/ROCKTAKEY/cookiecutter-emacs-lisp][ここ]]にあります。
=emacs-lisp-package-sample= という名前のGithubレポジトリで、
=sample= というパッケージ及びプロジェクトの名前のパッケージを想定して作ってみましょう。
#+BEGIN_SRC shell
  cookiecutter https://github.com/ROCKTAKEY/cookiecutter-emacs-lisp
#+END_SRC
すると、以下のようなプロンプトが表れます。
#+begin_example
  project_name [project-name]:
#+end_example
ここではプロジェクト名を聞いているので、 =sample= と入力してEnterキーを押します。
この値はEmacs Lispパッケージの =feature= 名及び各シンボルの接頭辞として利用されます。

するとさらに以下のようなプロンプトが得られます。
#+begin_example
  project_name [project-name]: sample
  github_repository_name [sample]:
#+end_example
このように、対話的にプロジェクトを作成することができます。
ここではGitHubのレポジトリ名を聞いているので =emacs-lisp-package-sample= と入力します。
プロジェクトへのURLの生成及びディレクトリ名に用います。

#+begin_example
  project_short_description [Short description of your project]: This is sample for package
#+end_example
ここではプロジェクトの概要を端的に入力します。
README及びメインのEmacs Lispファイルの説明文などに用いられます。

#+begin_example
  full_name [Your Name]: Your Name
#+end_example
ここではあなたの本名を入力します。
著作権表記に用います。必ずしも本名でなければならないわけではありません。

#+begin_example
  email [email@example.com]: youremail@example.com
#+end_example
ここにはemailアドレスを入力します。あなたの連絡先を示すのに用います。

#+begin_example
  github_username [github]: username
#+end_example
ここにはあなたのGitHubのユーザー名を入力します。
この値もレポジトリのURLを生成するのに利用します。

#+begin_example
  year [2022]:
#+end_example
ここには現在の年を入力します。著作権の始まりを表すのに利用します。
空欄にすれば自動で現在の年が入力されます。

#+begin_example
  Select keyword:
  1 - abbrev
  2 - bib
  3 - c
  4 - calendar
  5 - comm
  6 - convenience
  7 - data
  8 - docs
  9 - emulations
  10 - extensions
  11 - faces
  12 - files
  13 - frames
  14 - games
  15 - hardware
  16 - help
  17 - hypermedia
  18 - i18n
  19 - internal
  20 - languages
  21 - lisp
  22 - local
  23 - maint
  24 - mail
  25 - matching
  26 - mouse
  27 - multimedia
  28 - news
  29 - outlines
  30 - processes
  31 - terminals
  32 - tex
  33 - tools
  34 - unix
  35 - vc
  36 - wp
  Choose from 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36 [1]: 33
#+end_example
とても長いプロンプトが出てきました。
ここには、このプロジェクトがどのキーワードに対応するかどうかを入力します。
=<f1> p= (=finder-by-keyword=)をEmacsで実行するとそれぞれのキーワードが何を表すかを見ることができます。
以下に内容を転記しておきます。
このキーワードはメインのEmacs Lispファイルのヘッダ及び =defgroup= に必要なのですが、
キーワードはかなり偏ったものが多いため、 =tools= を選ばざるを得ないことが多いです。
今回も =tools= を表す =33= を入力します。
#+begin_example
  abbrev        abbreviation handling, typing shortcuts, and macros
  bib           bibliography processors
  c             C and related programming languages
  calendar      calendar and time management tools
  comm          communications, networking, and remote file access
  convenience   convenience features for faster editing
  data          editing data (non-text) files
  docs          Emacs documentation facilities
  emulations    emulations of other editors
  extensions    Emacs Lisp language extensions
  faces         fonts and colors for text
  files         file editing and manipulation
  frames        Emacs frames and window systems
  games         games, jokes and amusements
  hardware      interfacing with system hardware
  help          Emacs help systems
  hypermedia    links between text or other media types
  i18n          internationalization and character-set support
  internal      code for Emacs internals, build process, defaults
  languages     specialized modes for editing programming languages
  lisp          Lisp support, including Emacs Lisp
  local         code local to your site
  maint         Emacs development tools and aids
  mail          email reading and posting
  matching      searching, matching, and sorting
  mouse         mouse support
  multimedia    images and sound
  news          USENET news reading and posting
  outlines      hierarchical outlining and note taking
  processes     processes, subshells, and compilation
  terminals     text terminals (ttys)
  tex           the TeX document formatter
  tools         programming tools
  unix          UNIX feature interfaces and emulators
  vc            version control
  wp            word processing
#+end_example

これによってディレクトリ =emacs-lisp-package-sample= がカレントディレクトリに生成されます。
生成されたディレクトリは、以下のような構造になっているはずです。
#+begin_example
  .
  ├── .dir-locals.el
  ├── .github
  │   └── workflows
  │       └── test.yml
  ├── .gitignore
  ├── Keg
  ├── LICENSE
  ├── README.org
  ├── codecov.yml
  ├── sample.el
  └── test
      └── sample-test.el
#+end_example
各ファイルの役割を説明していきます。

** パッケージを構成する各ファイルの役割
前章を飛ばした方のために、もう一度ディレクトリ構造を示します。
=sample= というプロジェクト名であることに留意してください。
#+begin_example
  .
  ├── .dir-locals.el
  ├── .github
  │   └── workflows
  │       └── test.yml
  ├── .gitignore
  ├── Keg
  ├── LICENSE
  ├── README.org
  ├── codecov.yml
  ├── sample.el
  └── test
      └── sample-test.el
#+end_example
これらの各ファイルについて解説していきます。
先にEmacs Lisp以外のファイル(テスト周りを除く)を説明し、
その後Emacs Lispファイルを説明、最後にテスト周りのファイルについて触れます。

*** README.org
耳にたこができるほどよく見る言説かもしれませんが、
READMEは、このパッケージを調べて辿りついた人が最初に見るファイルです。
端的にパッケージの概要を示しつつ、ドキュメントを付けておきましょう。
テンプレートでは以下のような内容になっています。org-modeで書いています。
#+BEGIN_SRC org
  [[https://github.com/username/sample][https://img.shields.io/github/tag/username/sample.svg?style=flat-square]]
  [[file:LICENSE][https://img.shields.io/github/license/username/sample.svg?style=flat-square]]
  [[https://codecov.io/gh/username/sample?branch=master][https://img.shields.io/codecov/c/github/username/sample.svg?style=flat-square]]
  [[https://github.com/username/sample/actions][https://img.shields.io/github/workflow/status/username/sample/test/master.svg?style=flat-square]]
  ,* sample: This is sample for package

  ,* How to Use?
  ,* License
    This package is licensed by GPLv3. See [[file:LICENSE][LICENSE]].
#+END_SRC
最初の4行はShields.ioによって生成されたバッジです。
もしGitLabなどの他のサービスでホスティングする場合はURLを適宜変更する必要があります。

始めのヘッドラインにはパッケージの説明と概要を入れています。
ここに詳細な説明を適宜書いてください。
動画やGIFを撮ってここに置いておくとどんなパッケージなのかがグッとわかりやすくなります。
その際は[[https://github.com/tarsius/keycast][keycast]]パッケージを利用してモードラインに現在のキー入力を表示させるとよいです。

その他最低限のヘッドラインを用意しています。ライセンスについては後述します。

*** LICENSE
ファイルの内容は長いので省略します。
ここには[[https://www.gnu.org/licenses/gpl-3.0.html][GNU General Public License version 3.0]](GPLv3)のライセンス文がそのまま書かれています。
Emacs自体がGPLv3の下で公開されていることもあり、Emacs LispのパッケージもGPLv3の下で公開されることが多いです。
そのため、ここではGPLv3を採用しています。もちろん他のライセンスでも構いませんが、
今後パッケージアーカイブに入れてもらう可能性を考えると、GPLv3に互換のあるライセンスであることが望ましいです。
また、GPLv3以外を利用する場合は後述のようにメインのEmacs Lispファイルのヘッダのライセンスに関する文言も変更する必要があります。

*** .gitignore
#+begin_example
  flycheck_*
  ,*.elc
  .keg/
#+end_example
.gitignoreファイルです。Git管理のレポジトリにおいて、Gitの履歴に含めないようなファイル群を指定しています。
[[https://www.flycheck.org/en/latest/][Flycheck]]を利用する場合にたまに見え隠れするファイル =flycheck_*= 、バイトコンパイル後のファイル =*.elc= 、
及び後述するプロジェクトの依存するパッケージ群のあるディレクトリ =.keg/= (=npm= で言う =node_modules= 相当)
の3種を指定しています。

*** sample.el
#+BEGIN_SRC emacs-lisp
  ;;; sample.el --- This is sample for package  -*- lexical-binding: t; -*-

  ;; Copyright (C) 2022  yourname

  ;; Author: yourname <youremail@example.com>
  ;; Keywords: tools

  ;; Version: 0.0.0
  ;; Package-Requires: ((emacs "24.1"))
  ;; URL: https://github.com/username/emacs-lisp-package-sample

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;; This is sample for package

  ;;; Code:

  (defgroup sample ()
    "This is sample for package"
    :group 'tools
    :prefix "sample-"
    :link '(url-link "https://github.com/username/emacs-lisp-package-sample"))

  (provide 'sample)
  ;;; sample.el ends here

#+END_SRC
ここには様々な情報が書かれています。分解して説明します。

#+begin_src emacs-lisp
  ;;; sample.el --- This is sample for package  -*- lexical-binding: t; -*-
#+end_src
1行目はファイル名、概要、 =-*- lexical-binding: t; -*-= の3つの内容が書いてあります。
この3つはいずれも(ほぼ)必須の定型フォーマットになります。
特に概要の部分は、パッケージアーカイブに登録した場合にパッケージの概要として表示されます。
なお、概要にピリオドは不要です。

=-*- lexical-binding: t; -*-= は見慣れない記述かもしれません。
これは[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html][ファイルローカルな変数を指定する記法]]です。
ここでは =lexical-binding= を =t= に指定しています。
これによりレキシカルバインディングを有効にします。
レキシカルバインディングは日本語では字句的束縛で、
端的に言えば「関数の実行に関数が **定義された時の** 環境を利用する」ことを意味します。
一方Emacs Lispではダイナミックバインディングを採用します。
これは日本語では動的束縛で、端的には「関数の実行に関数が **実行される時の** 環境を利用する」ことを意味します。
通常のプログラミング言語の大半は字句的束縛を採用していることもあり、
特に問題がない場合はEmacs Lispでも字句的束縛を採用します。
定義していない変数にアクセスしようとするなどの行儀の悪いコードを書かなければ、あまり意識する必要はありません。

#+BEGIN_SRC emacs-lisp
  ;; Copyright (C) 2022  yourname

  ;; Author: yourname <youremail@example.com>
  ;; Keywords: tools

  ;; Version: 0.0.0
  ;; Package-Requires: ((emacs "24.1"))
  ;; URL: https://github.com/username/emacs-lisp-package-sample
#+END_SRC
これはパッケージにおけるヘッダコメントで、メタデータが書かれています。
コピーライト表記及び筆者の情報として =yourname= と =youremal@example.com= が利用されています。
また、キーワードについてもここで指定しています(選択肢については =<f1> p= =finder-by-keyword= を参照)。

さらにバージョンを指定しています。バージョン表記は通常SemVer表記(0.0.0表記)を用います。
バージョンをきちんと管理していないパッケージも多いですが、
他のパッケージから依存されることなどを考えると、きちんとこまめにバージョンを切ったほうがよいです。

ホームページとしてURLも指定します。ここではGitHubを前提とし、
=username= というユーザー名、 =emacs-lisp-package-sample= というレポジトリ名でURLを生成していますが、
GitLabでもよいですし、独自に用意した任意のホームページで構いません。

特筆すべきは =Package-Requires= です。ここには依存するパッケージを書いていきます。
Emacsそのものもパッケージと同様に扱い、最低どのバージョンを求めるかをここに書きます。
デフォルトでは =24.1= からの指定となりますが、正直かなり古いので =25.1= や =26.1= を指定してもいいと思います。
特に =24.4= や =24.5= あたりでかなり劇的に変化を遂げたので、そのあたりになってしまうこともあります。
後述するlinterによって最低のEmacsバージョンを自動で教えてくれるので、そのままでもよいかもしれません。

他のパッケージに依存する場合、バージョンは該当パッケージのヘッダコメント =Version= にあるバージョンを指定します。
たとえば[[https://github.com/magnars/dash.el][dash.el]]の =2.19.1= と[[https://github.com/magnars/s.el][s.el]]の =1.13.1= を依存として利用したいなら、以下のように書きます。
#+BEGIN_SRC emacs-lisp
  ;; Package-Requires: ((emacs "24.1") (dash "2.19.1") (s "1.13.1"))
#+END_SRC
このように、 =Package-Requires= に =(package-name "version")= のリストを渡すことで依存を記述します。
ここに記述された依存は、このパッケージのインストール時や後述する =keg install= を初めとした開発ツールによって
自動でインストールされます。

#+BEGIN_SRC emacs-lisp
  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+END_SRC
ここにはライセンスの説明が書いてあります。
GPLv3が前提となっています。
ここは定型文なので、ライセンスとしてGPLv3を利用するのであればこのままで構いません。

#+BEGIN_SRC emacs-lisp
  ;;; Commentary:

  ;; This is sample for package
#+END_SRC
ここにはパッケージの詳細な説明を記述します。
テンプレートでは概要をそのまま書いていますが、ここには **詳細な説明** を書いてください。
パッケージアーカイブに登録した場合、パッケージの詳細として表示されます。
READMEから生成するのもよいかもしれません。

#+BEGIN_SRC emacs-lisp
  ;;; Code:
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (provide 'sample)
  ;;; sample.el ends here
#+END_SRC
上記のように、実際のコードの部分は =;;; Code:= コメントの行で始まり、
featureを提供する =(provide 'sample)= 節と =;;; sample.el ends here= コメントで終わる必要があります。
コメント自体は動作に必須というわけではないですが、コーディング規約的なところで決まっており、
後に説明するlinterで警告されます。

#+BEGIN_SRC emacs-lisp
  (defgroup sample ()
    "This is sample for package"
    :group 'tools
    :prefix "sample-"
    :link '(url-link "https://github.com/username/emacs-lisp-package-sample"))
#+END_SRC
実際のコードとしてテンプレートから展開されるのはこの部分のみです。
パッケージを書く際はこの下に書いていくことになります。

ここで定義しているのは =group= です。
これは主にカスタマイズ変数を体系的に管理するために利用するもので、第一引数にグループ名を指定します。
通常はパッケージ名をそのままグループ名としますが、
所属するアイテム数が大きくなってしまうのであればカテゴリ毎に複数グループに分けても構いません。

第二引数は通常空リストです。グループに所属するシンボルとその編集方法をリストによって組にしたものを
リストとして連ねたものを渡すことができますが、変数定義のときにグループを指定するのが一般的です。

第三引数はドキュメントです。1行目はピリオドで終わり、各行は最大でも80桁であることが望ましいです。
ここではテンプレートに入れた文字列の都合上ピリオドなしになっています。
これ以降の引数はキーワード引数となっていて、 =:keyword1 value1 :keyword2 value2 ...=
のような値を渡します。

=:group= として親となるグループを指定します。
さきほどヘッダのコメントに書いたキーワードはグループとして必ず存在するため、ここに設定されていますが、
他に適切な親グループが存在する場合(例えば派生パッケージでは派生元のパッケージのグループ)はそれを設定してください。

=:prefix= には、このグループにおける各シンボルの接頭辞を指定します。
Emacs Lispには名前空間が実質的に存在しないため、変数や関数がどのパッケージに所属するかを接頭辞で表します。
通常はパッケージ名にハイフンを付けたものにします。

=:link= にはURLなどのリンクを渡します。 =url-link= 以外にもinfoファイルへのリンクである =info-link= や
ファイルへのリンクである =file-link= を渡すことができます。
複数渡したい場合は何度もこの引数を指定すればよいです。

**** コードの書き方について
ここではコードの書き方の作法について述べます。
Emacs Lispは書けるけど、パッケージの作法がよくわからない、という人向けの節です。

***** グローバル変数定義
グローバル変数を定義する方法は2種類あります。
その二つを説明したあと、命名について述べます。
****** =defvar=
ひとつは =defvar= を使った定義方法です。
以下のように使います。
#+BEGIN_SRC emacs-lisp
  (defvar variable-name initial-value
    "document.")
#+END_SRC
これによって初期値 =initial-value= の =variable-name= というグローバル変数が定義されます。
="document."= の部分には変数の説明が入ります。
1行目はピリオドで終わる必要があり、各行は最大でも80桁であることが望ましいです。
ドキュメントは省略可能ではありますが、可能な限り付けてください。
後に述べるlinterで警告されます。
これは通常のグローバル変数で、ユーザーに直接変更されることを想定しません。

****** =defcustom=
もうひとつは =defcustom= を使った定義方法です。
以下のように使います。
#+BEGIN_SRC emacs-lisp
  (defcustom customizable-variable-name initial-value
    "document."
    :group 'sample
    :version "0.0.0"
    :type 'number
    ;; :safe t
    ;; :risky t
    ;; :local t
    )
#+END_SRC
最初の3つの引数は =defvar= と同様で、 =initial-value= を初期値とする
=customizable-variable-name= という名前のカスタマイズ変数
(=defcustom= で定義したグローバル変数はカスタマイズ変数と呼ぶ)を定義し、
="document."= で説明します。
カスタマイズ変数はユーザーに変更されることを想定した変数です。
そのため、ユーザーのための情報をキーワード引数として渡すことができるようになっています。
代表的な例は以下になります。
******* =:group=
所属するグループを与えます。通常はそのパッケージで定義したグループを与えます。
******* =version=
その変数が初めて導入されたバージョンを与えます。
******* =type=
型を示します。これは *静的型付けによる型エラーを検知するためのものではなく* 、
ユーザーがGUIを用いて値を変更するときの入力支援や、ユーザーによる変更に対する型エラーを通達するためのものです。
かなり複雑なので詳細は[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Customization-Types.html][マニュアル]]を参照して欲しいのですが、よく使うものだけ挙げておきます。
- =string= :: 文字列
- =number= :: 数値
- =integer= :: 整数
- =float= :: 浮動小数点数
- =regexp= :: 正規表現
- =file= :: ファイル
- =directory= :: ディレクトリ
- =boolean= :: 真偽値 (=nil= か =t=)
- =function= :: 関数
- =variable= :: 変数
- =(choice type1 type2 type3 ...)= :: =type1= =type2= =type3= ... のいずれかの型。複雑な型を作るのに便利。
- =(const value)= :: =value= という値のみを取ることができる定数型
- =(repeat type)= :: =type= 型の要素がいくつか連なっているリスト
- =(alist :key-type type1 :value-type type2)= :: =type1= 型のキーと =type2= 型の値で構成される連想リスト
- =(plist :key-type type1 :value-type type2)= :: =type1= 型のキーと =type2= 型の値で構成されるプロパティリスト
******* =:safe= 、 =:risky=
これは、その変数が第三者に自由に変更されても安全かどうかを規定します。
Emacsにはファイルローカルな変数の値をあらかじめファイルの冒頭や末尾、 =.dir-locals.el= に書いておくことで、
ファイルを開いたときに自動でその値を代入してくれる機能があります。
通常インデントにタブを用いるか、インデントの幅をどうするかなどをEmacsに教えるのに利用しますが、
悪用されれば任意のコードを実行されてしまうかもしれません。かといって全ての変数についてユーザーに尋ねていては鬱陶しいです。
そこで、その変数が他人に書き換えられたときに危険な作用を及ぼし得るか否かをあらかじめ教えておくアプローチを
Emacsはとっています。
知らない人に勝手に代入されて絶対に安全ならば =:safe= を =t= に、危険なことが分かっている場合は =:risky= を =t= にします。
なにも与えなければ、デフォルトの挙動となります。
デフォルトにどう扱うかはユーザーのポリシーによりますが、通常はユーザーに一度だけ尋ね、承認されたら以降 =:safe= とします。
=:risky= な変数は常にユーザーに尋ねます。 =:safe= な変数の場合はユーザーに尋ねず代入します。
******* =:local=
そのカスタマイズ変数を既定でバッファローカルな変数とします。
グローバル変数なのにローカルであることに不自然さを感じるかもしれませんが、
あくまでもグローバル変数がバッファによって異なるようにできる、というだけです。
グローバルスコープがバッファによって変化すると捉えてもよいかもしれません。

****** 命名法
Emacs Lispには名前空間が実質的に存在せず、従って公開変数や非公開変数のような機構も存在しません。
つまり、あらゆる変数や関数はユーザーがアクセスできます。
これは熟練のEmacs Lisperがアドバイスなどを介してカスタマイズをしやすいという利点もありますが、
ライトユーザーにとってみれば利用されることを想定した変数や関数を簡単に見分けられないのは困ります。
そこで、Emacs Lispでは名前によってユーザー用かどうかを区別します。
具体的には、先程グループの定義で示した接頭辞の末尾のハイフンが1つならばユーザー用、
二つなら内部実装用です。例を示します。
- ユーザー用 :: =sample-command= 、 =sample-command-for-you=
- 内部実装用 :: =sample--function= 、 =sample--function-for-me=
先程述べたように、 =defcustom= はユーザーに変更されることを想定しているので、常にハイフンは1つです。
一方 =defvar= についてはどちらもあり得ます。ユーザーに変更されることは想定していなくても、
ユーザーに値を参照されることを想定している可能性があるためです。
このような命名は、ユーザーに「この関数や変数は互換性を保つ対象である」と明示する役割があると言えます。

***** 関数定義
関数定義に書くことはあまりないです。 =defun= を利用し、以下のように書きます。
#+BEGIN_SRC emacs-lisp
  (defun sample-function-name (arg1 arg2 &optional arg3)
    "Add ARG1, ARG2 and ARG3."
    (interactive)
    (+ (or arg1 1) (or arg2 1) (or arg3 1)))
#+END_SRC
第一引数に関数名を渡します。命名については[[*命名法][命名法の節]]を参照してください。

第二引数には引数のリストを渡します。
=&optional= 以降の引数は渡さなくてもよく、渡されなければ =nil= を束縛します。
=&rest= の後の1つの引数は残りの全ての引数をリストとして束縛します。

第三引数には関数の説明(ドキュメント)を書きます。
今まで通り各行は80桁以下、1行目はピリオドで終わるのが望ましいです。
注意点として、このドキュメントには全ての引数の説明が出てくる必要があります。
引数は全てを大文字にして記述します。
これを行わなかった場合、後述するlinterに警告を受けます。

残り部分は実引数が仮引数に束縛された状態で実行されます。
一番上の =(interactive)= だけは特別で、これを付けることにより、
ユーザーが =M-x= (=execute-command=)やキー割り当てによって直接(Emacs Lispとしての明示的な評価を介さずに)
実行できるようになります。
このようにユーザーが直接呼び出すことのできる関数を *コマンド* と呼びます。
=interactive= について説明するとそれだけで一記事になってしまうので、ここでは割愛します。
詳しくは[[https://ayatakesi.github.io/lispref/28.2/elisp-ja.html#Defining-Commands][マニュアル(翻訳)]]をご覧ください。

***** マクロ定義
この節は難しいので、飛ばしても構いません。
大半のパッケージはマクロを定義していないので、パッケージを作るにあたってそこまで支障はないです。

マクロ定義は基本的に関数定義とほとんど同様です。
実行時の違いは1つだけで、関数は実引数を評価したものを仮引数に束縛して評価するのに対し、
マクロは実引数を評価せずに仮引数に束縛して評価し、返り値をさらに評価します。
すなわち、引数として与えられるのは値ではなく値になる前の式そのもので、それを使って新しい式を作成し、
その式が最初からそこに書いてあったかのように評価します。
定義は =defmacro= を用いて以下のように行います。
#+BEGIN_SRC emacs-lisp
  (defmacro sample-macro-name (arg1 arg2)
    "Add ARG1 and ARG2."
    `(+ ,arg1 ,arg2))
#+END_SRC
各引数の意味は関数のときと全く同じです。

パッケージにおいてマクロを定義する際には一つ注意があります。
それは、ローカル変数のリークです。
ローカル変数を使うような式へと変形する場合、普通に書くと以下のようになります。
#+BEGIN_SRC emacs-lisp
  (defmacro sample-macro-name-8 (arg1 arg2)
    "ARG1とARG2と8をかけ算する"
    `(let ((a 8))
       (* ,arg1 ,arg2 a)))
#+END_SRC
一見なんら問題ないように見えますが、これには問題があります。
実際の展開先を見るとわかります。
#+BEGIN_SRC emacs-lisp
  ;; 展開前
  (sample-macro-name-8 1 2)

  ;; 展開後
  (let ((a 8))
    (* 1 2 a))
#+END_SRC
これを見てわかる通り、展開先に =a= が残ってしまいます。
このような単純な場合ではこの =a= のなにが問題かわからないかもしれません。
次の例を見てみましょう。
#+BEGIN_SRC emacs-lisp
  ;; 展開前
  (let ((a 1))
    (sample-macro-name-8 a 2))

  ;; 展開後
  (let ((a 1))
    (let ((a 8))
      (* a 2 a)))
#+END_SRC
これでおかしさがわかるでしょうか。
展開前を見るかぎり、この式は =8= と =a=1= と =2= をかけ算して =16= になりそうです。
しかし実際の展開結果を見ると、マクロの展開によって新たに出てきた =let= 文によって =a=
の値が上書きされてしまいます。結果返り値は =168= となります。

このような事故を防ぐための方法があります。
それは、「絶対に衝突しない名前(シンボル)」を利用することです。
たとえば =a= という名前の衝突しないシンボルは =(make-symbol "a")= で生成できます。
「 =a= という名前なのだから衝突してるじゃん」とみなさん考えると思います。
実はEmacs Lispには名前空間が1つだけあり、普通に書いたシンボル(例えば =a=)は
その名前空間に登録されたものになります。 =(make-symbol "a")= で生成されたシンボルは
名前こそ =a= ですが、どこの名前空間にも登録されていないシンボルになります。
つまりこのシンボルは衝突のしようがありません。

このようなシンボルは同じ =(make-symbol "a")= で複数回生成しても毎回異なるシンボルを返すので、
適当な変数に束縛してからそれぞれの場所(=let= 節の変数定義や変数の使用場所)に割り振ってあげます。
#+BEGIN_SRC emacs-lisp
  (defmacro sample-macro-name-8 (arg1 arg2)
    "ARG1とARG2と8をかけ算する"
    (let ((a (make-symbol "a")))
     `(let ((,a 8))
       (* ,arg1 ,arg2 ,a))))
#+END_SRC
外側の =(let ((a ...)))= において =a= というシンボルを利用していますが、
これは展開時に残らないので問題ありません。関数内で変数を利用するのと同様です。
=a= という変数に衝突しないシンボルを束縛し、利用する場所で =,a= とすることで
そこにそのシンボルを書いたかのような効果を発揮します(なお、これは =`= の影響下だからできることです)。
これによって、変数を一切リークさせずにマクロ定義行うことができました。

*** test/sample-test.el
このファイルにはテストを書き入れます。
パッケージ開発を行うにあたって、テストは重要です。
テストをきちんと書いておけば、既存の機能が壊れてないことを担保しながら、
安全に新しい機能を追加していくことができます。
#+BEGIN_SRC emacs-lisp
  ;;; sample-test.el --- Test for sample

  ;; Copyright (C) 2022  yourname

  ;; Author: yourname <youremail@example.com>

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;; Test for sample

  ;;; Code:

  (require 'ert)

  (require 'undercover)
  (undercover "*.el"
              (:report-format 'codecov)
              (:report-file "coverage-final.json")
              (:send-report nil))

  (require 'sample)




  (provide 'sample-test)
  ;;; sample-test.el ends here
#+END_SRC
始まりと終わりの部分はメインのファイルとほぼ同じです。
単なるテストファイルなので、ヘッダではバージョンなどのパッケージそのものの情報は省略され、
筆者など最低限の情報だけが書かれています。

#+BEGIN_SRC emacs-lisp
    (require 'ert)
#+END_SRC
=ert= はテストを定義・実行するための標準パッケージです。
ドキュメントは[[https://www.gnu.org/software/emacs/manual/html_node/ert/][ここ]]にあります。
テストの定義は =ert-deftest= を利用して以下のように書きます。
#+BEGIN_SRC emacs-lisp
  (ert-deftest sample-test-name ()
    "docuent."
    ...)
#+END_SRC
基本的には関数定義と同様です。
ドキュンメント ="documents."= は任意で、テストにドキュンメントを付けている人はあまり見たことがありません。
本当は付けたほうがよいかもしれないですが、何をテストしているのか名前や内容から読み取れず、
ドキュンメントがないと理解できないテストとなっている場合はテストが複雑すぎるかもしれません。
また、テストの名前 =sample-test-name= は関数の名前空間とは独立ですが、
テストを管理する単一の名前空間に存在することに留意し、関数や変数と同様にパッケージ名の接頭辞 =sample-= を
付けてください。なにも思いつかなければテスト対象の関数名をそのまま利用することもできます。
なお、引数 =()= は =ert-deftest= を関数っぽく見せるためだけに存在しているダミー引数で常に空リストです。

=...= の部分にテストの内容を書きます。ここには任意の式を書くことができます。
テストを実際に行う式は以下の4種類があります。
- =should= :: =(should 式)= のように用い、 =式= が非 =nil= な値を返せばテストは成功、そうでなければ失敗します。
- =should-not= :: =(should-not 式)= のように用い、 =式= が =nil= を返せばテストは成功、そうでなければ失敗します。
- =should-error= :: =(should-error 式)= のように用い、 =式= が実行時にエラーを吐けば成功、そうでなければ失敗します。
- 式 :: そのまま式を書くと、エラーを吐かなければ成功、エラーを吐けば失敗します。

たとえば、前に出てきた関数 =sample-macro-name-8= に引数 =1= と =2= を与えると =16= を返し、
=2= と =5= を与えると =80= を返すことをテストするには以下のように書きます。
#+BEGIN_SRC emacs-lisp
  (ert-deftest sample-macro-name-8 ()
    (should (eq (sample-macro-name-8 1 2) 16))
    (should (eq (sample-macro-name-8 2 5) 80)))
#+END_SRC
ただし、マクロの変数リークはこのようなテストでは検知できないので、依然として気をつける必要があります。

テストを今動かしているEmacs上で実行するためには、 =ert= コマンドを使います。
=M-x ert= とすると、どのテストを実行するか聞かれます。 =t= を渡せば現在定義されている全てのテストを実行し、
テストの名前を渡せばそれを実行します。
たとえば =sample-macro-name-8= とテスト自体を評価した状態で =ert= を渡し、 =sample-macro-name-8= と入力すると、
以下のような =*ert*= バッファが得られるはずです。
#+begin_example
  Selector: sample-macro-name-8
  Passed:  1
  Failed:  0
  Skipped: 0
  Total:   1/1

  Started at:   2022-12-16 10:38:54+0900
  Finished.
  Finished at:  2022-12-16 10:38:54+0900

  .
#+end_example
上段にはテスト結果のまとめが書いてあります。
中段には実行のログが書いてあります。
下段には =.= と書いてあります。特にこの下段にはテストの一覧が1テスト1文字で書かれています。
=.= は成功、 =F= は失敗を表します。
今回は1つしかテストを実行していないので1文字ですが、複数のテストを同時に行えば =...= や =..F= のように
複数の文字が横に連なります。

**** カバレッジ計測
テンプレートには以下の記述があります。
#+BEGIN_SRC emacs-lisp
  (require 'undercover)
  (undercover "*.el"
              (:report-format 'codecov)
              (:report-file "coverage-final.json")
              (:send-report nil))
#+END_SRC
[[https://github.com/undercover-el/undercover.el][undercover.el]]は、テストにおけるカバレッジ(コード全体の行のうちどれくらいの割合がテストされているか)を計測してくれるパッケージです。
=undercover= マクロでカバレッジの出力フォーマットやファイル名を指定しています。
今回はCodecovというサービスにカバレッジを送信するので、 ='codecov= をフォーマットとして指定しています。
Codecovへのカバレッジレポートの送信は後述するGitHub Actionsで行うので、 =:send-report= には =nil= を指定します。
その他のオプションの詳細は[[https://github.com/undercover-el/undercover.el][undercover.elのREADME]]をご覧ください。

=undercover= パッケージは、 =undercover= 節よりも後に =require= したものを対象にカバレッジ計測を行うこと、
及びバイトコンパイル後の =.elc= ファイルではカバレッジ計測できないこと(行の情報が消失している)を留意してください。
後述する =keg run test-all=  ではバイトコンパイル前後の両方でテストを行いますが、カバレッジを計測できるのはバイトコンパイル前のみです。

**** テストにおける注意点
***** 環境を汚さない
テストを行う際は、環境を汚さないよう配慮しましょう。
これは地球の環境問題への配慮ではなく、あなたのEmacsの実行環境のことを指しています。
それには「あなたの作っているパッケージ自体」も含みます。
テストにおいて、あなたの作ったパッケージのグローバル変数や、
他のパッケージのグローバル変数を直接変更するのは控えましょう。

=let= を利用することで一時的にグローバル変数を別の値に束縛しておけます。
これを用いると、一時的にグローバル変数をローカル変数のように扱えます。
つまり、スコープを抜けると元の値に戻ること、 =let= の内側での該当変数の変更は一切グローバルに波及しないことを保証します。
ただし、Emacs Lispにおけるリストは参照渡しなので、あるリストの途中を変更したときに、
同じリストの参照を保持している変数の値は実質的に変更されます。

この束縛は =let= 環境の内側のすべての関数に波及します。つまり、 =let= 内側で呼びだした関数が該当変数を変更した場合も、
=let= で定義したローカル変数のほうしか変更できず、グローバルな値は変更されません。
これはまさにダイナミックバインディング(動的束縛)の効果になります。
実はEmacsでは、グローバル変数として存在する変数と全く同じ変数を =let= で束縛すると、自動で動的束縛にします。
これにより、 =lexical-binding: t= とした場合でも今回のようなグローバル変数のスコープ内変更を行えるようになっています。

他にも =with-temp-buffer= や =skip-unless= など、環境を汚さないための手法がいくつかありますが、
そこまで頻度はあまり高くないので、ここでは解説しません。
[[https://www.gnu.org/software/emacs/manual/html_node/ert/Tests-and-Their-Environment.html][公式のマニュアル]]をご覧ください。

*****  マクロ定義における注意
マクロをテストする場合、マクロはテスト定義の時点で展開されてしまうため、
マクロを定義しなおしたらテストも定義しなおさねばなりません。
また、場合によっては、マクロ展開を行った式の返り値のテストだけでなく、
=macroexpand-1= などの展開結果を =equal= で比較するなど、マクロ展開そのもののテストを行うこともあります。

*** Keg
このファイルでは[[https://github.com/conao3/keg.el][keg.el]]というツールのプロジェクト毎の設定が書かれています。
この節では =keg.el= に限らず、Emacsプロジェクトにおいて導入しておくと便利なCLIツールについて書いています。

ここでは一旦例として =keg.el= を用いますが、他も大抵の仕組みは同じだと思います。
他には[[https://github.com/cask/cask][cask]]が有名です。
#+BEGIN_SRC emacs-lisp
  (source gnu nongnu melpa)

  (package (sample
            (recipe . (:fetcher github :repo "ROCKTAKEY/sample-emacs-lisp"))))

  (dev-dependency undercover)

  (script
   (test
    (let ((test-files (mapcar (lambda (file) (file-relative-name file "."))
                              (directory-files "test" t "\\.el$"))))
      (keg-shell
       `("keg" "emacs" "--batch" "-Q" "-L" "."
         ,@(mapcar (apply-partially #'concat "--load=") test-files)
         "-f" "ert-run-tests-batch-and-exit"))))
   (test-all
    (keg-shell "keg clean-elc"
               "keg run test"
               "keg build"
               "keg run test"
               "keg clean-elc")))
#+END_SRC
=(source gnu nongnu melpa)= ではソースとなるパッケージのアーカイブを指定しています。
メインのEmacs Lispファイルのヘッダに書いた依存を、このソースから落としてきます。
それぞれ[[https://elpa.gnu.org/][GNU ELPA]]、[[https://elpa.nongnu.org/][NonGNU ELPA]]、[[https://melpa.org/#/][MELPA]]から落とすことを指定しています。
これらは有名どころのパッケージアーカイブです。

=package= 節ではレシピ等の情報を指定しています。
=keg.el= は複数パッケージに対応しており、 =(sample ...)= によってパッケージ =sample= についての設定を行うようになっています。
=...= の部分では =alist= によって情報を指定します。
たとえば =(recipe . ...)= でレシピの情報を指定しています。
レシピはツールによって対応しているものとしていないものがあります。
レシピとは、パッケージをビルドする際の情報をリストにまとめたものです。
このあたりは若干方言がありますが、基本文法は[[https://github.com/melpa/melpa#recipe-format][MELPAの説明]]がわかりやすく、よく用いられています。
=plist= のうち、代表的なものを以下に示します。
- =:fetcher= :: ソースコードをどこから取ってくるかです。今回はGitHubでホストしているので =github= としています。
  他にも =gitlab= や単に =git= のようなものも指定できます。
- =:repo= :: レポジトリの名前です。 =:fetcher= で =gitlab= や =github= を指定した場合にのみ用います。
  =git= の場合は かわりに =:url= でフルのURLを指定してください。
- =:files= :: パッケージに含めるファイルの正規表現のリスト。
  通常は指定しなくてもよしなにしてくれますが、複数パッケージを含む場合は明示的にファイル名を指定します。

=dev-dependency= は、開発においてのみ必要な依存です。
ここでは前述のカバレッジ計測ツールである =undercover= を指定しています。

=(script ...)= では、 =keg run= コマンドで実行するEmacs Lispの式が書けるようになっています。
ツールにより似たような機能があるかどうか、書けるのがEmacs Lispかシェルスクリプトかのような違いはあると思います。
ここでは =test= と =test-all= の二つのコマンドを定義しています。それぞれ =keg run test= と =keg run test-all= で実行できます。
- =test= :: こちらでは、まずは =test/= 以下にあるテストファイルを全て列挙し、それを =--load= と結合して =keg emacs --batch= に渡しています。
  =--load= にファイルを渡すことで、Emacs Lispファイルがロードされます。
  また、 =-L .= によってパッケージ自体を読み込んでいます。 =-L= は =--load== とほとんど同じで、後ろに渡されたファイルをロードします。
  同時に =-f ert-run-tests-batch-and-exit= を渡し、定義されたテストを実行しています。 =-f= は後ろに渡された関数を実行します。

  なお、 =keg emacs= は単にEmacsを実行するものですが、環境変数 =EMACSLOADPATH= を通じてEmacsに =load-path= を伝えます。
  この変数を渡さないと、Emacsは依存をどこにインストールしたのかを知ることができません。
  どのツールにもこの機能は実装されているかと思います。

  =keg-shell= については後述します。

- =test-all= :: こちらでは、 =keg-shell= という1つの関数のみを呼び出しています。
  この関数は与えられた文字列をシェルコマンドとして順に実行していきます。
  文字列の代わりにリストを与えることもできます。その場合、各要素(文字列)をエスケープした上で結合し、シェルコマンドとして実行します。

  ここでは3種類、5つの文字列を与えています。 =keg clean-elc= はバイトコンパイル後のファイルの削除、
  =keg run test= は先ほど定義した =test= スクリプトの実行、 =keg build= はバイトコンパイルを行います。

**** CLIツールによるテストの実行
テストの章ではテストを実行中のEmacsで実行しましたが、使用中の環境は我々の設定が読み込まれていたり、
逆に開発中のパッケージを評価し忘れていたりと、不確実性がそこそこにあります。
そこで、コマンドラインツールを利用してテストを実行していきましょう。
今回利用しているのは =keg.el= でした。先ほど =script= で定義した =test= を使ってテストを走らせましょう。
#+BEGIN_SRC shell
  keg run test
#+END_SRC
はじめには =keg install= と同等の処理が入ります。これは依存のインストールを行います。
必要であれば先に実行しておくとよいです。
なお、そこでいくつかの警告が出力されますが、それは依存先によるものなので、無視してよいです。
もし気になるのであれば、依存先にコントリビュートしに行きましょう。

次に、 =keg run test= の処理が入ります。ここではテストを行います。以下の部分がメインです。
#+begin_example
  Exec command: keg emacs --batch -Q -L . --load\=test/sample-test.el -f ert-run-tests-batch-and-exit
  Exec command: emacs --batch -Q -L . --load\=test/sample-test.el -f ert-run-tests-batch-and-exit
  Running 1 tests (2022-12-18 04:04:28+0900, selector ‘t’)
     passed  1/1  sample-macro-name-8 (0.000074 sec)

  Ran 1 tests, 1 results as expected, 0 unexpected (2022-12-18 04:04:28+0900, 0.000188 sec)
#+end_example
=*ert*= バッファとそうかわらないので、あまり説明することはないです。テストが失敗した場合は以下のように表示されます。
#+begin_example
  Exec command: keg emacs --batch -Q -L . --load\=test/sample-test.el -f ert-run-tests-batch-and-exit
  Exec command: emacs --batch -Q -L . --load\=test/sample-test.el -f ert-run-tests-batch-and-exit
  Running 1 tests (2022-12-18 04:08:19+0900, selector ‘t’)
  Test sample-macro-name-8 backtrace:
    ert-fail(((should (eq (sample-macro-name-8 1 2) 13)) :form (eq 16 13
    (if (unwind-protect (setq value-2 (apply fn-0 args-1)) (setq form-de
    (let (form-description-4) (if (unwind-protect (setq value-2 (apply f
    (let ((value-2 'ert-form-evaluation-aborted-3)) (let (form-descripti
    (let* ((fn-0 #'eq) (args-1 (condition-case err (let ((signal-hook-fu
    (let ((lexical-binding nil)) (let* ((fn-0 #'eq) (args-1 (condition-c
    (lambda nil (let ((lexical-binding nil)) (let* ((fn-0 #'eq) (args-1
    ert--run-test-internal(#s(ert--test-execution-info :test #s(ert-test
    ert-run-test(#s(ert-test :name sample-macro-name-8 :documentation ni
    ert-run-or-rerun-test(#s(ert--stats :selector t :tests [#s(ert-test
    ert-run-tests(t #f(compiled-function (event-type &rest event-args) #
    ert-run-tests-batch(nil)
    ert-run-tests-batch-and-exit()
    command-line-1(("-L" "." "--load=test/sample-test.el" "-f" "ert-run-
    command-line()
    normal-top-level()
  Test sample-macro-name-8 condition:
      (ert-test-failed
       ((should
         (eq
      (sample-macro-name-8 1 2)
      13))
        :form
        (eq 16 13)
        :value nil))
     FAILED  1/1  sample-macro-name-8 (0.000108 sec)

  Ran 1 tests, 0 results as expected, 1 unexpected (2022-12-18 04:08:19+0900, 0.095499 sec)

  1 unexpected results:
     FAILED  sample-macro-name-8

  Script "test" exit abnormally with status code 1
#+end_example
まずは長いバックトレースが表示されます。バックトレースはEmacsがS式を評価し、エラーを起こすまでの軌跡です。
バックトレースは名前の通り、下から上に向かって時間が進むことに注意してください。

その後、テストの条件がどう失敗したのかを示してあります。
その部分を抜粋します。
#+begin_example
  Test sample-macro-name-8 condition:
      (ert-test-failed
       ((should
         (eq
      (sample-macro-name-8 1 2)
      13))
        :form
        (eq 16 13)
        :value nil))
     FAILED  1/1  sample-macro-name-8 (0.000108 sec)
#+end_example
見方は割とそのままで、 =:form= が実行された式、 =:value= が返された値です。
式の比較を =equal= で行った場合は、 =:explanation= として追加で情報が与えられます
(=eq= はプリミティブの比較及び参照の比較しか行わないが、 =equal= はリストの要素を掘って比較する)。
リストの長さが違うとか、リストのどこの要素が異なる、というような情報が得られます。

なお、 =keg run test= は単にテストを実行するだけですが、 =keg run test-all= はバイトコンパイルする前とした後の両方でテストを行います。
使い方はほとんど同じです。 CIなどでは特に理由がなければ =keg run test-all= を使うとよいです。

*** .github/workflows/test.yml
このファイルでは、GitHub Actionsによるテストなどの実行をするための流れを記述しています。
GitHub Actionsにおいて1つの環境で実行されるフローをジョブと言い、それをいくつか集めた実行単位をワークフローと呼びます。
1つのワークフローは必ず同じ操作で誘発され、同時に実行されます。
#+begin_src yaml
  name: test

  on: [push, pull_request]
#+end_src
=name= でこのワークフローの名前を指定します。
=on= では、どのような操作がこのワークフローの実行を誘発するかを指定します。
=push= はコミットのプッシュを行ったとき、 =pull_request= プルリクエストを行ったときにこのワークフローを実行することを表します。

#+begin_src yaml
  jobs:
    test:
      ...
    lint:
      ...
#+end_src
=jobs= には各ジョブの内容を指定します。
1つ下にキーとして名前を書きます。ここでは =test= と =lint= の2つをジョブとして指定します。

#+begin_src yaml
    test:
      runs-on: ${{ matrix.os }}
      continue-on-error:
        ${{ contains(fromJson('["snapshot"]'), matrix.emacs_version) }}
      strategy:
        fail-fast: false
        matrix:
          os:
            - ubuntu-latest

          emacs_version:
            - '24.1'
            - '24.2'
            - '24.3'
            - '24.4'
            - '24.5'
            - '25.1'
            - '25.2'
            - '25.3'
            - '26.1'
            - '26.2'
            - '26.3'
            - '27.1'
            - '27.2'
            - '28.1'
            - '28.2'
            - 'snapshot'
#+end_src
先に =strategy.matrix= について説明します。
=strategy.matrix.xxx= にリストを渡すと、 その数だけジョブが生成されます。
それぞれのジョブでは =matrix.xxx= にリストの各要素の値が束縛されるため、その値を利用することで様々な条件でジョブを実行することができます。
また、 =matrix.xxx= と =matrix.yyy= のように複数設定した場合、全ての組み合わせのジョブが生成されます。
これが =matrix= と言われている所以です。

=${{...}}= はGitHub Actions特有の文法で、関数の実行や変数からの値の取り出しに用います。


**** test
ここで =test:= の先頭まで戻ります。
=runs-on= では、そのジョブを実行するOSを指定します。Ubuntuだけでなく、macOSやWindowsも利用可能です。
ここでは後からOSを追加できるよう、 =${{ matrix.os }}= として =matrix.os= に =ubuntu-latest= を指定しています。
もしmacOSでもテストしたいのであれば、以下のように =macos-latest= を追加してください。
ただし、Ubuntuに比べてかなり遅く、CIを終えるのにかなり時間がかかるようになります。
#+begin_src yaml :hl_lines 9
    jobs:
      test:
        runs-on: ${{ matrix.os }}
        # ...
        strategy:
          matrix:
            os:
              - ubuntu-latest
              - macos-latest
#+end_src

=continue-on-error= を =true= にすると、そのジョブが失敗しても成功したかのように扱ってくれます。
#+begin_src yaml :hl_lines 4-5
  jobs:
    test:
      # ...
      continue-on-error:
        ${{ contains(fromJson('["snapshot]'), matrix.emacs_version) }}
#+end_src
ここでは ~${{ contains(fromJson('[snapshot"]'), matrix.emacs_version) }}~ という複雑な条件を与えていますが、
簡単に言えば =matrix.emacs_version= が =snapshot= の場合だけ失敗を許容します。
現状 =snapshot= のみなので単に ~${{ matrix.emacs_version == "snapshot" }}~ でも構いませんが、
たまに無視したいバージョンを追加したい場合があるので、手軽に追加できるようこのような書きかたになっています。

=strategy.fail-fast= に =true= を指定することで、ジョブが1つ失敗しても他のジョブを最後まで実行します。
デフォルトでは =true= となっていて、1つのジョブが失敗すると残りのジョブは自動で中断されてしまいます。
これにはリソースを節約するメリットがある一方、
全ての環境の組み合わせでの結果の成否を得ることができないため、環境要因の切り分けがしにくくて不便です。
そのため、ここで =false= に指定します。
#+begin_src yaml :hl_lines 4
  jobs:
    test:
      strategy:
        fail-fast: false
#+end_src

ここでは =matrix.emacs_version= の設定をしています。
もしサポートするEmacsバージョンを上げる場合は、ここも適宜削ってください。
#+begin_src yaml :hl_lines 5-21
  jobs:
    test:
      strategy:
        # ...
        emacs_version:
          - '24.1'
          - '24.2'
          - '24.3'
          - '24.4'
          - '24.5'
          - '25.1'
          - '25.2'
          - '25.3'
          - '26.1'
          - '26.2'
          - '26.3'
          - '27.1'
          - '27.2'
          - '28.1'
          - '28.2'
          - 'snapshot'
#+end_src

=steps= がジョブのメインの処理を書く部分です。
#+begin_src yaml
  jobs:
    test:
      # ...
      steps:
        - uses: actions/checkout@v3
        - uses: purcell/setup-emacs@master
          with:
            version: ${{ matrix.emacs_version }}
        - uses: conao3/setup-keg@master

        - run: keg install
        - run: keg run test-all
        - uses: codecov/codecov-action@v2
#+end_src
主に利用するのは =uses= と =run= の2種類です。
=run= は単に与えたシェルコマンドを実行します。
=uses= は、他の人が定義したActionを実行します。
Actionとは、ワークフローで不特定多数の人に利用してもらうことを想定した実行単位で、引数を取ることもできます。
環境変数を通じてAPIトークンなどにアクセスできる場合があるので、信用のできるものだけを利用してください。
なお、 =@= の後ろにブランチやタグを指定することである特定のバージョンのActionsを利用することができます。

ここで利用しているActionは以下の通りです。
- =actions/checkout= :: 当該レポジトリの当該コミットにチェックアウト(つまりテスト対象のコミットをファイルシステムに展開)する。
- =purcell/setup-emacs= :: Emacsを環境にインストールする。 =version= 引数によりインストールするEmacsのバージョンを指定できる。
- =conao3/setup-keg= :: =keg.el= を環境にインストールする。
- =codecov/codecov-action= :: テストのカバレッジをCodecovに送信する。

=run= に指定されている =keg install= と =keg run test-all= については前述のとおりで、それぞれ依存のインストール、
バイトコンパイル前後のテスト実行を担います。

**** lint
ほとんどはtestと同じなので説明するところはあまりありません。
唯一説明していないのは、 =keg lint= の部分です。
#+begin_src yaml :hl_lines 11
  jobs:
    lint:
      runs-on: ubuntu-latest
      continue-on-error: ${{ true }}
      steps:
        - uses: actions/checkout@v1
        - uses: purcell/setup-emacs@master
          with:
            version: '28.2'
        - uses: conao3/setup-keg@master
        - run: keg lint
#+end_src
シェルコマンド =keg lint= は、以下の3つの操作を行います。
これらの操作がエラーを吐かないことは動作自体に必須ではないですが、パッケージとしてはエラーや警告を吐かないことが望ましいです。
なんらかのエラーや警告が発生する場合、行儀の悪いパッケージとみなされる場合があります(例えばMELPAでは直すまで登録できません)。
特に =package-lint= は依存周りの問題を検出してくれるので、従ったほうがよいです。
なお、他のツールでも同様にこのような機能がついていると思われます。場合によっては追加でさらにインデント周りをやってくれたりするかもしれません。
- [[https://github.com/purcell/package-lint][=package-lint=]] :: パッケージとしての要件を満たしているかを検証してくれます。Emacsの最低バージョンで対応していない関数を利用してしまっていないか、
  ヘッダのバージョンや説明文がきちんと書かれているか、接頭辞が正しく運用されているか、などを確かめてくれます。
  詳しくは[[https://github.com/purcell/package-lint][package-lintのGitHub]]及び[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Coding-Conventions.html][Emacs Lispのコーディング規約]]をご覧ください。
  もし今利用しているEmacsで利用したい場合は、 =M-x package-install RET package-lint RET= などを用いてインストールしたあと、
  該当バッファで =package-lint-current-buffer= コマンドを実行してください。
- =checkdoc= :: ドキュメント周りの問題を指摘してくれます。引数がすべて入っているか、ピリオドの後にスペースが2つ入っているか、
  ドキュメントの各行が80桁以下になっているか、などを確認します。
  詳細は [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/checkdoc.el][checkdoc.elのソースコード]]の説明文(Commentary)をご覧ください。
  なお、これは標準搭載のパッケージなので、インストールは必要ありません。
  もし今利用しているEmacsで利用したい場合は、該当バッファで =checkdoc= コマンドを実行してください。
- =byte-compile= :: コンパイルしたときにエラーや警告が出ないかどうかを確認します。
  もし今利用しているEmacsで利用したい場合は、 =byte-compile-file= コマンドを実行して該当ファイルを指定してください。

これらは通るのが望ましいが絶対に通さないといけないものではないため、 =continue-on-error= は =true= としています。

*** .dir-locals.el
このファイルは、前述したファイルローカル変数を、ディレクトリ単位で設定するためのファイルです。
=((メジャーモード (変数 . 値) ...)...)= のような構造になります。
このファイルのあるディレクトリ以下にあるファイルを開いたとき、
そのファイルで立ち上がったメジャーモードに応じて変数の値をファイルローカルに指定できます。
#+begin_src emacs-lisp
  ((emacs-lisp-mode (package-lint-main-file . "sample.el")))
#+end_src
ここでは、Emacs Lispファイルを開いたときに =package-lint-main-file= を ="sample.el"= に束縛しています。

=package-lint-main-file= は文字通り、
=package-lint= においてパッケージのメインのファイルとして認識されるべきファイルを指定します。
メインのファイル以外にはヘッダにバージョンや説明は必要ない、
メインのファイル以外は接頭辞をファイル名と一致させる必要はない、など、
lintを行うにあたってメインのファイルとそれ以外で違いがあるため、この変数を束縛しています。

なお、初期状態では1ファイルのみの構成なので、このファイルはなくても構いません。
複数ファイルにしたときに自動で効果を発揮します。

*** codecov.yml
先ほど述べたカバレッジの計測ツール =undercover= で計測したカバレッジは、前述したGitHub ActionsでCodecovへと送信されます。
その際、当然テストを行った回数だけカバレッジが送信されます。
今回の雛形におけるGitHub ActionsではEmacsの各バージョンでテストを行うようにしているので、
全てが届くまでCodecovに待ってもらう必要がある場合があります。
それを設定しているのがこのファイルです。15種類のバージョンについてテストしている(snapshotバージョンのEmacsは不安定なので除く)ので、
=codecov.notify.after_n_builds= に =15= を指定しています。
#+begin_src yaml
  codecov:
      notify:
          after_n_builds: 15
#+end_src
なぜ =notify= なのかと思うかもしれません。実はここで指定しているのはGitHubへと送られてくる通知の遅延設定です。
適切にCodecovの設定をすると、各コミットのカバレッジ計測の結果をコミットステータスとして通知してくれます。
しかし、最初の1つのカバレッジだけを採用して通知してしまうと、Emacsのバージョンによる分岐を含む場合に正しいカバレッジを通知することができません。
そこで、このファイルでいくつのカバレッジが送信されるのかをあらかじめCodecovに教えています。

** このテンプレートにおいて、対応Emacsバージョンを上げるのにやらねばならないこと
ここまでで、パッケージを作る際に必要な情報はほぼ説明しました。
あと少しだけ、このテンプレートを用いているときに、対応Emacsバージョンを上げる場合になにをすればよいかを纏めておきます。

1. メインのファイルのヘッダの =Package-Requires: ((emacs "24.1"))= を上げたいバージョンに変更する。
2. =.github/workflows/test.yml= の =jobs.test.strategy.matrix.emacs_version= に渡しているリストの中から、
   サポート対象外となるバージョンを取り除く。
3. =codecov.yml= の数字を、取り除いたバージョン分だけ減らす。
  ここの数字は =jobs.test.strategy.matrix.emacs_version= の個数から =snapshot= の分の1を引いた数と一致する。

** 最後に
今回は、パッケージを作る際の雛形の解説を通じ、パッケージを作る際のノウハウを説明しました。
かなり長くなってしまいましたが、だからこそ抜けや漏れがある可能性は多いにあります。
もしなにか間違っている点、おかしな点、理解できなかった点、質問などがあれば、
コメントやメール、[[https://emacs-jp.github.io/][Emacs JP]]のSlackなどでなんなりとご連絡ください。
Emacs JPには私よりも長くEmacsを使っている猛者たちがたくさんいます。

* TODO 自分専用のELPA(Emacs Lisp Package Archive)をGitHubでホストしよう
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-11f6e993-0310-7aa4-0563-ea30d0f25c5d
  :EXPORT_HUGO_TAGS: Emacs package.el GitHub
  :END:
[[https://qiita.com/advent-calendar/2022/emacs][https://img.shields.io/badge/Emacs%20Advent%20Calendar%202022-13%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]

** 序文
[[https://blog.rocktakey.com/information-science/2022-df7edb45-d0ce-7cd4-5c6b-1a3efa8b4b4c/][前回の記事]]では、パッケージの作り方を扱いました。
パッケージを作ったら、今度は自分のEmacsに導入したいと考えるでしょう。
これを行う方法もいろいろあります。
Emacsのパッケージマネージャを以下に列挙してみます。
GNU GuixやNix、aptなどの汎用パッケージマネージャは除いています。
- 中央集権型
  - package.el(標準)
- 分散型
  - [[https://github.com/dimitri/el-get][el-get]](ただしpackage.elを透過的に利用可能らしい)
  - [[https://github.com/cask/cask][Cask]]
  - [[https://github.com/progfolio/elpaca][elpaca]]
  - [[https://github.com/radian-software/straight.el][straight.el]]
  - [[https://github.com/quelpa/quelpa][quelpa]]
この分類は、パッケージのビルドがどこで行われるかに着目しています。
適当なレシピ、つまりパッケージ定義が与えられた下で、
中央集権型はサーバーにおいてビルドされたパッケージをダウンロードするタイプ、
分散型はローカルでビルドするタイプのパッケージマネージャです。

この二つのタイプに明確な優劣があるわけではなく、一長一短です。
中央集権型の場合には、ローカルにパッケージをビルドする環境を用意する必要がないメリットがあります。
分散型だと環境によってローカルビルドが失敗したり一部のファイル(ドキュメント)などが欠けたりする可能性があります
(ただし現実的に問題になることはほとんどない)が、
中央集権型では(通常ユーザーではない人の管理する)ビルドサーバーの環境さえ整っていれば、
ユーザー側では一切の準備なく完全なパッケージを利用可能です。

一方分散型の場合には、一度レシピ一覧さえダウンロードしてしまえば、
レシピを配信するサーバーが落ちてもビルド自体はローカルなので問題にならないというメリットがあります。
もちろんソースコードを頒布するサーバーが落ちている場合はビルドできませんが、
それはパッケージ単位の話で、全てのパッケージを少数のサーバーに依存する中央集権型にはないメリットです。
ただし、 =GitHub= や =GitLab= をはじめとした有名なホスティングサービスでホストしたパッケージが大半なので、
実質的には少数のサーバーに依存してしまっているのが現状です。

中央集権型がpackage.elしかなく、分散型がほとんどを占める理由はおそらく単純で、
中央集権型ではサーバー管理が必要になってくるからだと思います。
新しいパッケージマネージャを作ろうと思ったとき、package.elと異なる配信のしかたをするのであれば、
わざわざパッケージをビルドして配信するサーバーを用意せねばなりません。
サーバーを用意しても利用してもらえなければ意味がないし、利用されすぎても管理費がかかる上、
同じ形式のサーバーが他にも立たないと他のパッケージマネージャに対してあまりメリットがなくなってしまいます。
一方package.elと同様の配信形式をそのまま利用するのであれば、単にpackage.elをバックエンドとすればよいでしょう。
すると必然的にpackage.elのラッパとなります。

中央集権型のpackage.elにはもう一つ大きなデメリットがあります。
それは、気軽にパッケージを追加できないことです。
分散型の場合、ローカルにビルド環境が必要ですが、それさえ用意してしまえば、
レシピを経由して自作パッケージと他の人のパッケージを統一的に扱うことができます。
しかし中央集権型の場合、ビルド及び配信を行うサーバーを別途用意する必要があります。
package.elはローカルのディレクトリをビルドサーバーに見立てて利用することが可能ではありますが、
その場合、結局ローカルのビルド環境を用意しなければならなくなり、あまり中央集権型の恩恵は受けられません。
さらに、ローカルでのビルドを前提としている分散型とは違い、ビルド環境を用意するのはかなり面倒になります。

そこで、なんらかのホスティングサービスを利用してパッケージをインターネット上に公開することを考えます。
パッケージの配布自体は静的サイトでよく、ビルドを定期的に走らせることで最新のパッケージに更新すればよいです。

ここでは、GitHub ActionsとGitHub Pagesを用いてパッケージをビルドし、パッケージを配布するところまでを行います。
実際にはこのサービスを絶対に利用しなければならないわけではないです。
簡単にGitLabなどの他のサービスへと移植できるよう、なにを行っているかを順に説明するつもりです。
ただし、各パッケージのビルドの具体的なプロセスについては[[https://github.com/melpa/package-build][package-build]]によって隠蔽されており、
利用にあたって深く知る必要はないため、あまり詳細に解説はしません。

** テンプレートの利用
今回は、[[https://github.com/ROCKTAKEY/template-github-elpa/][template-github-elpa]]を利用して解説していきます。
このテンプレートは[[https://github.com/10sr/github-elpa][github-elpa]]を直接の依存としており、これを利用するための諸々の準備を整えるためのテンプレートです。
github-elpaはCLIから直接呼びだせるようになっており、READMEでは[[https://github.com/cask/cask][Cask]]を利用するように書いています。
しかし、そこに書かれている =cask exec= コマンドは既にCaskから削除されており、そのままでは利用できません。
そこで、このテンプレートでは =keg= を用いた実行に書きなおしています。
ここで =keg= を選んでいる理由は特になく、単に私が慣れているからです。

詳しくは後述しますが、このテンプレートを利用する場合、
=recipes/= 以下にレシピを書いて =keg run build= すれば、 =docs/elpa/= 以下にパッケージアーカイブが作成されます。

** 使用方法
ここでは、[[https://github.com/10sr/github-elpa][github-elpa]]を使うことに焦点を当てた説明を行います。
具体的になにをしているのか、詳細な説明は[[#technical-description][次章]]をご覧ください。

また、手元で実際のビルド結果を確認したい場合は、
あらかじめ[[https://github.com/conao3/keg.el][keg.el]]をインストールしておいてください。
Emacsが既にインストールされていれば、クローンしてパスを通すだけで動きます。
なお、このツールはEmacs Lispパッケージ及びプロジェクト管理のためのツールで、 =npm= や =yarn= のようなものです。
デファクトスタンダードは特にないため、私の好みでこれを使っているだけです。

さて、順に使用方法を述べていきます。

1. まず、[[https://github.com/ROCKTAKEY/template-github-elpa][template-github-elpa]]をテンプレートとして、GitHubでレポジトリを作成してください。
  ここで作ったレポジトリ名を仮に =yourreponame= とします。
  すると、ユーザー名を =yourname= としたとき、今作成したレポジトリのURLは =https://github.com/yourname/yourreponame=
  となるはずです。ちなみに、ここでそれっぽい名前を付けると愛着が湧きます。
2. =recipes/= 以下にレシピを書きます。
   ここで言うレシピとは、[[https://github.com/melpa/package-build][package-build]]が認識できるフォーマットによって書かれたパッケージの定義のことです。
   パッケージのソースコードがどこにあるか、そのうちどのファイルを配布するのか、などを指定します。
   なお、レシピはパッケージ管理システムによってフォーマットが異なる場合があることに注意してください。
   レシピ自体はEmacs標準の概念ではなく、単にサードパーティのパッケージ管理システムやパッケージビルダーがパッケージの指定を簡単にするために
   導入したものです。

   以下に[[https://github.com/melpa/melpa#recipe-format][MELPAのREADME]]にあるレシピのフォーマット
   ([[https://github.com/melpa/package-build][package-build]]はMELPAプロジェクトの一部で、レシピのフォーマットはここを見るように[[https://github.com/melpa/package-build][package-build]]のREADMEに書いてある)を転載します。
   なお、S式としてパースされるため、改行は空白と等価です。
   また、 =[]= 内は省略可能、もしくは選択肢のなかから選ぶ方式を取る値です。
   #+BEGIN_SRC emacs-lisp
     (<package-name>
      :fetcher [git|github|gitlab|codeberg|sourcehut|hg]
      [:url "<repo url>"]
      [:repo "user-name/repo-name"]
      [:commit "commit"]
      [:branch "branch"]
      [:version-regexp "<regexp>"]
      [:files ("<file1>" ...)]
      [:old-names (<old-name> ...)])
   #+END_SRC
   通常、ファイル名は =<package-name>= と同一にします。
   主要なキーワードだけ軽く説明します。
   - =<package-name>= :: パッケージの名称。 =package-list-packages= などではこの名前で見える。
     メインのファイルは =<package-name>.el= であることが推奨される。
   - =:fetcher= :: 対象のパッケージのソースコードがどこでどうホストされているかを示す。
     =github= 、 =gitlab= 、 =codeberg= 、 =sourcehut= の4つのホスティングサービスには直接対応している。
     それ以外でホストしている場合は、利用しているバージョン管理システムに応じて =git= か =hg= を指定する。
   - =:repo= :: レポジトリを表す文字列で、 =ユーザー名/レポジトリ名= のようなものを与える。
     なお、これは =:fetcher= でホスティングサービスを直接指定したときにのみ有効。
   - =:url= :: レポジトリのURL。 =:fetcher= でバージョン管理システムを指定したときにのみ有効。
   - =:files= :: 対象パッケージに含むべきファイル名に一致する正規表現のリスト。
     なお、このリストの末尾の要素は =(:exclude "正規表現"...)= でもよく、ここにある正規表現に一致するファイルは、
     たとえ含むべきファイルの正規表現に一致したとしても除外される。
     なにも指定しなければ以下の値になる([[https://github.com/melpa/melpa#recipe-format][MELPAのREADME]]より転載、最新の情報は転載元を確認してください)。
     #+BEGIN_SRC emacs-lisp
       '("*.el" "lisp/*.el"
         "dir" "*.info" "*.texi" "*.texinfo"
         "doc/dir" "doc/*.info" "doc/*.texi" "doc/*.texinfo"
         "docs/dir" "docs/*.info" "docs/*.texi" "docs/*.texinfo"
         (:exclude
          ".dir-locals.el" "lisp/.dir-locals.el"
          "test.el" "tests.el" "*-test.el" "*-tests.el"
          "lisp/test.el" "lisp/tests.el" "lisp/*-test.el" "lisp/*-tests.el"))
     #+END_SRC
     もしデフォルトのファイル群に付け足す形で指定したい場合は、リストの先頭要素として =:defaults= を書くとよい。
     そうすると、上記のデフォルトに加えて、リストの先頭でない要素の正規表現にマッチしたファイルが認識される。

   さて、レシピの簡単な説明を終えたところで、レシピを書いてみましょう。
   コピペで動くように、とりあえず存在するパッケージをそのまま利用します。
   例として今回用意した特になにもしないパッケージである[[https://github.com/ROCKTAKEY/dummy-example-el][dummy-example]]を用います
   (他人の書いたパッケージが今後存在し続けることを担保するのが面倒なのでダミーのパッケージを用意しました)。
   自分で定義したパッケージがあるのなら、是非そちらに書きかえてみてください。
   #+BEGIN_SRC emacs-lisp
     ;; ファイル名: recipes/dummy-example
     (dummy-example :fetcher github :repo "ROCKTAKEY/dummy-example-el")
   #+END_SRC
   書き方は先ほどの通りで、ファイル名とパッケージ名を一致させ、 =fetcher= はコードがGitHubにあることから =github= に指定、
   ユーザー名 =ROCKTAKEY= でレポジトリ名 =grugru= なので =:repo= に ="ROCKTAKEY/grugru"= と指定します。
   自分のパッケージを作成したい場合は適宜置き換えてください。
   なお、レシピの編集のためのメジャーモードとして =package-recipe-mode= というモードが[[https://github.com/melpa/package-build][package-build]]パッケージで提供されているので、
   是非お使いください。

3. レシピを書いたので、手元でビルドしてみます。
   なお、この操作自体は必須ではなく、レシピさえコミットしてしまえばGitHub Actionsでビルドしてくれます。
   ただし、ビルドすることでなにが起こるか、正常にビルドできるか確かめるために手元で実行しておくことが望ましいです。

   この章の最初で述べたように[[https://github.com/conao3/keg.el][keg.el]]をインストールしたら、クローンしたあなたのレポジトリで以下を実行してください。
   #+BEGIN_SRC shell
     keg install
     keg run build
   #+END_SRC
   一行目でgithub-elpa及びその依存先をインストールし、二行目でレシピからパッケージをビルドします。
   =Keg= ファイルに書いてある通りですが、
   二行目は =keg emacs --batch -Q --eval (require 'github-elpa) -f github-elpa-build= を(github-elpa及びその依存先にload-pathを通した上で)
   実行しているだけです。
   成功すれば、二行目に対する出力として以下のようなものが得られるはずです。
   #+BEGIN_EXAMPLE
     Install dependencies
      DevDependency: ((github-elpa 0.0.1))

     All dependencies already satisfied
     Exec command: keg emacs --batch -Q --eval \(require\ \'github-elpa\) -f github-elpa-build
     Exec command: emacs --batch -Q --eval \(require\ \'github-elpa\) -f github-elpa-build


     :: github-elpa: packaging recipe dummy-example
     Package: dummy-example
     Fetcher: github
     Source:  https://github.com/ROCKTAKEY/dummy-example-el.git

     Cloning https://github.com/ROCKTAKEY/dummy-example-el.git to /home/rocktakey/sandbox/template-github-elpa/.github-elpa-working/dummy-example/
     Checking out 4776eee32b38dbfcdd45b2d87e2c5ce989e5ce05
     Built dummy-example in 0.908s, finished at 2023-02-20T17:02:09+0000
   #+END_EXAMPLE
   各パッケージにどんなファイルが含まれているかなど、ビルドの詳細が出力されています。複数のレシピがあれば複数のログが出力されるはずです。
   なお、ビルド生成物は =./docs/elpa/= 以下に出力されています。

4. 最後にこれをコミットしましょう。すると、GitHub Actionsによって自動的にビルドされ、
   パッケージアーカイブが =https://yourname.github.io/yourreponame/= にデプロイされます。
   なお、デフォルトでは =cron= を用いて毎日1回ビルドが走るようになっています。適宜変更してください。

   =./.github/workflows/pages.yml= を見るとわかりますが、先ほど手元で行ったビルドプロセスと全く同じことを実行した上で、
   GitHub Pagesに =./docs/elpa/= 以下をデプロイしているだけです。
   また、PRなどに対してビルドテストが走るようにしています(=./.github/workflows/test.yml= を参照)。
   テストでも同様にビルドを走らせているだけです。

5. init.elを変更して、package.elにアーカイブの場所を教えてあげましょう。
   以下をinit.elに追加してください。 =好きな名前= のところは好きな名前に置き換えてください。
   レポジトリの名前と揃っているとわかりやすいかもしれませんが、必須ではありません。
   ここの名前はパッケージをリスト形式で並べるときに出てくるので、自分の識別しやすい名前にしてください。
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'package-archives '("好きな名前" . "https://yourname.github.io/yourreponame/"))
   #+END_SRC
   ここで =package-list-packages= を実行すると、パッケージのリストが画面に表れます。
   しばらくするとリフレッシュ(パッケージアーカイブの最新情報をURLから取ってくる操作)が終了し、新しいパッケージがリストに追加されます。
   以後、このリストで =i= を押してパッケージをマークしてから =x= を押すか、 =package-install= コマンドを使うことでインストールできます。
   また、リストせずにリフレッシュだけしたい場合は =package-refresh-contents= コマンドを実行すればよいです。

** 技術的な仕組みの説明
:PROPERTIES:
:CUSTOM_ID: technical-description
:END:
この章はパッケージアーカイブがどのような仕組みで構成されているかを説明します。
先ほどのテンプレートを使用するだけであればこの章を読む必要はありません。

*** パッケージアーカイブの仕組み
そもそもパッケージアーカイブとは、どのようなディレクトリ構成になっていればよいのでしょうか。
それさえ把握してしまえば、 =package-build= や =github-elpa= を利用する必要はありません。

パッケージアーカイブのディレクトリ構造は、ルートディレクトリに対して以下のようになっています。
#+BEGIN_EXAMPLE
  .
  ├── archive-contents
  ├── package1-20230220.1700.el
  ├── package1-20230220.1700.entry
  ├── package1-readme.txt
  ├── package2-20230121.1825.entry
  ├── package2-20230121.1825.tar
  └── package2-readme.txt
#+END_EXAMPLE
大きくわけると4種類に分けられます。
- アーカイブ全体についてのファイル
  - =archive-contents= ファイル
- 各パッケージについてのファイル
  - =*.el= / =*.tar= ファイル
  - =*-readme.txt= ファイル
  - =*.entry= ファイル
これらのそれぞれについて解説していきます。

**** =archive-contents= ファイル
このファイルは、package.elのリフレッシュの際に用いられます。
このファイルはアーカイブがどのようなパッケージを持っているかをalistで保持しています。

# =package--download-one-archive=
* TODO MELPAにパッケージを提出してみんなに使ってもらおう
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-c6b38d7a-1974-ad04-8ebb-ee117a8a1d2d
  :EXPORT_HUGO_TAGS: EMacs MELPA
  :END:
[[https://qiita.com/advent-calendar/2022/emacs][https://img.shields.io/badge/Emacs%20Advent%20Calendar%202022-14%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]
* DONE Guixのパッケージをつくってみよう-その1: 簡単なフォントのパッケージを作る
CLOSED: [2022-12-05 Mon 04:43]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-770eb4b6-5c63-62d4-bbcb-475d92404603
  :EXPORT_HUGO_TAGS: GNU-Guix Scheme
  :END:
[[https://qiita.com/advent-calendar/2022/guix][https://img.shields.io/badge/GNU%20Guix%20Advent%20Calendar%202022-5%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]
** 序文
GNU Guixでは、簡単にパッケージを作り、自分でそれを利用することができます。
GNU Guixでは、パッケージ定義群は「チャンネル」という名前がついています。
各々が自分だけのチャンネルを作り、それを公開するなりローカルに保持するなりし、Guixにそれを教えてあげることで、
そのチャンネルを経由してパッケージを利用することができるようになります。

この記事では、おそらく最も簡単であるフォントのパッケージを実際に作り、チャンネルを経由して配信するところまでを扱います。

** 前提
GNU Guix自体はインストールされていて、使えるようになっていることを前提とします。

** チャンネルを用意する
チャンネルは、(試したことないですが)ローカルに用意することもできますし、GitHubやGitLabのレポジトリホスティングサービスを使うこともできます。
チャンネルにしたいレポジトリかディレクトリ直下に、以下のような内容のファイル =.guix-channel= をおいてください。
=<your-channel-URL>= は、ローカルの場合は =file:///path/to/channel/= 、
GitHubやGitLabレポジトリの場合は =https://gitlab.com/username/channel= の形式のURLに置き換えてください。
また、レポジトリを利用する場合はコミットしてプッシュするのを忘れないでくださいね。
#+BEGIN_SRC scheme
  (channel
   (version 0)
   (url "<your-channel-URL>"))
#+END_SRC
これはチャンネルの宣言です。依存関係がある場合や、チャンネルをサブディレクトリに置きたい場合には、
ここで一緒に宣言します。詳しくは[[https://guix.gnu.org/en/manual/devel/en/guix.html#Creating-a-Channel][公式のドキュメント(英語)]]をご覧ください。

次に、チャンネルの位置をGuixに教えてあげます。
=~/.config/guix/channels.scm= に以下を書いてください。
=<your-channel-URL>= は先程と同様に置き換えてください。また、 =your-channel-name= は任意の名前です。
好きな名前を付けて愛着を湧かせましょう。
#+BEGIN_SRC scheme
  (cons* (channel
          (name 'your-channel-name)
          (url "<your-channel-URL>")
          ;; もしレポジトリのデフォルトブランチが `main' の場合は以下を追記
          ;; (branch "main")
          )
         %default-channels)
#+END_SRC

これで登録は完了です。以下のコマンドを実行し、今登録したチャンネルからパッケージ定義を取り寄せていることを確認しましょう。
#+BEGIN_SRC shell
  guix pull
#+END_SRC
もし成功していれば、以下のような表示が得られます。
#+begin_example
  Updating channel 'your-channel-name' from Git repository at '<your-channel-URL>'...
  Updating channel 'guix' from Git repository at 'https://git.savannah.gnu.org/git/guix.git'...
  Building from these channels:
    guix      https://git.savannah.gnu.org/git/guix.git	a4d52f0
    your-channel-name    https://github.com/ROCKTAKEY/roquix	0000000
  (後略)
#+end_example

これで準備は完了です。

** パッケージを定義する
さて、パッケージを定義していきましょう。
まず、先程のディレクトリの下に =your-channel-name= 、及び =your-channel-name/packages= ディレクトリを作成してください。
これは単なる慣習です。基本的には =your-channel-name/packages/= 以下にパッケージ定義を置いていきます。

今回は、[[https://github.com/miiton/Cica][Cica]]というフォントのパッケージを作成していきます。
先にコードを貼っておきます。 =your-channel-name/packages/fonts.scm= に以下を書いてください。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages fonts)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download)
    #:use-module (guix build-system font))

  (define-public font-cica
    (package
      (name "font-cica")
      (version "5.0.3")
      (source (origin
                (method url-fetch)
                (uri (string-append
                      "https://github.com/miiton/Cica/releases/download/"
                      "v"
                      version
                      "/Cica_v"
                      version
                      ".zip"))
                (sha256
                 (base32
                  "0vshn2cd70mnbavsw9cbagcasa95wiv9qdj4wkzxn7gxygqvrlfb"))))
      (build-system font-build-system)
      (home-page "https://github.com/miiton/Cica")
      (synopsis "Japanese monospaced font for programming")
      (description
       "Cica is a Japanese monospaced font for programming.
  Hack + DejaVu Sans Mono is used for ASCII, and Rounded Mgen+ for the other.
  In addition, Nerd Fonts, Noto Emoji, Icons for Devs, and some adjustment forked from
  the Ricty generator are converted and adjusted.")
      (license license:silofl1.1)))
#+END_SRC

このコードはSchemeという言語で書かれています。
Lispに慣れていないと括弧に圧倒されるかもしれませんが、基本的には =(関数名 引数1 引数2...)= が関数呼び出しとなっています(このような塊をS式と呼びます)。
ただし、評価されないS式も多々出てきます(S式を関数呼び出しとして解釈して実行することを評価と呼びます)。
それは上位の関数的なもの(マクロと呼び、関数と全く同様な呼び出し記法で呼び出す)が各引数を評価するかどうか自由に決めることができるからですが、
理解できなくても構いません。ひとつずつ解説していくので安心してください。

*** モジュール
まずは、冒頭にある =define-module= の式をご覧ください。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages fonts)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download)
    #:use-module (guix build-system font))
#+END_SRC
これは名前の通り、「モジュールを定義する」部分になります。実はパッケージは、Schemeのモジュールという機構によって定義されます。
ここではそれを定義することでこのファイルをモジュールとし、Guixがモジュールとしてファイルを読み込むことができるようにします。

第一引数である =(your-channel-name packages fonts)= は、ちょうどディレクトリの構造及びファイル名を反映していなければなりません。
第二引数と第三引数、及びそれ以降の引数の組は =#:use-module (guix packages)= のような形をしています。
これは、このモジュールがなんのモジュールに依存しているかを表しています。
依存が足りなかったら後でエラーが出て、「○○を =use-module= してなくない？」と教えてくれるので、
厳密にどのパッケージがどこにあるか覚えていなくても問題にならないことが多いです。
ちなみに =#:prefix license:= の行では、「このモジュールでエクスポートされた変数は =license:= という接頭辞を付けてアクセスする」という指定が付いています。

*** パッケージ定義
さて、いよいよパッケージ定義です。外側から順番にみていきましょう。
#+BEGIN_SRC scheme
  (define-public font-cica
    ...)
#+END_SRC
=define-public= は、変数を定義する =define= の亜種です。
こちらも変数を定義しますが、それに加えて「モジュールの外からも見えるようにする(つまり公開状態(public)にする)」という機能があります。
先程も言ったように、Guixはモジュールを経由してパッケージ定義を得ます。そのため、パッケージ定義は公開されている必要があります。
第一引数は変数の名前で、第二引数がその値です。

さて、以下のようなものが値として与えられていました。
#+BEGIN_SRC scheme
  (package
   (name "font-cica")
   (version "5.0.3")
   (source ...)
   (build-system font-build-system)
   (home-page ...)
   (synopsis ...)
   (description ...)
   (license ...))
#+END_SRC
=package= というのは、 =package= というオブジェクトを生成する、所謂コンストラクタにあたるものです
(たぶん。違ったらすみません。普段使っているLispの方言と色々違っていてまだ完全にSchemeを習得できていません)。
各引数は =(name "font-cica")= のようになっています。 =(フィールド名 値)= の形で各フィールドの値を与えています。
名前(フィールド名)付きの引数(値)を複数渡せるようになっていると考えるとわかりやすいかもしれません。ちなみに順不同です。

この =(フィールド名 値)= のS式は評価されない(評価されたらフィールド名が関数名と解釈されて評価後の値が =package= の引数となってしまうため、
=package= コンストラクタがフィールド名を知る術がなくなる)ため、 =package= コンストラクタはマクロだろうと推測できます(これも定かではない)。
なお、 =値= の部分は評価されます。

少し話が逸れましたが、ここまで来ればあと少しです。 =package= コンストラクタに渡す引数をひとつひとつ見ていきましょう。

**** nameフィールド、versionフィールド
まずは =name= と =version= です。
#+BEGIN_SRC scheme
  (package
    (name "font-cica")
    (version "5.0.3")
   ...)
#+END_SRC
=name= は、文字通りパッケージの名前です。
この値は、コマンドラインからパッケージをインストールする場合に使います(例: =guix install font-cica=)。
バージョン違いなど、パッケージとなる対象が同じ場合、名前は他のパッケージと被っても構いません。
複数の定義がある場合はデフォルトで最も新しいものがインストールされます。
バージョンを指定してインストールすることも可能(例: =guix install gcc-toolchain@10=)なため、
バージョン違いで名前を被せることはむしろ有用です。

=version= はバージョンを表す文字列です。
おそらく形式に決まりはないですが、先頭に"v"を付けずに"5.0.3"のようにする場合が多いです。

**** home-pageフィールド、synopsisフィールド、descriptionフィールド
一番説明が面倒な =source= と =build-system= を一旦飛ばして、 =home-page= 、 =synopsis= 、 =description= に移ります。
#+BEGIN_SRC scheme
  (package
    ...
    (home-page "https://github.com/miiton/Cica")
    (synopsis "Japanese monospaced font for programming")
    (description
     "Cica is a Japanese monospaced font for programming.
  Hack + DejaVu Sans Mono is used for ASCII, and Rounded Mgen+ for the other.
  In addition, Nerd Fonts, Noto Emoji, Icons for Devs, and some adjustment forked from
  the Ricty generator are converted and adjusted.")
    ...)
#+END_SRC
この3つは割と見たまんまで、 =home-page= にはパッケージの対象のホームページを、 =synopsis= にはパッケージの1行の概要を、
=description= はパッケージの説明を文字列で与えます。なお、 =description= に[[https://www.gnu.org/software/texinfo/manual/texinfo/texinfo.html][texinfo]]の記法を使えます。

**** licenseフィールド
次は =license= です。
#+BEGIN_SRC scheme
  (package
    ...
    (license license:silofl1.1))
#+END_SRC
ここにはライセンスを指定します。ライセンスを表す定数は =(guix licenses)= モジュールで定義されています。
利用できるパッケージは[[https://git.savannah.gnu.org/cgit/guix.git/tree/guix/licenses.scm][公式レポジトリ]]で見ることができます。MITライセンスの名前は =expat= なので注意。
モジュール定義の際に =#:prefix license:= を指定したため、 =silofl1.1= の代わりに =license:silofl1.1= となっています。

**** sourceフィールド
次は先程飛ばした =source= です。
#+BEGIN_SRC scheme
  (package
    ...
    (source (origin
              (method url-fetch)
              (uri (string-append
                    "https://github.com/miiton/Cica/releases/download/"
                    "v"
                    version
                    "/Cica_v"
                    version
                    ".zip"))
              (sha256
               (base32
                "0vshn2cd70mnbavsw9cbagcasa95wiv9qdj4wkzxn7gxygqvrlfb"))))
    ...)
#+END_SRC
=source= は少し複雑ですが、基本的にはほとんどイディオムで、普段は専らコピペしています。
=source= フィールドには =origin= オブジェクトを渡しています。 =origin= オブジェクトはその場で生成して渡しています。
=origin= オブジェクトのコンストラクタの部分を抜き出してみます。
#+BEGIN_SRC scheme
  (origin
    (method url-fetch)
    (uri (string-append
          "https://github.com/miiton/Cica/releases/download/"
          "v"
          version
          "/Cica_v"
          version
          ".zip"))
    (sha256
     (base32
      "0vshn2cd70mnbavsw9cbagcasa95wiv9qdj4wkzxn7gxygqvrlfb")))
#+END_SRC
フィールドは =method= 、 =uri= 、 =sha256= の3つあることがわかります。

=method= としてここで与えているのは =url-fetch= です。
他には =git-fetch= を使うことが多いと思います。
その場合、 =uri= フィールドではgitレポジトリの情報を与えなければならないため、以下のような形になります。
#+BEGIN_SRC scheme
  (uri (git-reference
        (url "https://example.com/your/git/repo")
        ;; コミットハッシュの代わりにタグを使うこともできます。
        ;; (commit (string-append "v" version))
        (commit "0000000")))
#+END_SRC

=uri= として与えているのは文字列です。 =string-append= は単に文字列を結合する関数で、引数に文字列を与えてそれを呼び出しています。
マクロの力(たぶん、もしかしたらScheme自体の特徴かも)により、
=version= という名前で先程 =(version "5.0.3")= として渡した =version= フィールドの値 ="5.0.3"= にアクセスできるため、
呼び出した結果は以下のようになるはずです。
#+BEGIN_SRC scheme
  ;; S式
  (string-append
            "https://github.com/miiton/Cica/releases/download/"
            "v"
            version
            "/Cica_v"
            version
            ".zip")

  ;; 評価後の値
  "https://github.com/miiton/Cica/releases/download/v5.0.3/Cica_v5.0.3.zip"
#+END_SRC

=sha256= には、 謎の文字列を =base32= に渡したものが与えられています。
これはいわゆる「ハッシュ値」というもので、与えられたディレクトリの内容から一意に定まります。
URIから得られたファイルがパッケージを定義した人と一致していない場合、偽物を掴まされたことになりますが、
ハッシュ値を比較することで偽物であることを感知できます。
これにより、偽物を掴まされたことに気付かずにそのパッケージを使用してウイルスやマルウェアに侵されることを防ぎます。
この方法ではパッケージを定義した人がマルウェアを配信している場合に感知することはできないので、信頼できるチャンネルだけを登録しましょう。

このハッシュ値は、 =guix download <URL>= と入れることで得ることができます。
対象がgitレポジトリの場合、そのレポジトリをクローンして =guix hash -rx /path/to/repo= とすることで得ることができます。
後者の場合、異なるコミットやタグにチェックアウトしている場合は異なるハッシュ値が返るので注意してください。
また、裏技として、適当なハッシュ値を入れてパッケージをビルドすると「ハッシュ値が間違ってるよ」と言いながら実際のハッシュ値を教えてくれます。

**** build-systemフィールド
最後は =build-system= です。
#+BEGIN_SRC scheme
  (package
    ...
    (build-system font-build-system)
    ...)
#+END_SRC
=build-system= では、「パッケージをどのようにビルド・インストールするか」を与えます。
フォント専用の =font-build-system= の場合は既にあるファイルを所定のディレクトリに配置する作業が主です。
フォント以外、例えばソースコードからビルドするような場合には、ビルド方法を指定する必要があります。
ビルド方法によって色々定義されています。詳細は[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Systems][公式マニュアル]]にあります。
明日の記事で詳しく触れる予定です。

** パッケージをビルドしてみる
さて、これでパッケージの定義が終わりました。実際に使ってみましょう。
まずはパッケージをあなたのチャンネルに配信しましょう、と言いたいところですが、
実際に動くかわからないコードをいきなりプッシュするのは怖いですよね。
=guix= コマンドは =-L= オプションでチャンネルとなる(つまりロード対象となる)ディレクトリを渡すことで、
一時的にそのチャンネルを登録したかのように振舞います。
今定義したパッケージ =font-cica= をビルドすべく、以下を実行してみましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel/ font-cica
#+END_SRC
正常にビルドが成功すれば、大量のログの末尾に =/gnu/store/p6v2bm5s9diamkanr9z6c7r63ikzibb5-font-cica-5.0.3= のような表示が出ていると思います
(ただしハッシュ値は違う可能性があります)。

次に、それをインストールした環境に入ってみます。
#+BEGIN_SRC scheme
  guix shell -L /path/to/your/channel/ font-cica
#+END_SRC
=guix shell= は、指定したパッケージが *追加で*インストールされた環境に一時的に入ります
(元々入っていたパッケージは引き継がれた上で、新しい環境に入ります
もしまっさらな環境に指定パッケージだけが入った環境へ一時的に移りたい場合は、 =--pure= オプションを付ければよいです)。
shellのプロンプトに =[env]= が追加されていたら正常に移行できています。

とはいっても、フォントをインストールした場合はなにかを実行できるわけではなく、
このような環境に入ったところでよくわからないので、一旦 =exit= してください。
実行ファイルがビルドされるようなパッケージであれば、ここで実際に動くか試すことが可能です。

フォントが入っているか確かめるために、以下のコマンドを実行してまた新しい環境に移動してみましょう。
#+BEGIN_SRC shell
  guix shell --container -L /path/to/your/channel/ font-cica fontconfig grep
#+END_SRC
これは先程定義した =font-cica= に加えて、 =fontconfig= 、 =grep= をインストールした環境へ一時的に移行するコマンドです。
今回は =--container= オプションを付けています。これにより、指定したパッケージだけをインストールした(つまり今の環境にあるパッケージは含まない)、
ファイルシステムを含めて完全に独立した環境へ一時的に移行するオプションです。
=--pure= オプションの場合も指定したパッケージだけをインストールした環境へと一時的に移行するという点では同じですが、
ファイルシステムが独立していないという点が異なります。
これは本筋と全く関係のない話なので無視して構いませんが、ここで =--pure= ではなく =--container= を利用している理由は、
=fontconfig= がキャッシュをユーザーディレクトリに残すからか、
ファイルシステムが共有の =--pure= では元の環境にインストールされているフォントが漏れ出してしまうからです。

さて、新しい環境で以下を実行してみましょう。
#+BEGIN_SRC shell
  fc-list | grep Cica
#+END_SRC
これは =fc-list= で得られたフォントの一覧を、 =grep= コマンドで "Cica" を含むものだけに絞りこんでいます。
ここでなんらかの出力が得られれば、成功です。無事フォントをインストールできていることが確認できます。
終わったら =exit= を打って環境を戻しておきましょう。

念のため、なにもない環境でなんの出力も出ないかどうかを確認してみましょう。
#+BEGIN_SRC shell
  guix shell --container font-cica fontconfig grep
  fc-list | grep Cica
#+END_SRC
ここでなにも出ないことが確認できれば、 =font-cica= パッケージを入れたことによってフォントがインストールできたことの証明になります。

ちなみに余談ですが、 =guix shell= である環境に一時的に移行してあるコマンドを実行してすぐ戻ってくる、という操作は簡略化できます。
具体的には、以下のように末尾に =-- 実行したいコマンド= とすればよいです。
#+BEGIN_SRC shell
  guix shell --container font-cica fontconfig grep -- fc-list | grep Cica
#+END_SRC
ただし、上記の場合パイプ =|= の後ろの =grep= は一時環境から戻ってきた後に実行されているため、
現環境に =grep= がインストールされている必要があることに注意してください。つまり以下のように解釈されています。
#+BEGIN_SRC shell
  (guix shell --container font-cica fontconfig grep -- fc-list) | grep Cica
#+END_SRC
私もこれに対する解法は持ち合わせていません。
パイプや =&&= を =guix shell= に渡す方法があれば教えていただけると幸いです。

** パッケージをチャンネルに配信する
これでパッケージの動作確認が終わりました。最後に =lint= と =style= をかけておきましょう。
#+BEGIN_SRC shell -n
  guix style -L /path/to/your/channel/ font-cica
  guix lint -L /path/to/your/channel/ font-cica
#+END_SRC
lintについては必要以上に厳しい場合があるので、脆弱性など重要そうなものでなければ無視しても構いません。
特に上流のレポジトリに対して「tagが打たれてない」とか「GitHubでReleaseが作られてない」とか言われますが、大抵の場合どうしようもないです。
一行の長さなどは従っておきましょう。

Gitレポジトリのホスティングサービスを使っている人は、変更をコミットしてプッシュしてください。
ローカルの人はそのままでよいです。

そうしたら、また以下のコマンドを打ってください。
#+BEGIN_SRC shell
  guix pull
#+END_SRC
これによって、新しいパッケージ定義がGNU Guixに読み込まれました。
パッケージ定義が読み込まれているか確認するために、以下のコマンドを打ってみましょう。
#+BEGIN_SRC shell
  guix show font-cica
#+END_SRC
これで今登録したパッケージの詳細が表示されれば成功です。もしそのままインストールしたければ
#+BEGIN_SRC shell
  guix install font-cica
#+END_SRC
とすればよいですし、取り除きたければ
#+BEGIN_SRC shell
  guix remove font-cica
#+END_SRC
とできます。また、一つ前の状態に戻したい(たとえば入れたパッケージがやっぱりいらなかったので入れなかったことにする、など)場合は、
#+BEGIN_SRC shell
  guix package --roll-back
#+END_SRC
とすればよいです。

** 最後に
この記事では、フォントという比較的簡単な対象に対してパッケージ定義を行いました。
この「簡単」という言葉に驚くかもしれませんが、そもそもパッケージ定義自体に加えてその周辺知識についても一緒に説明しているため、
フォントのパッケージ定義自体は簡単でも、記事としてはかなり密度が高くなっています。
実際に =font-cica= に書いた定義自体も30行程度と短いですし、フォントのパッケージ定義自体よりもその周辺知識に頭を使ったと考えてください。
難しく感じるのも無理はありません。もしなにか質問などあれば、コメントなりメールなりで受け付けます。
また、Guixの日本語コミュニティである[[https://guix-jp.gitlab.io/][Guix-jp]]もあります(ちなみに今回作ったパッケージと同じものが[[https://gitlab.com/guix-jp/channel][Guix-jp公式チャンネル]]にあります)。
そちらには私以上のエキスパートの人がいますので、是非そちらもご興味あれば覗いてみてください。

*** 次回の記事
次回の記事は「[[https://blog.rocktakey.com/information-science/2022-c5b823db-a6b6-23a4-5783-c7741fd0f420/][Guixのパッケージをつくってみよう-その2: ビルドが必要なパッケージを作る]]」です。

* DONE Guixのパッケージをつくってみよう-その2: ビルドが必要なパッケージを作る
CLOSED: [2022-12-07 Wed 03:45]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-c5b823db-a6b6-23a4-5783-c7741fd0f420
  :EXPORT_HUGO_TAGS: GNU-Guix Scheme
  :END:
[[https://qiita.com/advent-calendar/2022/guix][https://img.shields.io/badge/GNU%20Guix%20Advent%20Calendar%202022-6%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]

** 序文
[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/][前回の記事]]では、フォントのパッケージ定義を通じて、パッケージ定義の流れを解説しました。
この記事では一歩進んで、ビルドを伴うパッケージの定義を行っていきます。

実はGNU Guixはその思想上、この「ビルド」というプロセスをきちんと行うことを大切にしています。
[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/][前回の記事]]で、ハッシュ値を確認することで偽物を掴まされていないことを確認するプロセスがあることを説明したと思いますが、
その一方で配信元がウイルスやマルウェアなどの悪意のあるコードを仕込んでいる場合は感知することはできません。
これを防ぐための究極の方法は、ソースコードから直接ビルドすることです。
公開されているソースコードからビルドすれば、ソースコードを確認することで悪意のあるコードが混入していないかを確認することができます。
一方公開されているバイナリを直接インストールする方法の場合、悪意のあるコードが混入していることを確認する術はありません。
元のソースコードが公開されていても、そのバイナリがそのソースコードからビルドされたことを確かめられないので無意味です。

このような理由で、GNU Guixはあらゆるパッケージを自分の手元でビルドすることを信条としています。
もちろんサイズが大きいパッケージをたくさん使うような場合、全てビルドするのは大変な場合もあります。
そのため、「このサーバーのビルドしたパッケージは信用できるので、ビルドする代わりにバイナリからインストールする」というのを実現する機能があります。
この機能はSubstitutesと呼ばれています。デフォルトではGNUのサーバーだけが登録されています。詳しくは[[https://guix.gnu.org/en/manual/devel/en/guix.html#Substitutes][公式マニュアル]]をご覧ください。
また、この機能はあくまでも「ビルド手順をパッケージ定義として示した上で、その手順と全く同一の手順を踏んでいるであろうバイナリを提供するサーバーを信用する」
という機能であることに注意してください。ビルド手順の記述を省略するようなことはできません。
そのへんに落ちているバイナリから直接インストールする機能は[[https://blog.rocktakey.com/information-science/2022-6353e393-4e0b-6ad4-754b-0d84ebd31c97/][次回の記事]]で説明します。

** 前提
GNU Guix自体はインストールされていて、使えるようになっていることを前提とします。
また、[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/][前回の記事]]の設定が残っていることが前提となっています。
ただし、試すだけなら必ずしもGitレポジトリを使う必要はなく、 =-L /path/to/channel= オプションを毎回使ってもよいです。
大抵のサブコマンドには対応しています。

** パッケージを定義する
今回は、[[https://geoff.greer.fm/ag/][ag]]というバイナリのパッケージを作成していきます。
agは高速なgrepとして開発されたCLIツールで、パッケージは[[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/code.scm#n337][GNU Guixの公式チャンネル]]に含まれています。
そこから引用されたコードはGPLv3 or laterによってライセンスされていることに留意してください。

前回はパッケージ定義の概要を説明するためにパッケージ定義を先に示しましたが、
今回はパッケージを作るときの流れを実際に体験してもらうため、先に最終形を示すことはしません。

*** モジュール
まずは前回同様、モジュールを定義していきます。
チャンネルの下の =your-channel-name/packages/ag.scm= に以下を書きましょう。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages ag)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download))
#+END_SRC
この3つのモジュールはほぼ必ず =#:use-module= することになるため、これを雛形としてもよいと思います。
前回と異なるのは一行目の =(your-channel-name packages ag)= のファイル名にあたる最後の =ag= の部分くらいです。
あと、今回はフォントではないので =(gnu build-system font)= を =#:use-module= しないようにしました。

*** パッケージ定義
次にパッケージ定義を書いていきます。今回は本家との名前の衝突を避けるために =my-ag= という名前にしましょう。
ビルドのしかたは[[https://github.com/ggreer/the_silver_searcher#building-a-release-tarball][agのREADME]]に書いてあります。
それによると、[[https://geoff.greer.fm/ag/][ここ]]にあるtarballからビルドする場合は以下のようなコマンドでインストールできるらしいです。
ソースコードは "https://geoff.greer.fm/ag/releases/the_silver_searcher-2,2,0.tar.gz" にあるようです(リンク先のリンクにあります)。
#+BEGIN_SRC scheme
  ./configure
  make
  make install
#+END_SRC
このようなビルドの手順はLinuxにおいて非常によく使われる典型的なものです。
まずはこの典型的なビルドをできるようになって欲しいため、このパッケージを題材にしました。

この情報を元に、パッケージ定義を書いてみます。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
     (name "my-ag")
     (version "2.2.0")
     (source (origin
              (method url-fetch)
              (uri (string-append
                    "https://geoff.greer.fm/ag/releases/the_silver_searcher-"
                    version ".tar.gz"))
              (sha256
               (base32
                "0w1icjqd8hd45rn1y6nbfznk1a6ip54whwbfbhxp7ws2hn3ilqnr"))))
     (build-system gnu-build-system)
     (home-page "https://geoff.greer.fm/ag/")
     (synopsis "Fast code searching tool")
     (description
      "The Silver Searcher (@command{ag}) is a tool for quickly searching large
    numbers of files.  It's intended primarily for source code repositories, and
    respects files like @file{.gitignore} and @file{.hgignore}.  It's also an order
    of magnitude faster than its inspiration, @command{ack}, and less specialised
    tools such as @command{grep}.")
     (license license:asl2.0)))
#+END_SRC
上記のフィールドのほとんどは[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/][前回の記事]]と全く同様のため、詳細は省きますが、 =my-ag= という名前のパッケージを定義しています。
基本的に上記に示したフィールドは全て必須であるため、これをテンプレートとして穴埋めすることでパッケージを作るのが手っ取り早いです。

**** ビルドシステム
さて、今書いた中で最も大事なフィールドは =(build-system gnu-build-system)= です。
この変数の定義は =(guix build-system gnu)= というモジュールにあるので、このモジュールを =#:use-module= しておいてください。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages ag)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download)
    #:use-module (guix build-system gnu))
#+END_SRC

先程のフィールドでは、 =build-system= を =gnu-build-system= と指定しています。
この =gnu-build-system= は、実は正に =./configure && make && make install= の典型的なビルド手順を表しています
(詳細な仕様が知りたい方は[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Systems][公式マニュアル(英語)]]を参照)。

ただし、 =./configure && make && make install= をそのまま走らせているわけではないということに注意してください。
GNU Guixはその特性上 =/bin/= や =/lib/= の代わりに =/gnu/store/xxxxxxxxxxxxxxxxx-my-ag-2.2.0/bin/= や
=/gnu/store/xxxxxxxxxxxxxxxxx-my-ag-2.2.0/lib/= に生成物をインストールする必要があります。
そのため、 =./configure= にインストール先の接頭辞を指定する =--prefix= を付ける、などを行っています。
具体的な実装を見たい場合は、
GNU Guix公式レポジトリの[[https://git.savannah.gnu.org/cgit/guix.git/tree/guix/build/gnu-build-system.scm][guix/build/gnu-build-system.scm]]か[[https://git.savannah.gnu.org/cgit/guix.git/tree/guix/build-system/gnu.scm][guix/build-system/gnu.scm]]をご覧ください。
=#:use-module= したのは前者ですが、ビルド手順自体は主に後者に実装されています。

ビルドは具体的にどのような手順で行われるのでしょうか。これも[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Phases][公式マニュアル(英語)]]に記載されています。
=gnu-build-system= では以下のような手順で行われます。これらの各手順はフェイズ(phase)と呼ばれています。
なお、他のビルドシステムも大抵は =gnu-build-system= を継承して作られているため、似たような流れになります。
また、ソースのダウンロード自体はビルドシステムが走るよりも前に行われており、
ビルドシステムが走る環境は外のネットワークには一切繋がりません。
これはソースのハッシュ値が等しいことと成果物が等しいことを等価にするのに必要です
(ネットワークに繋がってしまうと、ソースコードが同じでもネットワーク経由の入力によって成果物が変わり得る)。
- =set-paths= :: ソースのダウンロードやビルドのための環境を用意するフェイズです。
  各種依存へパスを通したりします。
- =unpack= :: =source= に指定したソースコードのtarballやzipを展開し、ビルド用の環境へとコピーします。
- =patch-source-shebangs= :: シェルスクリプトのshebangを変更します。
  GNU GuixはFHSに従ったディレクトリ構造をしておらず、 =bash= や =sh= をも =/gnu/store/= 以下に閉じ込めているため、
  その位置をシェルスクリプトに伝えるべく =#!/bin/sh= や =#!/bin/bash= を
  =#!/gnu/store/xxxxxxxxxxxxx-bash-0.0/bin/sh= や =#!/gnu/store/xxxxxxxxxxxxx-bash-0.0/bin/bash= に置き換えます。
- =configure= :: =./configure= を実行します。先程述べたように、 =--prefix= 引数によってインストール先が変更されます。
  また、後述の =#:confiugre-flags= 引数によって追加のオプションを指定できます。
- =build= :: =make= を実行します。他のビルドシステムの場合でも、このフェイズで実際のビルドが走ることが多いです。
  なお、前述のとおり、ここではネットワークには一切繋がりません。
  そのため、外からダウンロードしてくる操作がビルドスクリプトに含まれていると失敗します。
  その場合、外からダウンロードしてくる操作自体をビルドスクリプトから取り除くか実行されないようにして、
  ダウンロードされてくる部分を別のパッケージとして定義し、それを依存としたパッケージを定義する必要があります。
  この作業はかなり大変です。後述の =#:phases= 引数を使ってこのフェイズ自体を一から書き直したり、
  [[https://guix.gnu.org/en/manual/devel/en/guix.html#index-substitute_002a][=substitute=]]マクロ(前述のバイナリ提供サーバーとしてのsubstituteとは無関係。 =#:phases= の詳細説明を参照)
  を使ってビルドスクリプトを修正するフェイズをビルド前に追加したりすることで対応することになります。
  ここはどうしてもアドホックになりがちなところです。
- =check= :: =make check= を実行します。後述の =#:tests?= 引数によって抑制できます。
- =install= :: =make install= を実行します。 =./configure= に渡された =--prefix= オプションにより、
  =/gnu/store/= 直下にある専用のインストール先にインストールされます。
- =patch-shebangs= :: =patch-source-shebangs= とほとんど同じです。
  今回はソースコードではなくインストールされた実行ファイルに適用されます。
- =strip= :: 生成されたバイナリからデバッグ情報を取り除きます。
  なにをしているのかをあまり気にすることはないのですが、このフェイズでたまにコケるので、
  その場合は後述の =#:strip-binaries?= 引数を =#f= とするとよいです。
- =validate-runpath= :: 生成されたバイナリの =RUNPATH= を確認し、依存するライブラリがきちんと存在するかどうかを検証します。
  このフェイズも引数を用いて飛ばすことは可能ですが、ここでコケるのはライブラリの依存が足りていない証拠なので、
  「足りない」と言われた依存を適宜追加してください。

**** 依存の解決
さて、ビルドシステムの説明も終わったことなので、先程書いたパッケージを一旦ビルドしてみましょう。
#+BEGIN_SRC scheme
  guix build -L /path/to/your/channel my-ag
#+END_SRC
すると、たくさんのビルドログの下のほうに、エラーが出るはずです。
実は、一番下を見てもあまり有用な情報は出てきません。なぜなら末尾のエラーはScheme及びGNU Guixがコケたことによるエラーだからです。
少し上に、コケた根本の原因、すなわちどこかのフェイズで実行された実際のコマンドのエラーのログがあるはずです。
今回は、以下のような =configure= フェイズのエラーが出ているはずです。
#+BEGIN_SRC
  configure: error: The pkg-config script could not be found or is too old.  Make sure it
#+END_SRC
これが出るのは正常です。 =ag= のビルドに必要な依存を一切入れていないからです。
[[https://github.com/ggreer/the_silver_searcher#building-a-release-tarball][agのREADMEのBuilding a Release tarball]]と[[https://github.com/ggreer/the_silver_searcher#building-master][Building master]]を読むと、以下が必要そうだとわかります。
- =automake=
- =pkg-config=
- =PCRE=
- =LZMA=
このうち  =automake= は =gnu-build-system= においては自動で利用可能になっているので、気にする必要はありません。
とりあえず、 =pkg-config= を依存として追加してみましょう。

依存は =package= オブジェクトに =inputs= フィールドや =native-inputs= として渡します(それらの違いは後述)。
渡す値は =package= オブジェクトのリストになります。
つまり、依存パッケージを格納している変数がどのモジュールで定義されているか知る必要があります。
パッケージの検索には =guix search= や =guix package -A= を使います。
=guix search= では説明文も含めて検索しますが、 =guix package -A= の場合はパッケージ名だけが検索の対象になります。
また、ブラウザでは[[https://packages.guix.gnu.org/][こちら]]で検索することも可能です。
#+BEGIN_SRC shell
  guix search pkg-config
#+END_SRC
結構たくさん候補が出てくるのですが、一番上に =pkg-config= というそのままのパッケージがあります。
ある特定のパッケージの情報だけを見たい場合は、 =guix show= を使います。
#+BEGIN_SRC shell
  guix show pkg-config
#+END_SRC
すると以下のような表示が得られます。
ブラウザの検索の場合は[[https://packages.guix.gnu.org/packages/pkg-config/0.29.2/][こちら]]をご覧ください。
#+begin_example
name: pkg-config
version: 0.29.2
outputs:
+ out: everything
systems: x86_64-linux i686-linux
dependencies:
location: gnu/packages/pkg-config.scm:37:2
homepage: https://www.freedesktop.org/wiki/Software/pkg-config
license: GPL 2+
synopsis: Helper tool used when compiling applications and libraries
description: pkg-config is a helper tool used when compiling applications and libraries.  It helps you insert the correct compiler options on the command
+ line so an application can use gcc -o test test.c `pkg-config --libs --cflags glib-2.0` for instance, rather than hard-coding values on where to find glib
+ (or other libraries).  It is language-agnostic, so it can be used for defining the location of documentation tools, for instance.
#+end_example
=location= が =gnu/packages/pkg-config.scm= となっていることから、このパッケージは =(gnu packages pkg-config)= モジュールに定義されていることがわかります。
行数は現時点でのものなので今後変更されているかもしれません。念のため定義を見ておきましょう。locationはブラウザでもコマンドラインでもリンクになっています。
公式レポジトリでいうと[[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/pkg-config.scm#n37][こちら]]になります。そこには以下のような定義が書いてあります。
#+BEGIN_SRC scheme
  ;; This is the "primitive" pkg-config package.  People should use `pkg-config'
  ;; (see below) rather than `%pkg-config', but we export `%pkg-config' so that
  ;; `fold-packages' finds it.
  (define-public %pkg-config
    (package
     (name "pkg-config")
     (version "0.29.2")
     ...))
#+END_SRC
どうやら変数自体は =%pkg-config= だけど、普通に =pkg-config= を使ってくれと書いてあります。
今回の場合は該当しませんが、変数名とパッケージ名は異なる場合がたまにあるので、このように確認する作業が必要になります。

さて、どのモジュールのどの変数に =pkg-config= のパッケージが保存されているかわかったので、それを依存に入れていきます。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (native-inputs
       (list pkg-config))
      ...))
#+END_SRC
=native-inputs= は「ビルドを行うプラットフォームで必要なパッケージ」を指定します。
実はGNU Guixは今いるプラットフォームとは別のプラットフォーム用のパッケージをビルドする機能があります。
「ビルドには必要だけど実際使うときにはいらないパッケージ」と捉えていただいて構いません。
一方 =inputs= は実行時にも必要な依存を記述します。なお、 =propagated-inputs= というものも存在します。
=propagated-inputs= に指定された依存は親パッケージをインストールすると一緒にインストールされます。

さて、これで再びビルドしてみましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel my-ag
#+END_SRC
すると、以下のようなエラーが得られます。
#+begin_example
ice-9/eval.scm:223:20: In procedure proc:
error: pkg-config: unbound variable
hint: Did you forget `(use-modules (gnu packages pkg-config))'?
#+end_example
そういえば、 =pkg-config= が定義されているモジュール =(gnu packages pkg-config)= を指定していませんでしたね。
このようにモジュールを指定せずに変数を使ってしまっても、かなりの確率で教えてくれます。
勘で依存パッケージの変数を書いてビルドして、ヒントでどこにあるか確認するという横着もできてしまいます(私もけっこうやる)。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages ag)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download)
    #:use-module (guix build-system gnu)
    #:use-module (gnu packages pkg-config))
#+END_SRC

これでもう一度ビルドしましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel my-ag
#+END_SRC
今度は最初とは別のエラーが =configure= フェイズで出ています。
#+begin_example
configure: error: Package requirements (libpcre) were not met:

No package 'libpcre' found
#+end_example
先程言ったように、  =PCRE= が依存として必要でした。他にも =LZMA= が必要とのことだったので、一気に解決を試みましょう。

先程と同様に =guix search= やブラウザでの検索を行うと、 =pcre= は =(gnu packages pcre)= モジュールにある =pcre= という変数に束縛されたパッケージに
あるとわかります。ここでは詳細を省きます。 =pkg-config= のときと全く同じなので、是非実際に試してみてください。

=LZMA= についても同様に検索しますが、どうも =lzma= という名前のパッケージはないようです。
これでは埒があかないので、とりあえずビルドして =./configure= がどんなエラーを吐くか見てみましょう。
=(gnu packages pcre)= モジュールを =use-module= しつつ、以下のようにパッケージ定義を変更しましょう。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (native-inputs
       (list pkg-config))
      (inputs
       (list pcre))
      ...))
#+END_SRC
依存として =inputs= に =PCRE= を追加しました。ビルドしてみましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel my-ag
#+END_SRC
すると以下のようなエラーが =build= フェイズで得られます。 =configure= フェイズはどうやら正常に通ったようです。
#+begin_example
  src/zfile.c:63:9: error: unknown type name ‘z_stream’
     63 |         z_stream gz;
        |         ^~~~~~~~
  (後略)
#+end_example
ここからはGNU Guixに限った話ではなく、ただただビルドを通るまで依存を追加していく作業になります。
幸い =z_stream= でググると =zlib= の話が大量に出てくるので、 =zlib= に定義されていることがすぐわかります。
また、もう一度基本に戻って[[https://github.com/ggreer/the_silver_searcher#building-master][公式のビルド手順]]を見てみると、Fedoraにおける依存解決のしかたが書いてあります。
#+BEGIN_SRC shell
  yum -y install pkgconfig automake gcc zlib-devel pcre-devel xz-devel
#+END_SRC
どうも、ここでも =zlib= が必要なことがわかります。(もうひとつ =xz= というのも入っていますが、とりあえず無視しておきます。)
GNU Guixでのビルド方法の情報は少ないため、このような他のディストロの情報を利用するのも大切です。

先程と同じように =zlib= というパッケージを探し出していきます。
ここも詳細は省きますが、 =(gnu packages compression)= モジュールに =zlib= が定義されています。
=#:use-module= しつつまた依存を追加していきます。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (native-inputs
       (list pkg-config))
      (inputs
       (list pcre zlib))
      ...))
#+END_SRC
ここでビルドすると、 =build= フェイズの最後に行うリンクでコケます。
#+begin_example
    CCLD     ag
  ld: src/log.o:/tmp/guix-build-my-ag-2.2.0.drv-0/the_silver_searcher-2.2.0/src/log.h:12: multiple definition of `print_mtx'; src/ignore.o:/tmp/guix-build-my-ag-2.2.0.drv-0/the_silver_searcher-2.2.0/src/log.h:12: first defined here
  ld: src/log.o:/tmp/guix-build-my-ag-2.2.0.drv-0/the_silver_searcher-2.2.0/src/util.h:15: multiple definition of `out_fd'; src/ignore.o:/tmp/guix-build-my-ag-2.2.0.drv-0/the_silver_searcher-2.2.0/src/util.h:15: first defined here
  (後略)
#+end_example
=ag multiple definition of= で検索してみると、どうやら [[https://github.com/ggreer/the_silver_searcher/issues/1378][=ag= 自体のバグ]]なようです。そこの説明文をみるに、
GCC-10(=gnu-build-system= で利用されるデフォルトのGCCのバージョンは2022/12/7現在では10です)では
=./configure= に ~CFLAG=-fcommon~ を付けないと動かないとのこと。このような場合、どうすればよいでしょうか。

実は「ビルドシステム」というのは引数を取ることができます。
引数は =package= のフィールドとして直接与えます。つまり以下のように書きます。
#+BEGIN_SRC scheme
  (define-public example
    (package
     (name "example")
     (version "0")
     ...
     (arguments
      '(#:tests? #f
        #:configure-flags '("--some-option" "--other-option")))
     (build-system gnu-build-system)
     ...))
#+END_SRC
使用するビルドシステムによって取れる引数は異なりますが、
ほとんどのビルドシステムは =gnu-build-system= を継承して作られているため、代表的なものは他のビルドシステムでも
利用できます。折角なのでいくつか紹介しておきます。[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Systems][公式マニュアル(英語)]]で一覧を見ることができます。
- =#:configure-flags= :: =./configure= に渡されるオプションを文字列のリストで渡します。
  典型的にはオプションの機能をオンにしたりオフにしたりするのに使います。
- =#:make-flags= :: =make= 、 =make check= 、 =make install= に渡されるオプションを文字列のリストで渡します。
  あまり利用頻度は多くないです。
- =#:tests?= :: テスト(=make check=)をするかどうか、すなわち =check= フェイズを行うかどうか真偽値で渡します。
  デフォルトでは =#t= (Schemeにおけるtrue)となっていて、
  ネットワークがないとテストが通らない場合やそもそもテストがない場合には
  =#f= (Schemeにおけるfalse)を指定してテストをしないようにします。
- =#:strip-binaries?= :: 生成されたバイナリからデバッグ情報を取り除くかどうか、
  すなわち =strip= フェイズを行うかどうかを真偽値で渡します。
- =#:phases= :: この引数が最も柔軟にビルド内容を変更できます。
  具体的には、ビルドプロセスの1手順(phase)をまるっと別のものに入れ替えたり、ある手順の前や後ろに別の手順を追加したりできます。
  詳細の書き方を以下に置いておきますが、かなり難しい内容になっているため、一旦飛ばしても構いません。

#+begin_details
#+begin_summary
=#:phases= 引数を利用するための詳細な説明
#+end_summary
各フェイズ自体もSchemeで書かれているため、無名関数を与えるだけで新しいフェイズを与えることができます。
この引数として与える式は、ほとんどが =(modify-phases %standard-phases ...)= という形です。
=%standard-phases= というのは =build-system= を経由して与えられるフェイズ群で、
これを修正した新しいフェイズ群を与えることでフェイズの変更を達成しています。

=(modify-phases %standard-phases ...)= のうち =...= の部分には以下の4つをいくつでも書くことができます。
- =(delete 'phase-name)= :: =phase-name= という名前のフェイズを削除します。
- =(replace 'old-phase-name 無名関数)= :: =old-phase-name= という名前のフェイズを新しいフェイズに置き換えます。
- =(add-before 'base-phase-name 'new-phase-name 無名関数)= ::
  =base-phase-name= という名前のフェイズの前に =new-phase-name= という名前の新しいフェイズを追加します。
- =(add-after 'base-phase-name 'new-phase-name 無名関数)= ::
  =base-phase-name= という名前のフェイズの後に =new-phase-name= という名前の新しいフェイズを追加します。
無名関数は新しいフェイズの定義になります。
無名関数はキーワード引数を受け取ります。
受け取れる引数は =#:make-flags= などの各種引数と、 =inputs= や =outputs= といった連想リストです。
=inputs= は、キーを依存の名前、値を依存として与えられたディレクトリ(読取専用)へのパスとした連想リストです。
=outputs= は、キーを出力の名前(普通に定義したパッケージは"out"のみをキーとする)、
値を出力先(インストール先)のディレクトリへのパスとした連想リストです。
これらを用いることで、新しいフェイズから依存のディレクトリやインストール先のディレクトリを直接触ることができます。
たとえばデフォルトの出力先である"out"に対応するディレクトリを取り出す場合は、 =(assoc-ref outputs "out")= とします。

以下に例を示します。この例は[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Phases][公式マニュアル(英語)]]からの引用です。
#+BEGIN_SRC scheme
  (define-public example
    (package
      (name "example")
      ;; other fields omitted
      (build-system gnu-build-system)
      (arguments
       '(#:phases (modify-phases %standard-phases
                    (delete 'configure)
                    (add-before 'build 'set-prefix-in-makefile
                      (lambda* (#:key outputs #:allow-other-keys)
                        ;; Modify the makefile so that its
                        ;; 'PREFIX' variable points to "out".
                        (let ((out (assoc-ref outputs "out")))
                          (substitute* "Makefile"
                            (("PREFIX =.*")
                             (string-append "PREFIX = "
                                            out "\n")))))))))))
#+END_SRC
この例では2つのフェイズ修正を行っています。
一つ目は =(delete 'configure)= による =configure= フェイズの削除です。
二つ目は =(add-before 'build 'set-prefix-in-makefile ...)= による新しいフェイズの追加です。

Schemeでキーワード引数を受け取る無名関数を作りたい場合、
=(lambda* (#:key key1 key2 #:allow-other-keys) ...)= のように書きます。
特に =#:allow-other-keys= は必要のないキーワード引数を受け取ってもエラーにならないようにするもので、
フェイズのようにどんな引数が渡されるかわからないような状況では便利です。

今回受け取って引数として束縛するキーワード引数は =outputs= だけです。
前述のようにここには連想リストが束縛されています。
その後、 =let= 節を用いて =(assoc-ref outputs "out")= すなわちインストール先のディレクトリへのパスを
=out= 一時変数に束縛しています。
さらにその後 =substitute*= マクロを使っています。
このマクロは、第一引数に与えられたファイルにおいて、第二引数以降で指定された置換を実行します。
第二引数以降は =((regexp...) body...)= の形を取っていて、 =(regexp...)= には置換したい対象を表す正規表現のリストを、
=body= は順次評価したときに最後の評価結果が置換後の文字列になるようなS式群を表しています。
これにより =Makefile= の中にある 「PREFIX=.*」にマッチする文字列すべてが、
「PREFIX=パッケージにおけるインストール先のディレクトリの絶対パス」へと置き換わります。

=arguments= として与えられたリストはクオートされていることに注意してください。
すなわち、 *今の無名関数を含めた =arguments= 下にあるS式は、現環境では評価されません。*
これがなにを意味するかというと、現在のモジュールで =#:use-module= 宣言をいくらしたところで、
さきほどの無名関数からそのモジュールの機能には一切アクセスできません。
なぜなら各 =arguments= が評価される環境は現在のモジュールを定義した環境ではなく、
=guix= がパッケージをビルドしようとしたときの環境だからです。
もしなんらかのモジュールを無名関数で利用したい場合、
無名関数の中で =use-modules= マクロを呼び出すことであらためてモジュールの使用を宣言してください。
以下は =(ice-9 match)= モジュールと =(srfi srfi-26)= モジュールを無名関数の中で使う場合の例です。
#+BEGIN_SRC scheme
  (lambda* (#:key outputs #:allow-other-keys)
   (use-modules (ice-9 match)
                (srfi srfi-26))
   ...)
#+END_SRC
#+end_details

つまり、今回の場合は =#:configure-flags= として ~CFLAG=-fcommon~ が与えられればよいわけです。
つまり以下のように書きます。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (arguments
       '(#:configure-flags (list "CFLAGS=-fcommon")))
      ...))
#+END_SRC
この状態で再びビルドしてみましょう。

すると、エラーが全く出ずに最後まで実行できました。ビルド成功です。しかしまだ喜んではいけません。
それがインストールされた環境へ入って実行してみましょう。今回は =--pure= でも =--container= でも構いません。
#+BEGIN_SRC shell
  guix shell --pure -L /path/to/your/channel my-ag
#+END_SRC
たとえば今作っていたチャンネルのディレクトリに入り、 =ag home-page= と実行してみましょう。
すると、我々が今作成したパッケージや、前回の記事で作ったフォントのパッケージの =home-page= フィールドがきちんとみつけられました。
きちんと動いています。

#+begin_details
#+begin_summary
=xz= について
#+end_summary

先程見た[[https://github.com/ggreer/the_silver_searcher#building-master][公式のビルド手順]]には、Fedoraにおける依存解決のしかたが書いてありました。
#+BEGIN_SRC shell
  yum -y install pkgconfig automake gcc zlib-devel pcre-devel xz-devel
#+END_SRC
ここには、 =xz= というみたことのない依存を入れています。
なくても動きますが、[[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/code.scm#n338][公式のチャンネル]]の定義では入れています。
せっかくなので =xz= を入れていきましょう。

まずは、 =xz= を検索してみます。今度は =guix package -A= を使ってみましょう。
#+BEGIN_SRC shell
  guix pacakge xz
#+END_SRC
すると以下のようなリストが得られます。
#+begin_example
  java-xz             	1.9  	out       	gnu/packages/java-compression.scm:288:2
  pixz                	1.0.7	out       	gnu/packages/compression.scm:1059:2
  rust-xz2            	0.1.6	out       	gnu/packages/crates-io.scm:67762:2
  xz                  	5.2.5	out,static	gnu/packages/compression.scm:509:2
  xzgv                	0.9.2	out       	gnu/packages/image-viewers.scm:983:2
#+end_example
ずばり =xz= という名前のパッケージがあるので、これを使うとよさそうです。
=guix show xz= で詳細情報も確認しておくと確実です(LZMAに触れられています)。
モジュールは =zlib= と同様なので新しく =use-module= する必要はなさそうです。
変数名もそのまま =xz= であることを確認し、依存として =inputs= に =xz= も追加します。
#+BEGIN_SRC scheme
  (define-public my-ag
    (package
      (name "my-ag")
      ...
      (native-inputs
       (list pkg-config))
      (inputs
       (list pcre zlib xz))
      ...))
#+END_SRC
これでも同様に動きますが、動作に必要あるかは不明です(もしかしたら =xz= がないと特定の機能だけ動かない可能性もある)。
#+end_details

** =guix import= で手抜きできる場合がある
ビルドが必要なパッケージの定義を実際に行っていきました。それなりに大変だったと思います。
使いたいパッケージの度にこれを行うのは億劫だという人もいると思います。
実は、比較的簡単にパッケージを定義できる場合があります。それは、 =guix import= が利用できる場合です。

=guix imort= は、インポーターというものを使って自動でパッケージ定義を書く機能です。
インポーターの一覧など、詳しくは[[https://guix.gnu.org/en/manual/devel/en/guix.html#Invoking-guix-import][公式マニュアル(英語)]]にありますが、例えば以下のようにしてパッケージを生成できます。
#+BEGIN_SRC shell
guix import go gopkg.in/yaml.v2 --recursive
#+END_SRC
=go= というのがインポーターを表していて、[[https://proxy.golang.org/]]からメタデータを取得することでパッケージ定義を生成します。
=--recursive= は依存を再帰的に辿ってパッケージ定義を生成するオプションで、付けないと依存が足りずにビルドがコケます。
また、デフォルトでは標準出力に定義を吐くため、ファイルにでも流しこんでください。
モジュール定義 や =#:use-module= は行ってくれないので、自分で行ってください。

もちろん =guix import= だけで全てのパッケージ定義を賄うことはできないですし、これを用いてもビルドが失敗することはあります。
それでも、依存先のパッケージなども含めて一気に定義できるのは有用ですし、
ビルドが失敗しても今回の記事のようにビルドを成功へ導いてあげればよいです。
是非利用してみてください。

** 最後に
今回の記事では、ビルドの必要なパッケージ定義を扱いました。
これをマスターすればあなたも =guix= の玄人です。

前回とおなじ締めですが、もしなにか質問などあれば、コメントなりメールなりで受け付けます。
また、Guixの日本語コミュニティである[[https://guix-jp.gitlab.io/][Guix-jp]]もあります。
そちらには私以上のエキスパートの人がいますので、是非そちらもご興味あれば覗いてみてください。

次回の記事は[[https://blog.rocktakey.com/information-science/2022-6353e393-4e0b-6ad4-754b-0d84ebd31c97/][こちら]]になります。

* DONE Guixのパッケージをつくってみよう-その3: どうしてもビルドできないときはバイナリを直接使ったパッケージを作る
CLOSED: [2022-12-11 Sun 04:20]
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-6353e393-4e0b-6ad4-754b-0d84ebd31c97
  :EXPORT_HUGO_TAGS: GNU-Guix Scheme nonguix
  :END:
[[https://qiita.com/advent-calendar/2022/guix][https://img.shields.io/badge/GNU%20Guix%20Advent%20Calendar%202022-7%E6%97%A5%E7%9B%AE-d60a34.svg?style=flat-square&logo=qiita]]

** 序文
[[https://blog.rocktakey.com/information-science/2022-c5b823db-a6b6-23a4-5783-c7741fd0f420/][前回の記事]]では、ビルドを伴うパッケージの作成を行いました。
しかし、どうしてもビルドがうまくいかないこともあります。
特に前回触れたインポーターがまだない他の既存パッケージマネージャで管理されたソフトウェアや、
そもそもインポーターが介在する余地のないような独自のビルド手順を持つソフトウェアなどで、
まだGNU Guixの公式チャンネルに実装されていない依存が大量にある場合には、
多大な労力が必要になります。
さらに言うと、我々が利用しているソフトウェアはソースが公開されているとは限りません。
そのようなプロプライエタリなソフトウェアをソースコードからビルドすることは当然不可能です。
このような場合、GNU Guixでソフトウェアの管理を行うことは不可能なのでしょうか。

上記の話への回答は二つあります。
GNU Guix(というよりGNUプロジェクトやFSFかも)の哲学に基づいて話すならば、
「プロプライエタリなソフトウェアは使うべきではないし、ビルドしないという選択肢はない」です。
彼等は自由ソフトウェア原理主義です。
ソースコードが公開されておらず、中でなにをしているかわからないような自由でないソフトウェアは利用するべきではないと考えています。
同様な理由で、自分でビルドしていないバイナリは本当に公開されているソースコードからビルドされたものかわからないから信用するべきではない、
ということになります。

私も自由ソフトウェアはよいものだと思っていますが、現実的にプロプライエタリなソフトウェアをただちに排除することは不可能ですし、
たとえばインターネットを介して他人と競うようなゲームではコードの公開は不正に直結するでしょう。

実際自由ソフトウェアしか利用できないのは不便なので、[[https://gitlab.com/nonguix/nonguix][Nonguix]]というコミュニティ及びチャンネルが存在します。
このチャンネルでは不自由なソフトウェアやドライバが配信されています。
これは非公式のものであり、GNUの哲学に反するものです。
そのため、Nonguixはこのチャンネルは不自由なソフトウェアを推奨するものではないこと、
IRCやメーリングリストなどの公式のGNU Guixコミュニケーションでは宣伝しないこと、とREADMEに書いています。
言及自体を避けるものではないですが、GNUの哲学を尊重しましょうねという形です。
このあたりのポリシーはコミュニティによって異なりますが、
GNU直属のコミュニティではかなり厳格なので注意して発言する必要があります。

このような経緯で、不自由なソフトウェアやドライバGNU Guixを扱うノウハウはすべてNonguixに集まっています。
しかし、Nonguixは使い始めるための最低限のドキュメント(READMEにあるものが全て)しかありません。
パッケージを利用するだけならチャンネルを登録するだけなので簡単ですが、
不自由なソフトウェアのパッケージ(つまりバイナリを直接インストールするパッケージ)を作る知識を得るには
Nonguixの他のパッケージ定義を真似るしかありません。

そこで、ここでは、バイナリを直接インストールするパッケージの作り方を解説していきます。
前回や前々回の記事とは違ってきちんとしたドキュメントに基づいているわけではなく、
私も見様見真似でやっているところがあるので、説明が間違っている可能性が前の記事たちよりも少し高くなっていることにご留意ください。

** Nonguixチャンネルを登録する(Nonguixチャンネルの提供するパッケージを利用したい場合のみ)
先に、Nonguixのパッケージを利用する方法を述べておきます。
この章の操作はNonguixのパッケージを利用するのには必要ですが、
Nonguixの提供するビルドシステムを利用したパッケージを自分で作りたい場合には不要です
(そのような場合は後述するようにチャンネルに依存を書く必要があるが、ユーザー側は明にチャンネルを登録する必要はない)。

[[https://gitlab.com/nonguix/nonguix/][NonguixのREADME]]にあるのと似たように、以下を =~/.config/guix/channels.scm= に書きます。
#+BEGIN_SRC scheme
  (cons* (channel
          (name 'nonguix)
          (url "https://gitlab.com/nonguix/nonguix")
          ;; Enable signature verification:
          (introduction
           (make-channel-introduction
            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
            (openpgp-fingerprint
             "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
         ;; 前回つくったチャンネルはここに
         (channel
          (name 'your-channel-name)
          (url "<your-channel-URL>"))
         ;; その他のチャンネルを登録したい場合も続けて書ける
         %default-channels)
#+END_SRC
今まで書いてきたものと違い、 =introduction= フィールドがあります。
この =introduction= フィールドには署名が書かれています。
[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/#source%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89][前の記事]]で言及したハッシュ値の検証と意味合いとしては近く、
偽物のチャンネルを掴まされても偽物だと気付けるようになっています。
詳しくは[[https://guix.gnu.org/en/manual/devel/en/guix.html#Channel-Authentication][公式のマニュアル(英語)]]をご覧ください。

** バイナリからインストールするパッケージを作成する
この章では、バイナリから直接インストールするパッケージを作成していきます。
例として、[[https://github.com/latex-lsp/texlab][texlab]]という言語サーバーについてのパッケージを作成します。

*** 自分のチャンネルに依存チャンネルを追加する
チャンネルの宣言は、チャンネル直下の =.guix-channel= に以下のように書いていました。
#+BEGIN_SRC scheme
  (channel
   (version 0)
   (url "<your-channel-URL>"))
#+END_SRC
今回はNonguixの提供するビルドシステムを利用したいので、チャンネルにNonguixへの依存を追加します。
#+BEGIN_SRC scheme
  (channel
   (version 0)
   (url "<your-channel-URL>")
   (dependencies
    (channel
     (name nonguix)
     (url "https://gitlab.com/nonguix/nonguix")
     ;; Enable signature verification:
     (introduction
      (make-channel-introduction
       "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
       (openpgp-fingerprint
        "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))))
#+END_SRC
=dependencies= フィールドが追加されています。
ここに依存するチャンネルを書いていきます。
基本的には前節のチャンネル追加と同じものですが、1点だけ注意事項として、 =name= フィールドにクオート ='= がありません。
前節のチャンネル追加では =(name 'nonguix)= としましたが、依存の追加では =(name nonguix)= となっています。
このようになっている理由は不明ですが、ハマりすいので注意してください。

*** パッケージを定義する
前回同様、モジュールやパッケージ定義の雛形を最初に書きます。
あらかじめ埋めておいたものを以下に示しますが、
以下のフィールドは[[https://blog.rocktakey.com/information-science/2022-c5b823db-a6b6-23a4-5783-c7741fd0f420/][前回]]や[[https://blog.rocktakey.com/information-science/2022-770eb4b6-5c63-62d4-bbcb-475d92404603/][前々回]]の記事ですべて解説しているので、余力があれば自分で書いてみてください。
ファイルは =your-channel-name/packages/texlab.scm= としましょう。
#+BEGIN_SRC scheme
  (define-module (your-channel-name packages texlab)
    #:use-module (guix packages)
    #:use-module ((guix licenses) #:prefix license:)
    #:use-module (guix download))

  (define-public my-texlab
    (package
     (name "my-texlab")
     (version "4.3.0")
     (source
      (origin
       (method url-fetch)
       (uri (string-append
             "https://github.com/latex-lsp/texlab/releases/download/v"
             version
             "/texlab-x86_64-linux.tar.gz"))
       (sha256
        (base32
         "0xrn9392yw7vy6f7yhbb37xm60igy5fv0mip4qgyzq5kfa3ni182"))))
     (synopsis "An implementation of the Language Server Protocol for LaTeX")
     (description
      "Language Server providing rich cross-editing support for the LaTeX typesetting system.
  The server may be used with any editor that implements the Language Server Protocol.")
     (home-page "https://github.com/latex-lsp/texlab")
     (license license:gpl3)))
#+END_SRC
名前は将来衝突した場合に混乱の元にならないよう =my-texlab= にしました。
この記事がチュートリアル的な構成をとっているためにこのような変な命名を行っていますが、
自分のチャンネルで実際にパッケージを定義をする場合は一般的な名前を付けても構いません。

さて、今回ダウンロードしてくるファイルを展開したものはバイナリです。
実際に展開して見てみましょう。
#+BEGIN_SRC shell
  wget https://github.com/latex-lsp/texlab/releases/download/v4.3.0/texlab-x86_64-linux.tar.gz
  tar xvf texlab-x86_64-linux.tar.gz
#+END_SRC
すると、現在いるディレクトリに =texlab= というファイルが生成されています。
つまりディレクトリではなく、ファイルが直に圧縮されていることがわかります。
このバイナリをそのままインストールするには、 =binary-build-system= を用います。
#+BEGIN_SRC scheme
  (define-public my-texlab
    (package
     ...
     (build-system binary-build-system)
     ...))
#+END_SRC
このビルドシステムは =(nonguix build-system binary)= に定義されているので、 =#:use-module= しておきましょう。

バイナリを直接コピーしてインストールするためには、
当然「どのファイルをどこに配置するか」という情報を与える必要があります。
そのような情報を =binary-build-system= に与えるには、 =#:install-plan= 引数を用います。
この引数は ='(("source/filename" "/output/filename") ...)= のような値を取ります。
="source/filename"= でダウンロードしたファイルを指定し、出力ディレクトリの ="/output/filename"= にコピーします。
ここで指定するファイルは、ディレクトリでも構いません。
それぞれの末尾にスラッシュが付いているかによって、コピーをよしなにしてくれます。
末尾にスラッシュを付けると中身をそれぞれ個別に指定しているような意味になります。
どのような組み合わせでどのようなコピーの仕方を得られるのかについての詳細は[[https://guix.gnu.org/en/manual/devel/en/guix.html#Build-Systems][公式マニュアル(英語)]]の
=copy-build-system= を参照ください(=binary-build-system= は =copy-build-system= を継承しています)。

たとえば今回の場合、単ファイル =texlab= を =/bin/= の中へとコピーすればよいので、以下のようになります。
末尾のスラッシュを忘れた場合(=("texlab" "/bin")=)、
=texlab= というファイルを =bin= という名前にした上でルートディレクトリ =/= に置く、という指定になってしまいます。
#+BEGIN_SRC scheme
  (define-public my-texlab
    (package
     ...
     (build-system binary-build-system)
     (arguments '(#:install-plan
                  '(("texlab" "/bin/"))))
     ...))
#+END_SRC

さて、このパッケージをビルドしてみましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel/ my-texlab
#+END_SRC
すると、ログの末尾で以下のようなエラーが出ると思います。
#+begin_example
  starting phase `validate-runpath'
  validating RUNPATH of 1 binaries in "/gnu/store/wsacmf19wa4xdvniwza1vlrbhl3fk6jq-my-texlab-4.3.0/bin"...
  /gnu/store/wsacmf19wa4xdvniwza1vlrbhl3fk6jq-my-texlab-4.3.0/bin/texlab: error: depends on 'libgcc_s.so.1', which cannot be found in RUNPATH ()
  /gnu/store/wsacmf19wa4xdvniwza1vlrbhl3fk6jq-my-texlab-4.3.0/bin/texlab: error: depends on 'ld-linux-x86-64.so.2', which cannot be found in RUNPATH ()
  error: in phase 'validate-runpath': uncaught exception:
  misc-error #f "RUNPATH validation failed" () #f
  phase `validate-runpath' failed after 0.0 seconds
  Backtrace:
             8 (primitive-load "/gnu/store/z4gvf8acdds19bphq0sq4bd768l…")
  In guix/build/gnu-build-system.scm:
      906:2  7 (gnu-build #:source _ #:outputs _ #:inputs _ #:phases . #)
  In ice-9/boot-9.scm:
    1752:10  6 (with-exception-handler _ _ #:unwind? _ # _)
  In srfi/srfi-1.scm:
      634:9  5 (for-each #<procedure 7ffff6043080 at guix/build/gnu-b…> …)
  In ice-9/boot-9.scm:
    1752:10  4 (with-exception-handler _ _ #:unwind? _ # _)
  In guix/build/gnu-build-system.scm:
     927:23  3 (_)
     568:10  2 (validate-runpath #:validate-runpath? _ # _ #:outputs _)
  In ice-9/boot-9.scm:
    1685:16  1 (raise-exception _ #:continuable? _)
    1685:16  0 (raise-exception _ #:continuable? _)

  ice-9/boot-9.scm:1685:16: In procedure raise-exception:
  RUNPATH validation failed
  builder for `/gnu/store/db0x0apr340mjxc6z85dx09ra62k92ld-my-texlab-4.3.0.drv' failed with exit code 1
  build of /gnu/store/db0x0apr340mjxc6z85dx09ra62k92ld-my-texlab-4.3.0.drv failed
  View build log at '/var/log/guix/drvs/db/0x0apr340mjxc6z85dx09ra62k92ld-my-texlab-4.3.0.drv.gz'.
  guix build: error: build of `/gnu/store/db0x0apr340mjxc6z85dx09ra62k92ld-my-texlab-4.3.0.drv' failed
#+end_example
見ての通りですが、かなり複雑で長いエラーメッセージが出ます。
これはGNU Guix自体がGNU Guileという処理系で動いており、Guixの吐くエラーとGuileの吐くエラーとが両方表示されているためです。
前半はGuixの吐くエラー、後半はGuileの吐くエラーです。
Guileの出すエラーはScheme処理系自体のバックトレースでしかなく、パッケージのビルド過程そのものの情報はあまりありません。
そのため、基本的には前半のエラーを読んでいくことになります。

前半の部分を抜き出すと、以下のようになります。
#+begin_example
  /gnu/store/wsacmf19wa4xdvniwza1vlrbhl3fk6jq-my-texlab-4.3.0/bin/texlab: error: depends on 'libgcc_s.so.1', which cannot be found in RUNPATH ()
  /gnu/store/wsacmf19wa4xdvniwza1vlrbhl3fk6jq-my-texlab-4.3.0/bin/texlab: error: depends on 'ld-linux-x86-64.so.2', which cannot be found in RUNPATH ()
#+end_example
=RUNPATH= というのはバイナリに含まれている情報で、依存する共有ライブラリを探すときにどのディレクトリの中を探すか、保持しています。
GNU GuixはFHSという標準的なディレクトリ構成から逸脱しているため、この =RUNPATH= をあらかじめ書き換えておかないと、
依存する共有ライブラリを見つけることができません。
このエラーは、「 =texlab= バイナリは =libgcc_s.so.1= 及び =ld-linux-x86-64.so.2= という二つの共有ライブラリに依存しているけど、
=RUNPATH= の中を探してもそんなファイルないよ？」ということを表しています。
行末の =()= には本来パスが入るのですが、 =RUNPATH= を一切設定していないので空になっています。

=RUNPATH= を書き換えるには、 =#:patchelf-plan= という引数を用います。例を見せたほうがわかりやすいと思うので、以下に示します。
#+BEGIN_SRC scheme
  (define-public my-texlab
    (package
     ...
     (arguments '(#:install-plan
                  '(("texlab" "/bin/"))
                  #:patchelf-plan
                  '(("texlab" ("glibc")))))
     (inputs
      (list glibc))
     ...))
#+END_SRC
=#:patchelf-plan= には ='(("binary-filename" ("input1" "input2" ...)))= のような値を与えます。
="binary-filename"= は =RUNPATH= を変更したいバイナリファイル、
="input1"= や ="input2"= には =RUNPATH= に追加したいディレクトリを保持するパッケージの名前を書きます。
すなわち、共有ライブラリを提供しているパッケージを指定すればよいです。
もちろん、 =#:patchelf-plan= に指定するパッケージは =inputs= に指定する必要があります。

上記の例では、 =glibc= を =inputs= に指定し、 =#:patchelf-plan= によって =texlab= の =RUNPATH= に追加しました。
=glibc= は =ld-linux-x86-64.so.2= を提供します。
さて、 =glibc= を提供するモジュール =(gnu packages base)= を =#:use-module= した上で、ビルドしてみましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel/ my-texlab
#+END_SRC
すると、以下のようなエラーが見られます。
#+begin_example
  /gnu/store/2ga0imdyrgq5miqysvry8fbphjh4w4ky-my-texlab-4.3.0/bin/texlab: error: depends on 'libgcc_s.so.1', which cannot be found in RUNPATH ("/gnu/store/ayc9r7162rphy4zjw8ch01pmyh214h82-glibc-2.33/lib")
#+end_example
まず、行末の =RUNPATH ()= の中に =glibc= のパスが追加されています。
さらに、 =RUNPATH= を追加したことで、さきほど出ていた =ld-linux-x86-64.so.2= についてのエラーが解消されています。

次に、 =libgcc= についてのエラーを解消します。 =libgcc= は =gcc= のうち ="lib"= 出力で提供されています。
この言い回しははじめてかもしれません。
通常のパッケージは =out= 出力に書き込まれますが、ドキュメント部分やライブラリ部分がそれぞれ大きすぎて1つのパッケージにするのは不便な場合があります。
そのような場合のために、 =doc= 出力や =lib= 出力など、複数の出力を持てるようになっています。
なにも指定せずにインストールすれば =out= 出力だけがインストールされ、必要な人だけが別途 =lib= や =doc= などの別の出力をインストールできるようになっています。
コマンドラインからインストールする場合、 =gcc:lib= のようにコロン区切りで出力の種類を指定できます。

=inputs= で依存として指定する場合は、以下のように出力を指定できます。
#+BEGIN_SRC scheme
  (inputs
   (list
    glibc
    (list gcc "lib")
    ;; `(,gcc "lib") でも同義
    ))
#+END_SRC
つまり、 =inputs= に与えるリストの各要素は、パッケージ定義そのものだけでなく
「第一要素がパッケージ定義、第二要素が出力を表す文字列」のリストも用いることができます。

=#:patchelf-plan= に与えるパッケージ名は、単にパッケージ名で構いません。すなわち、以下のようになります。
#+BEGIN_SRC scheme
  (define-public my-texlab
    (package
     ...
     (arguments '(#:install-plan
                  '(("texlab" "/bin/"))
                  #:patchelf-plan
                  '(("texlab" ("glibc"
                               "gcc")))))
     (inputs
      (list
       glibc
       (list gcc "lib")))
     ...))
#+END_SRC

さて、 =gcc= を提供するモジュール =(gnu packages gcc)= も =#:use-module= した上で、もう一度ビルドしてみましょう。
#+BEGIN_SRC shell
  guix build -L /path/to/your/channel/ my-texlab
#+END_SRC

ここまで正しくできていれば、ビルドが成功しているはずです。
=my-texlab= がインストールされた環境に入って確かめてみましょう。 =--pure= でも =--container= でも構いません。
#+BEGIN_SRC shell
  guix shell -L /path/to/your/channel/ my-texlab --container -- texlab --version
#+END_SRC
=--= による環境での即時実行を使ってみました。該当環境で =texlab --version= を実行しています。ここでバージョンが出力されたら成功です!!

** トラブルシューティング
この章では、 =binary-build-system= を用いた場合に経験した諸トラブルを扱います。
今後追記するかもしれません。

*** =validate-runpath= フェイズでGuileがエラーを吐いてしまう
=validate-runpath= において、以下のようなエラーが出ることがあります。
#+begin_example
  wrong-type-arg "struct-vtable" "Wrong type argument in position ~A (expecting ~A): ~S" (1 "struct" #f) (#f)
#+end_example
このエラーは、 =#:strip-binaries?= 引数に =#:f= を与えると解消します。
この引数によって =strip=  フェイズが無効化されますが、これは主にデバッグ情報を取り除くものらしく、
少なくとも私の手元ではこれによって動作に影響が出たことはありません。

** 最後に
今回はバイナリを直接インストールするパッケージの定義方法を説明しました。
=binary-build-system= において、今回出てきた =ld-linux-x86-64.so.2= (=glibc=)と =libgcc= (=gcc:lib=)の解消はかなりの頻度で求められるので、
覚えておくとよいです。

重ね重ねになりますが、 =binary-build-system= は少なくとも GNU哲学において推奨されるものではないため、
GNU直属のコミュニティで喧伝するのは控えたほうがよいです。
しかし、一方で一般的なユーザーにとって便利であることも事実です。
バイナリから直接インストールする危険性は念頭に置きつつも、上手に使っていきましょう。

また、AppImageなどの一部のバイナリについては、この方法ではインストールできず、どうやってインストールするのか私にはわかりません。
成功した方やなにか情報があるかたは気軽にご連絡ください。
どうしてもパッケージの作成が成功しない場合のサブとして、[[https://flatpak.org/][Flatpak]]というパッケージマネージャを利用する人が多いようです。

またまた前回と同じ締めですが、もしなにか質問などあれば、コメントなりメールなりで受け付けます。
また、Guixの日本語コミュニティである[[https://guix-jp.gitlab.io/][Guix-jp]]もあります。
そちらには私以上のエキスパートの人がいますので、是非そちらもご興味あれば覗いてみてください。
もちろんそちらでも質問などをお受けいたします。

* TODO micを使って自分だけのuse-pacakgeを定義し、init.elを管理する
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-48b1a128-e423-8444-202b-3c25fd244198
  :END:
* TODO GNU Guixとはなにか
  :PROPERTIES:
  :EXPORT_FILE_NAME: 2022-0a6933eb-cb7e-7cd4-db1b-af5a8571d6d5
  :EXPORT_HUGO_TAGS: GNU-Guix GNU-Guix-System advent-calendar
  :END:
** 序文
この記事では、GNU Guixというパッケージマネージャ、及びそれと密に関連するGNU Guix SystemというLinuxのディストロを紹介します。
** TL;DR
- GNU Guixは汎用パッケージマネージャ
  - =apt= などと共存可能
  - 環境を自由にいったりきたりできる(=guix package --roll-back= 、 =guix shell=)
  - 環境を宣言的に記述できる(=manifest.scm=)
  - パッケージ定義群を自分で書いて自分で使える(=~/.config/guix/channels.scm=)
- GNU Guix SystemはLinuxのディストロ
  - 標準でGNU Guixが搭載
  - パッケージだけでなく、カーネル自体やカーネルオプションなども宣言的に記述可能(=config.scm=)
** GNU Guixとは？
GNU Guixは、パッケージマネージャの一種です。
パッケージマネージャには =npm= 、 =cargo= 、 =opam= のような言語特化のものと、
=apt= や =yum= のような汎用のものがありますが、GNU Guixは後者、すなわち汎用パッケージマネージャにあたります。
汎用なパッケージマネージャは通常OS標準のものを使うと思います。
GNU Guixはどのようなディストロにも後から入れられて、OS標準のパッケージマネージャと干渉することはないので、
少しずつ乗り換えることも可能です。

GNU Guixの最大の特徴は、「環境を自由にいったりきたりできる」ということです。
あるパッケージを入れたけどやっぱり微妙だったとか、なんか動作が不調になったとかがあれば、すぐに元に戻せます。
また、一時的に全く別の環境(つまり現環境とは全く別のパッケージ群の入った環境)に入ったり、
今の環境に追加で新しいパッケージを入れた新環境を一時的に使う、といったことが可能です。
さらに、ファイルシステムを完全に切り離したコンテナ環境を用意することも可能です。望むならdockerイメージも生成できます。

もうひとつ特徴を挙げるとすれば、「環境を宣言的に記述できる」ところです。
=manifest.scm= と呼ばれるファイルで環境を記述しておけば、誰のPCでもその環境を用意して実行が可能ですし、
新しいパソコンを買ったあとの環境構築も自動化できます。
このあたりはdockerを始めとしたコンテナ技術と雰囲気が近いかもしれませんが、デフォルトの環境、一時的な環境、コンテナの環境のすべてを
統一的に扱っているという点では少し異なります。
ちなみに、 =manifest.scm= はSchemeというプログラミング言語で書かれているため、やろうと思えばだいたいなんでもできます。

さらにもう一つ推しポイントがあります。それは、「パッケージ定義群を自分で書いて自分で使える」ということです。
これは地味ですがかなり便利です。
=apt= で「あれ、あのパッケージデフォルトにないのか、どうやってやるんだっけな、検索しよ」というのをUbuntu入れ直すたびにやっている私としては革命でした。
一度パッケージ定義を書いておけば、あとはGNU Guixを経由して入れるだけでよいです。
さらに言えば、GNU Guix経由でパッケージを入れておけば、前述のメリットが全て享受できます。
すなわち、環境をいったりきたりしたり、宣言的に記述したりという対象に、新しく自分で定義したパッケージも含めることができます。
**
