+++
title = "grugru.el ― カーソル下のthingをじゅんぐりに入れ替える"
author = ["ROCKTAKEY"]
date = 2020-08-04T00:00:00+09:00
lastmod = 2021-11-15T01:21:44+09:00
tags = ["Emacs", "Emacs-Lisp", "grugru"]
draft = true
+++

この記事は、[Emacs Advent Calendar 2021](https://qiita.com/advent-calendar/2021/emacs)の記事です。


## 導入 {#導入}

さてみなさん、突然ですが、コードを書いていて、「あっやっぱり `true` じゃなくて `false` だった」
「 `&&` じゃなくて `||` だった」などということが多々あるのではないでしょうか。そして、往々にして、
入れ替えることになる組み合わせは決まっているのではないでしょうか。こういうとき、いちいちバックスペースを
連打して打ち直すのは、思考のノイズになってしまってよくありません。そこで、単一のコマンドを使って、
あらかじめ登録しておいた一連の `thing` をじゅんぐりに出してくれる `grugru.el` というパッケージを開発しました。

{{< figure src="https://gh-card.dev/repos/ROCKTAKEY/grugru.svg" link="https://github.com/ROCKTAKEY/grugru" >}}

とりあえず使ってみたい人は、 `M-x package-install RET grugru RET` してください
(インストールできない場合は、[ここ](https://emacs-jp.github.io/packages/package)を参照)。
その後、

```emacs-lisp
(grugru-default-setup)
(global-set-key (kbd "C-:") #'grugru)
(grugru-highlight-mode)
```

を評価するなり `init.el` に貼り付けて再起動するなりしてみましょう。すると、じゅんぐりに変えられる
`thing` をハイライトしてくれるようになります。そこで `C-:` を押下すると、次の `thing` へと置き換えてくれます。

口で言ってもわかりにくいので、例として、C++の以下のようなソースコードを開いてみましょう。

```cpp
#include <iostream>
#include <vector>
#include <array>
#include <deque>

class c{
private:
    float f;
};

int main(){
    bool b = false;

    std::vector<int> v(1, 1);

    double d;

    std::cin >> d;

    if (d || b) {
        std::cout << d << "\n";
    } else {
        std::cout << b << "\n";
    }

    return 0;
}
```

ここにある シンボルはほとんどが `grugru` 可能です。以下にgifを置いておきます。
適当なところにカーソルをもっていって、ハイライトされたら `C-:` を押してみてください。
連打してもよいです。実際に使ってみたgifを以下においておきます。

<a id="org29af710"></a>

{{< figure src="https://raw.githubusercontent.com/ROCKTAKEY/images/35e323db33f4da1545c289f2741782c4ac04968b/c++-mode.gif" caption="Figure 1: C++におけるgrugruのデモ" >}}


## 自分で定義する {#自分で定義する}

ここでは `grugru-default-setup` を使ってあらかじめ用意されたものを `grugru` していますが、
自分で定義することも可能です。定義するための関数は主に3つあります。

-   `(grugru-define-global GETTER STRINGS-OR-FUNCTION)`
-   `(grugru-define-on-major-mode MAJOR GETTER STRINGS-OR-FUNCTION)`
-   `(grugru-define-local GETTER STRINGS-OR-FUNCTION)`

書き方はとても簡単です。 `GETTER` の部分には、 `symbol` 、 `word` 、 `char` など、
どの範囲をひとつの `thing` としてみなすかを指定します。
`STRINGS-OR-FUNCTION` には、 `grugru` したい一連の文字列のリストを渡します。
`grugru-define-global` はEmacs全体を通じてそれらの文字列が `grugru` できるようになり、
`grugru-define-on-major-mode` は `MAJOR` で指定したメジャーモード(リストによる複数指定可)全体、
`grugru-define-local` は現在のバッファのみで `grugru` できるようになる、という違いがあります。
書き方の例を示します。

```emacs-lisp
(grugru-define-global 'word '("aaaa" "bbbb" "cccc"))
(grugru-define-on-major-mode '(c-mode c++-mode) 'symbol '("unsigned" "signed"))
(grugru-define-local 'char '("a" "b" "c"))
```

また、 `grugru-define-global` と `grugru-define-on-major-mode` はいっぺんに定義するためのマクロが
用意されています。以下の3つは全て等価になります(上2つはLispの文法上等しい)。

```emacs-lisp
(grugru-define-multiple
 (fundamental-mode
  . ((word . ("aaa" "bbb" "ccc"))
     (symbol . ("xxx" "yyy" "zzz"))
     (word . ("abc" "def" "ghi"))))
  (word . ("aaaa" "bbbb" "cccc"))
  (symbol . ("xxxx" "yyyyy" "zzzzz"))
  (word . ("abcd" "defd" "ghid")))

(grugru-define-multiple
 (fundamental-mode
   (word "aaa" "bbb" "ccc")
   (symbol "xxx" "yyy" "zzz")
   (word "abc" "def" "ghi"))
  (word "aaaa" "bbbb" "cccc")
  (symbol "xxxx" "yyyyy" "zzzzz")
  (word "abcd" "defd" "ghid"))

(progn
  (progn
     (grugru-define-on-major-mode 'fundamental-mode 'word '("aaa" "bbb" "ccc"))
     (grugru-define-on-major-mode 'fundamental-mode 'symbol '("xxx" "yyy" "zzz"))
     (grugru-define-on-major-mode 'fundamental-mode 'word '("abc" "def" "ghi")))
   (grugru-define-global 'word '("aaaa" "bbbb" "cccc"))
   (grugru-define-global 'symbol '("xxxx" "yyyyy" "zzzzz"))
   (grugru-define-global 'word '("abcd" "defd" "ghid")))
```

ちなみに、複雑な `grugru` にも対応すべく、~GETTER~ や `STRING-OR-FUNCTION` には関数を
与えることが可能になっています。詳細はここでは省きますが、
`GETTER` は引数なしでカーソル位置から `thing` の始点と終点のコンスセルを返し、
`STRING-OR-FUNCTION` は第一引数として貰った候補が有効なら次の候補(第二引数が `non-nil` なら前の候補)
を返せばよいです。


## local な `grugru` をinteractiveに定義する {#local-な-grugru-をinteractiveに定義する}

実は、 `grugru-define-local` は、interactiveに定義することができます。
バッファ使い捨ての `grugru` をぱっと定義したいときに有用です。実行すると、単に置換したい
2つの文字列を聞かれます。略語の展開のような意図で使うことを想定しているため、デフォルトの `GETTER` は
「カーソルから1つ目の候補の文字列の長さ分前に戻った部分まで」となっています。
また、リージョンがアクティブなら中身を2つ目の文字列として自動で入力されます。
もし `GETTER` や置換したい文字列の数を指定したい場合は、前置引数 `C-u` を付けて実行してください。

<a id="org36b3e1a"></a>

{{< figure src="https://raw.githubusercontent.com/ROCKTAKEY/images/698f33489645a6e7b0c29d879771dbb15fa3fcd9/grugru-define-local.gif" caption="Figure 2: `grugru-define-local` をinteractiveに使う" >}}


## 選択肢の中から `grugru` を選んで適用する {#選択肢の中から-grugru-を選んで適用する}

さて、たくさんの `grugru` を定義すると、同じ `thing` に対して複数の `grugru` 候補がある場合が出てくる
かもしれません。その場合、 `grugru` コマンドは単に一番優先度の高いものを実行します。優先度は
「local>major-mode>global」になっていて、同じ優先度の中では「後に定義されるほど強い」というふうに
なっています。

しかし、せっかく定義しても使えなければ意味がありません。そこで、 `grugru-select` というものが用意
されています。とても素直な関数なので使ってみればわかると思いますが、
(あれば)複数の `grugru` 候補の中から適用したいものを選択し、さらにどの文字列へと置換するのかを選択する、
というものです。この関数は、複数の `grugru` 候補がある場合だけでなく、 `grugru` をたくさん連打しないと
目的の文字列まで到達できない時に、絞り込みによって一気に到達するのにも有用です。画像では使って
いませんが、 `ivy` などの候補選択ライブラリと一緒に使うとより快適だと思います。

<a id="orge366616"></a>

{{< figure src="https://raw.githubusercontent.com/ROCKTAKEY/images/netlify/2021-eb9f86f0-ee65-1824-4063-ed0d0ba15dbf/grugru-select.png" caption="Figure 3: `grugru-select` による置換先の選択画面" >}}


## `grugru` を再定義する {#grugru-を再定義する}

`grugru` を実行して、やっぱりこれは違うな、と思ったとき、その場でサクっと再定義できると便利ですよね。
設定ファイルにこだわりがない場合は、 `grugru-edit` を利用するとよいです。現在のカーソルで有効な、
`grugru-define-global` と `grugru-define-on-major-mode` で定義した `grugru` を再定義できます。
ここで再定義した値は `grugru-edit-save-file` に保存されます。
`init.el` に以下のような記述をすれば、その設定は次回起動時にも読み込まれます。

```emacs-lisp
(grugru-edit-load)
```

保存されたファイルは単なるEmacs Lispの式ですので、気に入らないことがあれば手で編集しても構いません。

ただし、これを使うと設定が分散してしまうので、 `init.el` に設定を集約することにこだわりがある人には
おすすめできません。 `leaf` のキーワードにも対応していますし、当然直接定義を書いても問題ないので、
そういう人は素直に `init.el` に書いてください。

再定義関数は `grugru-redefine-*` のような名前になっていて、最後の引数として新しい `STRING-OR-FUNCTION`
を与えることで再定義できます。 `nil` を与えれば無効にできます。
`init.el` に直接書く場合、自分で定義したものは書き換えれば済むので、
主にデフォルトの挙動を変えたいときに使うことになりそうです。


## 独立した `grugru` を定義する {#独立した-grugru-を定義する}

ここまで、なるべく負荷を減らすべく、 `grugru` という単一のコマンドによって `thing` の置換を
行うようにしてきました。しかし、時には、もしくは人によっては、「いくつかの `thing` だけを
置換するようなコマンドを独立して定義したい」ということがあると思います。そういう人のために、
`grugru-define-function` というものが用意されています。基本的な引数は `defun` に準じます。
`body` 部の文法はメジャーモード指定ができない以外は `grugru-define-multiple` と同様です。
たとえば以下の `three-state` は、"water"、"ice"、"vapor"の3つと、"solid"、"liquid"、"gas"の3つ
のみを順に置換することができ、それ以外はいっさい置換できません。

```emacs-lisp
(grugru-define-function three-state ()
 "Docstring. This is optional."
 (symbol . ("water" "ice" "vapor"))
 (symbol . ("solid" "liquid" "gas")))
```


## 結論 {#結論}

ここに書ききれていないことも多々ありますので、詳細は[README.org](https://github.com/ROCKTAKEY/grugru#readme)
を見てね!!みなさんも `grugru` といっしょに、ストレスのないコーディングを楽しみましょう!!


## お願い {#お願い}

私があまり知らない言語では、どのような `thing` が置換されうるのかが分からないため、デフォルトが
あまり充実していないのが現状です。issueでもPRでも、SlackやTwitterのDMでも構いませんし、
フォーマットの有無や日本語英語も問いませんので、どの言語(どれかひとつの言語で構いません)に
どのような `grugru` できそうなペアがあるか(1つだけでも構いません)、教えていただけると嬉しいです。

あと、良かったら投げ銭してってね!
